# 编程入门

## 计算机概述

> 计算机包括硬件(hardware)和软件(software)两部分。硬件包括计算机中可以 看得见的物理部分。而软件提供看不见的指令。这些指令控制硬件并且使得 硬件完成特定的任务。

***

## 计算机硬件介绍

> 冯●诺依曼体系结构是现代计算机的基础，现代很多计算机都是以该体系为组织结构，只是做了一些改进而已，并没有突破该体系的束缚，冯诺依曼因此也被称为计算机之父

***

### 中央处理器CPU

> + CPU是计算机的大脑，作用是从内存中获取指令并执行这些指令
>
> + CPU包括：控制单元(control unit)和算术/逻辑单元(arithmetic/login unit)
>   + 控制单元：用于控制和协调其他组件的动作。
>   + 算术/逻辑单元：用于完成数值运算(+、-、*、/)和逻辑运算(比较)。
>
> + 每台计算机都有一个内部时钟，该时钟以固定速度发射电子脉冲。时钟速度越快，在给 定的时间段内执行的指令就越多。速度的计量单位是赫兹(Hz)，1Hz相当于每秒1个脉 冲。随着CPU速度不断提高，目前以千兆赫(GHz)来表述。
>
> + 最初一个CPU只有一个核(core)。核是处理器中实现指令读取和执行的部分。一个多核 CPU是一个具有两个或者更多独立核的组件。可提高CPU的处理能力。

***

### 存储设备

> + 内存中的信息在断电时会丢失，所以我们考虑将程序和数据永久地保留在存储设备上，当计算机确实需要这些数据时，再移入内存，因为在内存中读取比从存储设备要快得多
> + 存储设备主要有以下三种
>   + 磁盘驱动器：每台计算机至少有一个硬盘驱动器，硬盘(hard disk)用于永久地保存程序和数据
>   + 光盘驱动器（(CD和DVD)）：CD的容量可达700MB；DVD的容量可达4.7GB。
>   + USB闪存驱动器：Universal Serial Bus，通用串行总线。 可以使用USB将打印机、数码相机、鼠标、外部硬盘驱动器连接到计算机上。 USB闪存驱动器很小，可用于存储和传输数据的设备。

***

### 内存的单位

> + 在讨论内存前，先清楚数据是如何存储在计算机中的。
> + 计算机就是一系列的电路开关。每个开关存在两种状态：关(off)和开(on)。如果电路 是开的，它的值是1。如果电路是关的，它的值是0。
> + 比特bit：一个0或者一个1存储的为比特bit，是计算机中最小的存储单位
> + 字节byte
>   + 计算机中最基本的存储单位是字节，每个字节由8个比特bit构成
>   + 计算机的存储能力是以字节和多字节来衡量的
>     + 千字节KB=1024b
>     + 兆字节MB=1024KB
>     + 千兆字节GB=1024MB
>     + 万亿字节TB=1024GB

***

### 内存的概念

> + 内存也叫RAM（Random-Access Memory），由一个有序的字节序列组成，用于存储程序及程序需要的数据
> + 一个程序和它的数据在被CPU执行前将被移入内存中
> + 每个字节都有唯一的地址
> + 一个计算机的RAM越多，运行速度就越快，但是此规律是有限制的，涉及到使用率，若一个内存不够用，扩大内存还是会提升速度，若本身就够用，再扩大内存空间使用率都差不多，就没有明显的速度提升
> + 内存也与CPU一样嵌入在数百万晶体管的硅半导体芯片上，但内存芯片更简单更低速更便宜
> + 内存的存取速度要比硬盘快超过十倍，当然CPU快不知道多少倍
> + 内存是带电存储的，一旦断电数据就会丢失，而且容量有限，所以要长时间存程序和数据需要使用硬盘
> + 内存有两个作用
>   + 保存从硬盘读取到的数据并提供给CPU使用
>   + 保存CPU执行后的结果，以便CPU再次使用，或者保存到硬盘

***

### 输入输出设备

> + 常见的输入设备：键盘（keyboard）和鼠标（mouse）
> + 常见的输出设备：显示器（monitor）和打印机（printer）
> + 显示器屏幕分辨率：是指显示设备水平和垂直方向上显示的像素(px)数。
>   + 分辨率可以手工设置
>   + 分辨率越高，图像越清晰，越锐化

***

### 通信设备

> + 计算机可以通过通信设备进行联网。
> + 常见的设备有：
>   + 拨号调制解调器：使用的是电话线，传输速度可达56000bps（bps每秒比特）
>   + DSL数字用户线：使用的也是电话线但传输速度比上面快20倍
>   + 电缆调制解调器：利用有线电视电缆进行数据传输，通常速度比DSL快
>   + 网络接口卡：将计算机接入局域网LAN，局域网用于大学商业组织等速度甚至可达1000Mbps
>   + 无线网络：通过无线适配器连接到局域网或因特网

***

## 计算机发展史上的鼻祖

+ 阿兰●图灵：计算机领域最高奖项为图灵奖
+ 冯●诺依曼：理论的要点是计算机数制采用二进制，计算机应该按照程序顺序执行

***

## 操作系统

> 操作系统是运行在计算机上最重要的程序，他可以管理和控制计算机的活动
>
> 操作系统主要任务
>
> + 控制和监视系统的活动
> + 分配和调配系统资源
> + 调度操作

***

## 万维网与软件架构

> 万维网又称为web：分为web客户端和web服务端
> 	www可以用web客户端访问web服务端上的页面，是一个由许多互相链接的超文本组成的系统，通过互联网访问，在这个系统中每一个有用的事物称为资源，并且有一个全局统一资源标识符URI标识，这些资源通过超文本传输协议（http）传输给用户，而用户通过点击链接获得资源
>
> 万维网是无数个网络站点和网页的集合，他们在一起构成了因特网最主要的部分，他实际上是多媒体的集合，是由超级链接连接而成的，我们通常通过浏览器上观看的就是万维网的内容
>
> 互联网包含因特网包含万维网
>
> 软件架构分为两种
>
> + BS架构：通过浏览器访问服务器
> + CS架构：通过客户端访问服务器

***

## 职业发展与提升

> 工作中学习70%，尽量是技术熟悉一两年后去把握机会

***

## 学习经验探讨

> 三分看，七分练

***

# 第一章  Java语言概述

## 软件开发介绍

> + 软件开发：软件即一系列按照特定顺序组织的计算机数据和指令的集合，有系统软件和应用软件之分
>
> + 人机交互方式
>   + 图形化界面：这种方式简单直观，用户易于接受且容易上手操作
>   + 命令行方式：需要有一个控制台，输入特定的指令，让计算机完成特定的操作，较为麻烦，需要记录一些命令
>     + 常用的DOS命令
>       + dir：列出当前目录下的文件及文件夹
>       + md：创建文件夹
>       + rd：删除文件夹——需要保证文件夹是空的
>       + cd：进入指定文件夹
>       + cd..：返回上一级
>       + cd/：返回到根目录
>       + del：删除文件/删除文件夹内的所有文件
>       + exit：退出DOS命令行
>     + 常用快捷键
>       + ← →：移动光标
>       + ↑ ↓：调阅历史操作命令
>       + Delete和Backspace：删除字符

***

## 计算机编程语言介绍

> + 什么是计算机语言：
>   + 语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而 中国人要和英国人交流，就要学习英语。
>   + 计算机语言：人与计算机交流的方式；如果人要与计算机交流，那么就要学习计算机语言。 计算机语言有很多种。如：C ,C++ ,Java ,PHP , Kotlin，Python，Scala等。
> + 第一代语言：机器语言——指令以二进制代码存在
> + 第二代语言：汇编语言——使用助记符表示一条计算机指令
> + 第三代语言：高级语言——面向过程的语言/面向对象的语言

***

## Java语言概述

> + Java是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一 门高级编程语言
>
> + Java是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以 在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使 用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中
> + 随着Java技术在web方面的不断成熟，Java已经成为Web应用程序的首选开发语言
> + Java版本类型
>
>   + JavaEE：企业版——主要用于开发web应用后台，此前成为J2EE
>   + JavaSE：标准版——适合开发桌面级应用，此前成为J2SE
>   + JavaME：小型版——主要用于手机终端，此前成为J2ME
> + Java的应用领域
>   + 企业级应用
>   + 安卓平台应用
>   + 大数据平台开发
>
> + Java语言的特点
>   + 是一种类C语言
>   + 纯粹的面向对象的程序设计语言
>   + 舍弃了C语言中容易引起错误的指针
>   + 增加了垃圾回收器功能

***

## Java程序的运行机制及运行过程

### Java语言的特点

> + 面向对象性：具有类和对象两个基本概念
> + 健壮性：吸收了C语言的优点，去掉了其影响健壮性的指针，内存的申请与释放等，提供了一个相对安全的内存管理和访问机制
> + 跨平台性：
>   + 因为有了JVM，同一个Java程序在三个不同的操作系统【win、linux、mac】中都可以执行，不同操作系统的JVM是不同的
>   + 通过Java语言编写的应用程序可以在不同的系统上运行，只需要在运行Java应用程序的操作系统上安装一个Java虚拟机，由虚拟机来负责Java应用程序的运行

***

### JVM与垃圾回收机制

#### Java虚拟机(Java Virtual Machine)

> + JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器
> + 对于不同的平台，有不同的虚拟机
> + 只有某平台提供了不同的虚拟机，Java程序才能在此平台上运行
> + Java虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行

***

#### 垃圾收集机制(Garbage Collection)

> - 不再使用的内存空间应该回收
>   - 在C等语言中，内存回收需要程序员负责执行
>   - Java语言消除了程序员回收内存的责任，提供了一种系统级线程跟踪存储空间的分配情况，并在JVM空闲时，检查并释放那些可被释放的存储空间
> - 垃圾回收机制在Java程序运行过程中自动执行，程序员无法精确控制和干预
> - 即使如此，Java程序依然会出现内存泄露和溢出的问题【我们有时写的程序使得垃圾回收不能够识别，回收不了】

***

## Java环境搭建

### JDK与JRE的理解

**什么是JDK（Java Development Kit  Java开发工具包）**

> JDK是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE，所以安装了JDK就不用单独安装JRE了【其中的开发工具：编译工具javac.exe、打包工具jar.exe等等】
>
> ==JDK =  JRE + 开发工具集==

**什么是JRE（Java Runtime Environment  Java运行环境）**

> 包括Java虚拟机和Java程序所需要的核心类库等，若想要运行一个开发好的Java程序，计算机只需要安装JRE即可
>
> ==JRE = JVM + JavaSE标准类库==

+ JDK包含JRE包含JVM
+ 简单而言，使用JDK开发工具完成的Java程序，交给JRE运行

***

### 下载并安装JDK

**下载的官方网址**

+ www.oracle.com
+ https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html

**安装JDK1.8**

> 下一步→选择==源代码==→安装路径可更改→安装即可
>
> 跳出窗口要求安装独立的JRE→更改路径安装即可，避免之后出问题，因为eclipse需要识别独立的JRE

**具体安装步骤：**

+ 傻瓜式安装，下一步即可，选择源代码
+ 安装路径不要有中文或空格以及其他特殊符号
+ 若操作系统是64位的尽量选择64位的JDK
+ 当提示安装JRE时，正常的JDK安装时已经安装过了，但是为了后续使用Eclipse开发工具时不报错，建议根据提示另外选择路径安装独立的JRE

***

### 环境变量的配置

+ 计算机→属性→环境变量
+ 新建环境变量【统一配置在系统变量中保险】
  + 变量名：==JAVA_HOME==【之后的Tomcat会来找JAVA_HOME，所以按照这样的格式配置好会避免很多麻烦】
  + 变量值：==E:\Develop\Java\jdk1.8.0_291==
+ 添加path环境变量：==%JAVA_HOME%\bin==【配置成功后在任何目录下都可以访问开发工具集，没有path可以自建path，建议置顶】
+ 配置成功后，可以通过cmd进行测试相关指令

***

## 开发体验-HelloWorld

**步骤**

+ 将Java代码编写到扩展名为.java的文件中
+ 通过javac命令对该文件进行编译：==javac  xx.java==
+ 通过java命令对编译生成的字节码文件进行运行：==java  xx==

***

## 常见问题及解决方法

+ 可以不要配置classpath
+ 注意严格区分大小写
+ 分号不要忘记

***

## Java注释（Comment）

> 用于注解说明解释程序的文字就是注释，注释掉的内容是不参与编译的，字节码文件中不包含有注释信息

### Java中的注释类型

```java
//单行注释

/*
	多行注释
*/

/**
	文档注释:Java所特有的注释
	@author 指定Java程序的作者
	@version 指定源文件的版本
*/
```

***

### 注释的意义

+ 对所写的程序进行解释说明，增强了代码可读性，方便自己，方便别人
+ 调试所写的代码
+ 注释了的内容不参与编译，即编译生成的.class字节码文件不包含注释内容
+ 注释是一种良好的编程习惯
+ 将自己的思想通过注释先整理出来再通过代码去体现

***

### 文档注释的作用

+ 文档注释是Java特有的注释
+ 文档注释的内容可以被JDK工具javadoc所解析，生成一套由网页文件形式体现的该程序的说明文档
+ 生成网页说明文档的cmd操作方式：javadoc -d 目标文件夹名称  -author  -version  xx.java
+ 打开生成的文件夹，点击index.html即可查看文档

***

### 多行注释使用的一个注意点

> 多行注释不能够嵌套使用

***

## JavaAPI文档

+ API（Application Program Interface）是Java提供的基本编程接口

+ 全称应用程序编程接口，是Java提供给我们的基本编程接口，犹如程序的字典，不会的就查查看
+ Java提供了大量的基础类，因此Oracle也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类以及类中包含的方法
+ API下载路径：http://www.oracle.com/technetwork/java/javase/downloads/index.html

***

## 第一个Java程序的总结

**Java程序编写-编译-运行的过程**

+ 编写
  + 我们将编写的Java代码保存在后缀名为.java的源文件中
  + 在一个Java源文件中，可以声明多个class类，但是最多只能有一个类声明为public，且声明为public的类的类名需要与文件名一致
  + 程序的入口为main（）方法，且格式是固定不变的
  + 常用输出语句为
    + System.out.println()：输出之后进行换行操作
    + System.out.print()：输出之后不进行换行
  + 每一条执行语句都以分号结束
+ 编译
  + 使用javac.exe命令编译java源文件
  + 格式为：==javac  源文件名.java==
  + 编译之后，会生成一个或多个字节码文件，字节码文件的文件名与源文件中的类名一致，即一个源文件中有多个类，那么编译之后就会生成多个类对应的字节码文件
+ 运行
  + 使用java命令解释运行我们的字节码文件
  + 格式为：==java 类名==

***

## 良好的编程风格

### 正确的注释和注释风格

+ 使用文档注释来注释整个类或整个方法
+ 若注释的是某条语句或步骤可使用单行或多行注释

***

### 正确的缩进和空白

+ 使用一次tab操作实现缩进
+ 运算符两边习惯性加上空格隔开

***

### 块的风格

+ 行尾风格（推荐）
+ 次行风格

***

## 常用的Java开发工具

+ Eclipse
+ IDEA

***

# 第二章 Java基本语法

## 关键字和保留字

### 关键字的定义与特点

> 定义：关键字是被Java语言赋予了特殊的含义，用作专门用途的单词
>
> 特点：所有的关键字都是小写的

①用于定义数据类型的关键字
	class  interface  enum  byte  short int  long  float  double  char  boolean	void			
②用于定义数据类型值的关键字
	true	false	null		
③用于定义流程控制的关键字
	if  else  switch  case  default  while  do  for  break  continue  return	
④用于定义访问权限修饰符的关键字
	private  protected  public		
⑤用于定义类，函数，变量修饰符的关键字
	abstract  final  static  synchronized	
⑥用于定义类与类之间关系的关键字
	extends  implements			
⑦用于定义建立实例及引用实例，判断实例的关键字
	new  this  super  instanceof	
⑧用于异常处理的关键字
	try  catch  finally  throw  throws
⑨用于包的关键字
	package  import			
⑩其他修饰符关键字
	native  strictfp  transient  volatile  assert

***

### 保留字

> 现有的Java版本尚未使用，但以后的版本可能会作为关键字使用，命名时避免使用保留字
>
> 保留字有：byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const

***

## 标识符（Identifier）

> Java对各种变量、方法和类等要素命名时使用的字符序列成为标识符，即凡是自己可以起名字的地方都称为标识符
>
> 为了提高阅读性，命名时尽可能地见名知意
>
> Java采用Unicode字符集，标识符也可以使用中文声明，但是及其不建议

### 定义合法标识符的规则

> 不遵守这个规则，则编译无法通过

+ 由26个英文字母大小写，0-9，_ 或 & 符组成
+ 数字不能作为标识符开头
+ 不可以使用关键字和保留字，但可以包含
+ Java严格区分大小写，长度无限制
+ 标识符中不能包含空格

***

### Java标识符命名规范

> 若不遵守该规范，编译也能通过，建议遵守

+ 包名：多单词组成的所有字母都小写【xxyyzz】
+ 类名、接口名：多单词组合时，所有单词首字母大写【XxYyZz】
+ 变量名、方法名，多单词组合时，第一个单词首字母小写，后面单词首字母大写【xxYyZz】
+ 常量名：所有字母都大写，多单词组合时，每个单词之间用下划线进行连接【XXX_YYY_ZZZ】

***

### 使用标识符的注意点

+ 在起名称时，为了提高代码阅读性，尽量见名知意
+ Java采用Unicode字符集，所以命名时也可以采用中文命名，但是极其不建议使用

***

## 变量

### 变量的概念

+ 内存中的一个存储区域
+ 该区域的数据可以在同一类型范围内不断变化
+ 变量是程序中最基本的存储单元。包含==变量类型、变量名和存储的值==

***

### 变量的作用

> 用于在内存中保存数据

***

### 使用变量时的注意点

+ Java定义变量的格式：数据类型 变量名 = 变量值

+ 变量必须先声明后并初始化后才可以使用
+ 使用变量名来访问这块区域的数据
+ 变量的作用域：其定义所在的一对花括号{}内
+ 变量只有在其作用域内才有效，出了作用域就失效了
+ 同一个作用域内不可以声明两个同名的变量

***

### 变量的分类

> Java整型变量与常量通常定义为int型，声明为long型常量后需要加上L结尾，若没加L，若该常量值在int型表数范围内，属于自动类型提升，若不在范围内，则编译失败
>
> Java程序中变量通常声明为int型，除非不足以表示较大的数才使用long型
>
> 浮点型常量通常有两种表示方式
>
> + 十进制数形式【5.12】
> + 科学计数法形式【5.12e2】
>
> Java的浮点型常量默认为double型，通常定义浮点型数据使用double，声明为float型常量时，一定要在值后面加上F，否则编译失败，类型需要向下强转，因为默认为double型
>
> 定义char型变量，通常使用单引号''，单引号内部只能写一个字符
>
> boolean只能取true和false两个值

#### 按照数据类型分类

> 对于每一种数据都定义了明确的具体数据类型（强类型语言），且不同类型在内存中分配了不同大小的存储空间

##### 基本数据类型

+ 数值型
  + 整型
    + byte【占1字节】：取值范围：-128～127
    + short【占2字节】
    + int【占4字节】
    + long【占8字节】
  + 浮点型
    + float：【占4字节】
      + 单精度：尾数可以精确到7位有效数字，很多情况下，精度很难满足需求
      + 表示的数值范围比long还大
    + double【占8字节】
      + 精度是float类型的两倍，通常采用该类型声明浮点型数据
+ 字符型
  + char【占2字节】
    + Java中的所有字符都是用Unicode编码，故一个字符可以存储一个字母一个汉字，或其他书面的一个字符
    + 字符型变量的三种表现形式
      + 字符常量使用单引号引起来的单个字符，单引号中必须存在内容 哪怕是一个空格，否则编译错误
      + Java中还允许使用转义字符，来将其后的字符转变为特殊字符型常量：如char  c  =  '\n';
      + 直接使用Unicode来表示字符型常量，如\uxxxx，其中xxxx表示十六进制整数
    + char类型是可以进行运算的，因为每个字符都对应着一个Unicode码
    + 乱码的情况和字符集的说明
      + 世界上存在着多种编码方式，同一个二进制数字
      + ASCII编码
      + Unicode编码
      + UTF-8
        + 是在互联网上使用最广的一种Unicode的实现方式
        + 是一种变长的编码方式，他可以使1-6个字节表示一个符号，根据不同的符号而变化字节长度
        + UTF-8的编码规则
          + 对于单字节的UTF-8编码，该字节的最高位为0，其余七位用来对字符进行编码（等同于ASCII码）
          + 对于多字节的UTF-8编码，该字节的最高位为0，那么第一个字节的前n位为1，第一个字节的n+1位为0，该字节的剩余各位用来对字符进行编码，在第一个字节之后的所有字节，都是最高位两位为10，其余6位用来对字符进行编码
+ 布尔型
  + boolean
    + 只能取两个值
      + true
      + false
    + 常常在条件判断、循环条件中使用

**变量运算规则的两个特殊情况**

+ 声明为long型常量后需要加上L，若没加L，若该常量值在int型表数范围内，属于自动类型提升，若不在范围内，则编译失败
+ 整型常量值默认为int类型，浮点型常量值默认为double类型

***

##### 引用数据类型

+ 类【class】
+ 接口【interface】
+ 数组【array】

***

#### 按照声明位置分类

##### 成员变量

+ 在方法体外，类内部声明的变量称为成员变量
+ 成员变量又分为
  + 实例变量：不以static修饰的变量
  + 类变量：以static修饰的变量

***

##### 局部变量

+ 在方法体内部声明的变量称为局部变量
+ 局部变量又分为
  + 形参：在方法、构造器中定义的变量
  + 方法局部变量：在方法内定义的变量
  + 代码块局部变量：在代码块内定义的变量

***

### 基本数据类型变量之间的转换

>  前提：此处讨论的只能是七种基本数据类型的转换，不包括boolean类型

#### 自动类型转换（byte、short、char→int→long→float→double）

+ 当byte、char、short三种类型的变量之间做运算或这三者之间同种类型做运算时，结果为int类型
+ 当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型（此时的容量大小指的是表数范围的大小，而非内存所占字节大小）

***

#### 强制类型转换（byte、short、char←int←long←float←double）

+ 是自动类型转换的逆运算，需要使用强转符()
+ 强制类型转换可能会造成精度损失

```java
double douNum = 12.3;
int intNum = (int)douNum;//截断操作，精度损失

int i = 128;
byte b = (byte)i;//精度损失

int i = 123;
short j = (short)i;//没有精度损失z
```

***

### 基本数据类型与String间的转换

+ String不是基本数据类型，属于引用数据类型，称之为字符串
+ 使用方式与基本数据类型一致，声明为String变量时要使用双引号“ ”
+ 一个字符串可以连接另一个字符串，也可以连接其他的数据，可以和其他八种基本数据类型做运算，且只能是连接运算，连接运算后的结果为String类型，连接符为+

***

### 进制与进制间的转换

> 所有数字在计算机底层都以二进制形式存在

**对于整数有四种表达方式**

+ 二进制（binary）
  + 表示为0和1，满2进1，以0b或0B开头
+ 八进制（octal）
  + 表示为0-7，满8进1，以0开头
+ 十进制（decimal）
  + 表示为0-9，满10进1
+ 十六进制（hex）
  + 表示为0-F，满16进1，以0x或0X开头，10-15分别为A-F（A-F不区分大小写）

#### 二进制与十进制之间的转换

> 二进制的最高位是符号位，当最高位是0的时候为正数，为1的时候为负数
>
> 计算机底层都以二进制==补码==的方式保存所有的整数数据，不管是正数负数，正数都一样，负数得推出来

**二进制的整数有三种形式**

+ 原码：直接将一个数值转换为二进制数，最高位是符号位
  + 符号位是0为正数
  + 符号位为1为负数
  + 如14的二进制数为0000 1110，则其负数-14的原码为1000 1110，只是对最高位设置为1，其余位数值不变
+ 负数的反码：除了符号位为1不变之外，其余位数取反
+ 负数的补码：对反码进行加1
+ 注意：正数的原码、反码、补码都相同

**二进制转换为十进制举例**

```java
0000 1110  //从后往前算  0*2^0 + 1*2^1 + 1*2^2 + 1*2^3 = 14 以此类推，当然0的话就可以不算入了
1000 1110 //符号位改成1就为 -14的原码
1111 0001//反码：第一位不变，其余的1的反为0 0反为1
1111 0010//补码：加1，-14在计算机底层存储的补码就得到了
  
//给你一个补码  问你十进制是多少？方法就是往回推
1011 1011//补码首先 -1
1011 1010//补码-1后得到反码
1100 0101//反码后得到原码 十进制为1*2^0 + 1*2^2 + 1*2^6 = -69
```

**十进制转换为二进制**

> 方法为除2取余的逆

```java
//计算13的二进制数
13/2= 6...1
6/2 = 3...0
3/2 = 1...1
1/2 = 0...1
0/2 = 0...0//当余数为0时停止，后面再除无意义
//从下往上得到的余数就为二进制数 1101
```

***

#### 二进制与八进制之间的转换

```java
1110//每三个一位合并算出八进制数
001 = 1
110 = 0*2^0 + 1*2^1 + 1*2^2 = 6
//得出八进制为016
//八进制转为十进制 6*8^0 + 1*8^1 = 14
```

***

#### 二进制与十六进制的转换

```java
1110//每四个一位合并算出十六进制数
0*2^0 + 1*2^1 + 1*2^2 + 1*2^3 = 14 --0xE
//十六进制转换为十进制
E*16^0 = 14
```

***

## 运算符

#### 算数运算符

> 取余数运算，结果的正负与被模数符号相同
>
> 开发中，经常使用%来判断是否整除的情况

| 运算符 |      描述      |     示范     |                             结果                             |
| :----: | :------------: | :----------: | :----------------------------------------------------------: |
|   +    |      正号      |      +3      |                              3                               |
|   -    |      负号      |    i=3;-i    |                              -3                              |
|   +    |      加号      |     1+3      |                              4                               |
|   -    |      减号      |     1-3      |                              -2                              |
|   *    |      乘号      |     1*3      |                              3                               |
|   /    |      除号      |     9/3      |                              3                               |
|   %    | 取余数（取模） |     4%2      |                              0                               |
|   ++   |      自增      |   a++;++a    | 先取值后自增;先自增后取值<br />a的值会被改变，且不会改变a本身的数据类型 |
|   --   |      自减      |   a--;--a    | 先取值后自减;先自减后取值<br />a的值会被改变，且不会改变a本身的数据类型 |
|   +    |   连接运算符   | "Hel" + "lo" |                           "Hello"                            |

***

#### 赋值运算符

> 支持连续赋值
>
> 当两侧数据类型不一致时，可以使用强制类型转换或者自动类型提升原则进行处理
>
> 开发中如果希望变量实现 + 1的操作推荐使用==num++==，因为num = num + 1有可能数据类型不一致编译失败，前提是该变量为int型
>
> 开发中如果希望变量实现 + 2的操作推荐使用==num+=2==，因为num = num + 2有可能数据类型不一致编译失败，前提是该变量为int型

| 运算符 | 描述 |
| :----: | :--: |
|   =    | 赋值 |
|   +=   | 累加 |
|   -=   | 类减 |
|   *=   | 累乘 |
|   /=   | 累除 |
|   %=   | 累模 |

***

#### 关系运算符

> 关系运算符又称比较运算符，运算后的结果都是boolean型，只有true或false

|   运算符   |          描述          |           示范            | 结果  |
| :--------: | :--------------------: | :-----------------------: | :---: |
|     ==     |        是否相等        |           3==3            | true  |
|     !=     |        是否不等        |           3!=3            | false |
|     >      |        是否大于        |            4>3            | true  |
|     <      |        是否小于        |            4<3            | false |
|    \>=     |     是否大于或等于     |           4>=3            | true  |
|     <=     |     是否小于或等于     |           4<=3            | false |
| instanceof | 是否是一个类的对象类型 | "Hello" instanceof String | true  |

***

#### 逻辑运算符

> 运算的结果都是boolean类型，开发中推荐使用短路与、短路或

**&与&&的相同点和不同点**

+ 二者运算结果都是相同的
+ 当符号左边是true时，二者都会执行符号右边的运算
+ 当符号左边时false时，&会执行右边的运算，&&不会执行符号右边的运算
+ 推荐使用&&

**|与||的相同点和不同点**

+ 二者的运算结果都是相同的
+ 当符号左边为false时，二者都会执行符号右边的运算
+ 当符号左边为true时，|继续执行右边的运算，||不再执行符号右边的运算
+ 推荐使用‖

| 运算符 |                   描述                    |   示范    | 结果  |
| :----: | :---------------------------------------: | :-------: | :---: |
|   &&   |              与（存在短路）               |  真&&真   |  真   |
|  \|\|  |              或（存在短路）               | 真\|\|假  |  真   |
|   ！   |                非（取反）                 |    !真    |  假   |
|   ^    | 异或（两个一样就是false，不一样就是true） | true^true | false |
|   &    |            单与（不存在短路）             |           |       |
|   \|   |            单或（不存在短路）             |           |       |

***

#### 位运算符

> 位运算是直接对整数的二进制进行的运算，操作的都是整型的数据，位运算是高效的运算
>
> **左移运算**最多移动26位，27位会变为负数，空位补0，被移除的高位丢弃，空缺位补0
>
> **右移运算**被移位的二进制最高位是0，右移后空缺位补0；最高位是1，空缺位补1
>
> **无符号右移**，被移位的二进制最高位无论是0或1，空缺位都用0补
>
> 二进制位进行**与运算**，只有1&1时结果是1，否则是0，二进制各位相比得出的二进制就是结果
>
> 二进制位进行**或运算**，只有0&0时结果是0，否则是1，二进制各位相比得出的二进制就是结果
>
> 相同二进制位进行**异或运算**结果是0，不同二进制位异或运算为1，二进制各位相比得出的二进制就是结果
>
> **正数取反**，包括符号位在内，全部取反得出的二进制就是结果，各二进制码按补码各位取反
>
> **负数取反**，包括符号位在内，全部取反得出的二进制就是结果，各二进制码按补码各位取反
>
> **取反运算**说白就是包括符号位在内，全部1变0，0变1，得到的就是取反运算的结果

| 运算符 |           描述            |     示范      | 结果 |
| :----: | :-----------------------: | :-----------: | :--: |
|   <<   | 左移（每移x位就多乘x个2） | 3<<2---3*2\*2 |  12  |
|  \>\>  | 右移（每移x位就多除x个2） |     3>>1      |  1   |
| \>\>\> |        无符号右移         |     3>>>1     |  1   |
|   &    |          与运算           |      6&3      |  2   |
|   \|   |          或运算           |     6\|3      |  7   |
|   ^    |         异或运算          |      6^3      |  5   |
|   ~    |        取反码运算         |      ~6       |  -7  |

***

#### 三元运算符

> 格式为：(条件表达式) ？A：B;
>
> 条件表达式的结果为boolean类型
>
> 根据条件表达式的真或假，决定执行A或B
>
> 三元运算符可以嵌套使用，凡是可以使用三元运算符的地方都可以改写为if-else，反之则不成立
>
> 如果程序既可以使用三元运算符又可以使用if-else结构，首选三元运算符。效率高

| 运算符 |      描述      |
| :----: | :------------: |
|  ？：  | 也称三目运算符 |

**三元运算符与if-else的联系与区别**

+ 三元运算符可简化为if-else语句，反之可能不行
+ 三元运算符要求必须返回一个结果
+ if后的代码块中可以有多条语句
+ 若程序既可以使用三元运算符又可以使用if-else结构，推荐三元运算符，因为其执行效率高

***

#### 运算符的优先级

> 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序
>
> 只有单目运算符、三元运算符、赋值运算符是从右向左运算的

***

## 程序流程控制

> 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组成能完成一定功能的小逻辑模块
>
> 流程控制采用三种规定的流程结构
>
> + 顺序结构
>   + 程序从上到下逐行地执行，中间没有任何的判断和跳转
> + 分支结构
>   + 根据条件选择性地执行某段代码
>   + 有if-else和switch-case两种分支语句
> + 循环结构
>   + 根据循环条件重复性地执行某段代码
>   + 有while、do..while、for三种循环
>   + JDK1.5提供了foreach循环，方便遍历集合与数组元素
>   + 循环结构的四种组成部分
>     + 初始化部分
>     + 循环条件部分
>     + 循环体部分
>     + 迭代部分

### if-else结构

> else与最近的if配对（就近原则）

```java
//if单选择结构
if(布尔表达式){
  //条件成立则执行该代码体 
}
  
//if双选择结构
if(布尔表达式){
  //条件成立则执行该代码体 
}else{
  //条件不成立则执行该代码体 
}

//if多选择结构
if(布尔表达式){
  //布尔表达式成立执行该代码体
}else if(布尔表达式1){
  //布尔表达式1成立执行该代码体
  ...
}else{
  //都不成立则执行该代码体
}

//嵌套if结构
if(){
  if(){}
}
```

**if-else语句使用说明**

+ 条件表达式必须是布尔表达式、布尔变量
+ 语句只有一条执行语句时，{}可以省略，但是建议保留
+ 可根据需要嵌套使用
+ 当if-else是多选一时，最后一个else是可选的，根据需要可以省略
+ 当多个条件是互斥关系时，条件判断语句与及语句执行顺序是无所谓的
+ 当多个条件为包含关系时，小上大下/子上父下

***

### switch-case结构

> 根据switch表达式中的值，依次匹配各个case中的常量，一旦匹配成功，则执行相应case
>
> 当执行完语句后，则仍然继续向下执行其它case中的执行语句，直到遇到break关键字或此switch末尾结束为止
>
> break可以使用在switch-case结构中，表示一旦执行到此关键字就跳出当前switch-case结构，它是可省略的
>
> default相当于if语句中的else，当case都不满足时执行，default结构也是可选的，而且位置也是灵活的
>
> switch结构中的表达式只能是以下六种类型之一（byte、short、char、int、枚举类对象、String）
>
> case之后只能声明常量，不能声明一个范围
>
> switch语句结构可以转换为if-else结构，反之则可能不成立
>
> 当我们发现switch和if语句都可以实现某段功能时，优先使用switch，因为==效率高==

```java
//switch多选择结构 支持字符串值 case穿透是指没有break的情况下，一直往后执行
switch(表达式){
  case 常量:  break;
  case 常量:  break;
  default:  break;
}

//case合并
switch(表达式){
  case 1:
  case 2:
    System.out.println("匹配1或2都会执行该语句");
    break;
  default:  break;
}
```

***

### Scanner对象

> 我们可以通过Scanner类来获取用户的输入
>
> 基本语法Scanner s = new Scanner(System.in);

```java
Scanner scanner = new Scanner(System.in);
/*
	scanner.next();方法
		一定要读取到有效字符才可以结束输入
		对输入有效字符之前遇到的空格，会自动将其去除掉，只有输入有效字符后才将其后面输入的空格或空白符作为分隔符或结束符
		注意:该方法不能接收到带有空格的字符串
	scanner.nextLine();方法
		以Enter为结束符，该方法返回的是输入回车之前所有的字符，可以获得空格与空白符
	等等方法
	获取字符型数据只能通过获取字符串来获取
	scanner.nextInt();方法：获取一个int范围内的整数
	scanner.nextBoolean();方法：只能输入true/false，否则报异常
	scanner.nextDouble();方法：输入一个数值，自动转为double类型
	scanner对象没有char类型相关的方法，只有字符串类型，可以通过String类型.charAt(int index)的方式提取一个字符
*/
```

***

### 循环结构

> 在某些条件满足的情况下，反复执行特定代码的功能
>
> 写while循环千万不要丢了迭代条件，一旦丢了，就可能导致死循环，我们写程序要尽量避免死循环
>
> for循环和while循环的初始条件的作用范围不同

```java
//while循环  先判断后执行
while(布尔表达式){}

//do while循环  先执行后判断 至少执行一次
do{}while(布尔表达式);

//for循环
for(初始化;条件表达式;条件变化){}

//增强for循环  主要是用于循环数组与集合
for(声明语句 : 表达式){					
  //代码体
}
/*
for(int i : arrayInt) {
	System.out.println(i);
}
*/

//在嵌套循环中，使用带标签的break和continue。
label:for(int i = 1;i < 5;i++){
	for(int j = 1;j <= 10;j++){
		if(j % 4 == 0){
			//break;
			//continue;
			//break label;
			continue label;
		}
		System.out.print(j);
	}
	System.out.println();
}
```

#### while循环使用说明

+ 不要丢了迭代条件，一旦丢了就可能导致死循环
+ 我们写程序要尽量避免死循环
+ for循环和while循环是可以互相嵌套的

***

#### do-while循环的使用说明

+ 至少会执行一次循环体
+ 在开发中使用for和while循环较多

***

#### 嵌套循环的使用

+ 将一个循环A嵌套在另一个循环体B中，就构成了嵌套循环
+ 内层循环遍历了一遍，就相当于外层循环执行了一次
+ 假设外层循环执行m次，内层循环执行n次，则内层循环共要执行m*n次
+ 外层循环控制行数，内层循环控制列数

***

### break&continue

> break用于结束当前循环结构
>
> continue用于终止当次循环，直接进入下一次循环
>
> 二者之后不能声明语句

***

# 第三章 数组

## 数组的概述

> 数组是**多个相同类型的数据**按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理

***

## 数组的常见概念

+ `数组名称`
+ `数组元素`
+ `数组索引`
+ `数组长度`：数组中元素的个数

***

## 数组的特点

+ 数组是**有序的**
+ 数组本身是**引用数据类型**，而数据存储的**元素可以是任何数据类型**，包括基本数据类型和引用数据类型
+ 创建数据对象会在内存中开辟一整块的**连续的存储空间**，而数组名引用的是这块连续空间的**首地址值**
+ 数组的**长度一旦确定就不能够更改**，数组初始化完成其长度就确定了
+ 我们可以通过**下标调用**数组中指定位置上的元素数组按照维度可分为一维数组、二维数组或多维数组，按照元素的数据类型分为基本数据类型元素数组，引用数据类型元素数组（也称对象数组）

***

## 数组的分类

+ 按照维数分类：
  + 一维数组
  + 二维数组
  + 多维数组
+ 按照数组元素类型分类：
  + 基本数据类型元素的数组
  + 引用数据类型元素的数组

***

## 一维数组的使用

### 一维数组的声明和初始化

``` java
int[] ids;//声明保存学号的数组，数组元素类型为int类型
ids = new int[]{1001,1002,1003};//静态初始化：数组的初始化和数组元素的赋值同时进行

String[] names = new String[5];//动态初始化：数组的初始化和数组元素的赋值分开进行

/*
	错误写法：
	int[5] arr = new int[];//指定长度位置写错
	int[5] arr = new int[5];//都写上也是不行
	int[] arr = new int[3]{1,2,3};//既声明了长度又同时赋值也是不行的
*/	

//静态初始化也可以直接利用数组类型推断进行声明
int[] number = {1,2,3,4}
```

***

### 调用指定位置上的数组元素

> 通过**索引的方式**调用指定位置的元素，数组的**索引从0开始**，到**数组长度 -1时结束**

```java
String[] names = new String[5];
//一方面可以通过索引进行赋值操作
names[0] = "Martha";
names[1] = "Martha-X";
names[2] = "MarthaXR";
names[3] = "Martha-X-Crystal";
names[4] = "MarthaX";
//一方面可以通过索引获取元素值操作
String author = names[0];
```

***

### 获取数组的长度

> 数组有一个**length的属性**，通过该属性可获取数组长度

```java
String[] names = new String[3];
names[0] = "Martha";
names[1] = "Martha-X";
names[2] = "MarthaXR";
System.out.print(names.length);//输出3
```

***

### 遍历数组元素

```java
String[] names = new String[5];
//一方面可以通过索引进行赋值操作
names[0] = "Martha";
names[1] = "Martha-X";
names[2] = "MarthaXR";
for(int i = 0;i < names.length;i++){
  System.out.println(names[i]);
}
```

***

### 数组元素的默认初始化值

> 没有为数组显式赋值，数组会**有默认元素值**

+ 若数组元素类型为**整型**（byte、short、int、long）：`默认值为0`
+ 若数组元素类型为**浮点型**（float、double）：`默认值为0.0`
+ 若数组元素类型为**char型**：`默认值为0或'\u0000'`，而非'0'，在控制台显示为空格效果，但实际上是0
+ 若数组元素类型为**boolean型**：`默认值为false`
+ 若数组元素为**引用数据类型**：`默认值为null`

***

### 数组的内存解析

***

<img src="./JavaNotes_images\image-20210507150513454.png" alt="image-20210507150513454" style="zoom:100%;" />

***

## 二维数组的使用

> 如果说可以把一维数组当做几何中的线性图形，那么二位数组就相当于是一个表格
>
> 对于二维数组的理解可以看作是**一维数组作为另一个一维数组的元素而存在**，其实从数组的底层运行机制来看，其实没有多维数组，只是一个概念

### 二维数组的声明初始化

```java
int[][] arr = new int[][]{{1,2},{2,3},{3,4}};//静态初始化
String[][] arr = new String[3][2];//动态初始化：3行2列
String[][] arr = new String[3][];

//其它正确写法
String arr[][] = new String[3][];
String[] arr[] = new String[3][];
int[][] arr = {{1,2},{2,3}};//一行写的话系统可以自动推断出类型，分两行写就无效了
```

***

### 二维数组元素的调用

```java
int[][] arr = new int[][]{{1,2},{1,2}};
System.out.println(arr[0][1]);//输出第一行第二个元素
```

***

### 获取二维数组的长度

```java
int[][] arr = new int[][]{{1,3,5},{1,2},{2,6}};
System.out.println(arr.length);//输出3
System.out.println(arr[1].length);//输出2
```

***

### 遍历二维数组元素

```java
int[][] arr = new int[][]{{1,3,5},{1,2},{2,6}};
for(int i = 0;i < arr.length;i++){
  for(int j = 0;j < arr[i].length;j++){
    System.out.println(arr[i][j]);
  }
}
```

***

### 二维数组元素的默认初始化值

> 二维数组分为外层数组的元素和内层数组的元素

```java
int[][] arr = new int[3][3];
System.out.print(arr);//[[I@15db9742:[[代表二维数组 I代表int型，同理可得其它的数据类型首字母
System.out.print(arr[0]);//外层元素的初始化值为地址值  [I@15db9742：地址值
System.out.print(arr[0][0]);//内层元素的初始化值为数据类型默认值 0

int[][] arr = new int[3][];
System.out.print(arr[0]);//外层元素的初始化值为null，因为存储的一维数组为引用数据类型 null
System.out.print(arr[0][0]);//内层元素的初始化值不能调用，会报空指针异常
```

**总结：**

+ 针对于初始化方式一：int\[][] arr = new int[3]\[3];
  + 外层元素的初始化值为：**地址值**
  + 内层元素的初始化值为：与一维数组初始化情况相同
+ 针对于初始化方式二：int\[][] arr = new int[3]\[];
  + **外层元素的初始化值为null**
  + 内层元素的初始化值：不能调用，因为不存在，所以空指针异常报错

***

### 二维数组的内存解析

![image-20210507184822323](./JavaNotes_images\image-20210507184822323.png)

***

## 数组中涉及到的常见算法

### 数组元素的线性查找

```java
// 线性查找
boolean flag = false;
for (int i = 0; i < arr.length; i++) {
  if (arr[i] == 3) {
    flag = true;
    break;
  }
}
if (flag) {
  System.out.println("存在");
} else {
  System.out.println("不存在");
}
```

***

### 数组元素的二分查找

> 前提是所要查找的数组是有序的

```java
int[] arr3 = new int[] { -98, -34, 2, 34, 54, 66, 79, 105, 210, 333 };
// 所要查找的变量
int dest = -928;
int head = 0;// 初始的首索引
int end = arr3.length - 1;// 初始的末索引
boolean isFind = false;// 默认还没找到
while (head <= end) {
  int mid = (head + end) / 2;
  //是中位数就返回
  if (dest == arr3[mid]) {
    System.out.println("找到了指定的元素" + mid);
    isFind = true;
    break;
  } else if (arr3[mid] > dest) {
    end = mid - 1;
  } else if (arr3[mid] < dest) {
    head = mid + 1;
  }
}
if(isFind) {
  System.out.println("存在这个数");
}else {
  System.out.println("不存在哦");
}
```

***

### 数组元素的冒泡排序

```java
int[] arr = new int[] { 32, -98, 0, 42, 76, 33, -21, 32, 64, 99 };
for (int i = 0; i < arr.length - 1; i++) {
  for (int j = 0; j < arr.length - i - 1; j++) {
    if (arr[j] > arr[j + 1]) {
      int temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
for (int i : arr) {
  System.out.print(i + " ");
}
```

***

## Arrays工具类的使用

> 操作数组的工具类，其中定义了很多操作数组的方法

+ Arrays.equals(int[] a,int[] b)：判断两个数组中的元素是否相等

+ Arrays.toString(A)：遍历形参A数组的元素
+ Arrays.fill(arr,value)：为数组A填满B元素，将覆盖数组中每个元素
+ Arrays.sort(A)：对A数组进行排序
+ Arrays.binarySearch(A,B)：在数组A中二分查找B元素，返回一个负值就是没找到

***

## 数组使用中常见的异常

+ 数组下标越界异常：==ArrayIndexOutOfBoundsException==
+ 空指针异常：==NullPointerException==

***

# 第四章 面向对象编程（上）

## 面向过程与面向对象的概念

> 二者都是一种思想，面向对象是相对于面向过程而言的，面向过程强调的是功能和行为，以函数为最小单位，考虑怎么做
>
> 面向对象是将功能封装进对象，强调的是具备了功能的对象，以类和对象为最小单位，考虑谁来做

**面向对象的三大特征**

+ 封装
+ 继承
+ 多态

**理解万事万物皆对象**

+ 在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
+ 涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类的对象

***

## Java基本元素：类和对象

### 类和对象是面向对象的核心概念

> 类是一类事物的描述，是抽象的、概念上的定义
>
> 对象是实际存在的该类事物的每个个体，因而也称为实例

***

### 设计类就是设计类的成员

> 面向对象程序设计重点是类的设计

+ 属性：对应类中的成员变量
+ 方法：对应类中的成员方法

***

### 匿名类对象

> 匿名对象指的是没有为其显式赋给一个变量名保存地址
>
> 匿名类对象只能调用一次
>
> 一般都是作为实际参数传递使用的，形式参数会保存它的地址，供方法体使用

```java
new Person().setName("Martha");

phoneSell(new Phone());
public void phoneSell(Phone p){...}
```

***

## 对象的创建和使用

> 创建类的对象就等同于实例化一个对象

### 调用对象的结构

> 通过对象.属性与对象.方法调用相应的类结构

***

### 类和对象的使用

+ 创建类，设计类的成员
  + **常见的类的成员**
    + 属性：对应类中的成员变量
    + 方法：对应类中的成员方法
    + 构造器
    + 代码块
    + 内部类
+ 创建类的对象
+ 通过`对象.属性`或`对象.方法`调用对象的结构

***

### 类的多个对象之间的关系

> 如果创建了一个类的多个对象，则每个对象都独立拥有一套类的属性（非static的），即我们修改了一个对象的属性A，则不会影响另一个对象的属性A

***

### 对象的内存解析

#### 栈（Stack）

> 通常所说的栈，是指虚拟机栈，栈用于存储局部变量
>
> 局部变量存放了编译期可知长度的各种基本数据类型、对象引用（对象在堆空间中的首地址值），方法执行完自动释放

#### 堆（Heap）

> 堆空间用于存放对象实例，几乎所有的对象实例都在这里分配内存，所有的对象实例以及数组都要在堆上分配

#### 方法区（MethodArea）

> 用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

![image-20210508183317201](./JavaNotes_images\image-20210508183317201.png)

#### 对象数组的内存解析

![image-20210508194631384](./JavaNotes_images\image-20210508194631384.png)

***

## 类的成员之属性的声明和使用

### 属性与局部变量的对比

**二者相同点**

+ 定义变量的格式都是一样的（数据类型  变量名 = 变量值）
+ 都是先声明后使用
+ 都有其对应的作用域

**二者不同点** 

+ 在类中声明位置不同
  + 成员变量是直接声明在类{}内
  + 局部变量可以声明在方法内、方法形参、代码块内、构造器形参、构造器内部
+ 关于权限修饰符不同
  + 成员变量可以在声明时，指明其权限，也就是属性可以使用权限修饰符（private、缺省、protected、public）→封装性
  + 局部变量不可以使用权限修饰符，但与其所处方法的权限修饰符相同
+ 默认初始化值不同
  + 成员变量根据其类型的不同，都有其对应的初始化值
    + 整型（byte、short、int、long）默认初始化值为0
    + 浮点型（float、double）默认初始化值为0.0
    + 字符型（char）的默认初始化值为0或'\u0000'
    + 布尔型boolean的默认初始化值为false
    + 引用类型（类、数组、接口）默认初始化值为null
  + 局部变量在调用之前一定要显式赋值（特别地：形参在调用时赋值即可）
+ 在内存中加载的位置不同
  + 成员变量是加载到堆空间中的
  + 局部变量是加载到栈空间中的

### 属性可以赋值的位置

+ 默认初始化
+ 显式初始化
+ 构造器初始化
+ 创建对象后，使用`对象.属性`或`对象.方法`初始化
+ 代码块初始化

***

## 类的成员之方法的声明和使用

### 方法举例以及声明的格式

> 方法是用于描述类所应该具有的功能
>
> 分为无返回值有形参没形参，有返回值有形参没形参
>
> 方法的声明格式：权限修饰符 返回值类型 方法名（形参列表）{方法体}

```java
public void eat(){} //无返回值无形参
public void sleep(int hour){}	//无返回值有形参
public String getName(){return name;}	//有返回值无形参
public String getNation(String nation){return ..}	//有返回值有形参
```

***

### 关于方法的权限修饰符

+ private
+ public（默认方法的权限修饰符为public）
+ 缺省
+ protected

***

### 关于方法的返回值类型

+ 有返回值
  + 需要在方法声明时指定方法的返回值类型，同时方法中需要使用return关键字来返回指定类型的数据（变量或常量）
+ 无返回值
  + 需要在方法声明时，使用void来表示，通常没有返回值的方法中，就不需要使用return了，但是如果使用的话，==return；==表示结束方法的意思，return之后不能存在代码语句，执行不到，当调用者调用有返回值的方法时，该方法会将返回值返回给该调用者

****

### 关于方法的方法名

> 就属于标识符，需要遵循标识符的命名规则和规范，同时也要见名知意

***

### 关于方法的形参列表

> 方法可以声明一个或多个形参，格式为（数据类型1  变量名1,数据类型2  变量名2）（多个形参之间使用逗号隔开）

***

### 关于方法的方法体

> 一个方法的功能主要看方法体，方法体才是方法功能的实现

***

### return关键字的使用

+ 作用范围：使用在方法体中
+ 作用
  + 针对有返回值的方法，使用“return  数据;”返回所要的数据
  + 结束方法体，后面的代码不再被执行
+ 注意：return关键字之后不可以有声明执行语句

***

### 方法使用中的注意点

+ 方法在使用中可以直接调用当前类的成员变量，也可以调用当前类的方法（特殊地，一个方法直接或间接地调用自己称为递归）
+ 方法中不可以定义其它方法

***

## 再谈方法

### 方法的重载

> 在同一个类中。允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可

#### 方法重载的特点

+ 与返回值类型无关
+ 只看参数列表，且参数列表必须不同，调用时根据方法的参数类型的不同来区别

***

#### 重载的细节说明

+ 两同一不同
  + 同一个类、相同方法名
  + 参数列表不同、参数个数不同、参数类型不同、参数顺序不同
+ 方法之间是否构成重载与方法的权限修饰符、返回值类型、形参变量名、方法体都无关
+ 在通过对象调用重载方法时，通过方法名与形参列表确定某一个指定的方法
+ 构造器也是可以重载的

***

### 可变形参的方法

> Java5.0提供了可变形参机制，允许直接定义能和多个实参直接匹配的形参，从而，可以用一种更简单的方式来传递个数可变的实参

**可变形参方法的具体使用**

+ 可变个数形参的格式：（数据类型 ...  变量名）
+ 当调用可变个数形参的方法时，可以传入一个或多个也可以是0个，也就是不传参也行
+ 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
+ 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载，换句话说，二者不能共存（编译器认为二者相同）
+ 可变个数形参在方法形参中只能声明在末尾，且同一个方法的形参列表中，只能声明一个可变形参

```java
//以下两个方法不构成重载，系统认为他们相同，所以两个方法不能共存
//事实上就和数组差不多，获取也可以使用数组的方法获取
public void method(String ... args){
  for(String i : args){
    System.out.print(i);
  }
}
public void method(String[] args){}
```

***

### 方法参数的值传递机制

> Java的实参值如何传进方法中？
> 	Java中方法的参数传递只有一种：值传递，将实际参数值的副本传入方法内，实际参数本身不受影响
> 		形参是基本数据类型，则将实参数据值传入方法内（不影响实参值本身）
> 		形参是引用数据类型，则将实参地址值传入方法内（影响实参值本身）

**关于变量的赋值**

+ 若变量是基本数据类型，此时赋值的是变量所保存的数据值
+ 若变量是引用数据类型，此时赋值的是变量所保存的数据的地址值

**方法形参的传递机制**：==值传递==

+ 形参：声明方法时定义的形式参数列表
+ 实参：调用方法时，实际传入的值
+ 若参数是基本数据类型，那么实参赋值给形参的是实参真实存储的数据值，并不是地址
+ 若参数是引用数据类型，那么实参赋值给形参的是实参数据值存储的地址

***

### 递归方法

> 一个方法直接或间接地调用自己，递归一定不能形成死循环
>
> 方法递归包含了一种隐式循环，它会重复地执行某段代码，但是这种重复执行无需循环控制
>
> 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环

***

## 面向对象特征之封装与隐藏

> 我们的程序设计追求高内聚，低耦合
>
> 高内聚：类的内部数据操作细节自己完成，不允许外部干涉
>
> 低耦合：仅对外暴露少量的方法用于使用
>
> 封装与隐藏：隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性，可维护性，通俗地说，把该隐藏的隐藏起来，该暴露的暴露出来，这就是封装性的设计思想

**问题的引入**

> 当我们创建一个类的对象以后，我们可以通过对象.属性的方式对对象的属性进行赋值，这里的赋值操作只受到数据类型和存储范围的制约，除此之外没有其他制约条件，但是在实际问题中，我们往往还要给属性赋值加上额外的限制条件，这些条件就不能在属性赋值时体现，我们只能通过方法进行限制条件的追加（比如setLegs），同时我们还需要避免用户再通过对象.属性的方式进行属性赋值，则需要将该属性声明为私有的private（此时针对于属性就体现了封装性）

### 封装性的体现

> 封装性体现之一：我们将类的属性私有化，同时提供公共的方法来获取和设置此属性的值

+ 我们将类的属性私有化，同时提供公共的方法来设置和获取该属性的值
+ 不对外暴露私有的方法
+ 单例模式（私有化构造器）

```java
class Person{
  private String name;
  
  public void setName(String name){
    this.name = name;
  }
  
  public String getName(){
    return name;
  }
}
```

***

### 四种权限修饰符的理解

+ 封装性的体现需要权限修饰符的配合
+ Java规定了四种权限修饰符，从小到大依次为private、缺省、protected、public
+ Java权限修饰符置于类的成员定义前，用于限定对象对该类成员的访问权限
+ 对于类来说只有public和缺省两种权限修饰符
  + public的类可以在任何地方被访问
  + 缺省的类只能在同一个包下被访问
+ 四种权限修饰符可用于修饰类以及类的内部结构（属性、方法、构造器、内部类），修饰类只能使用缺省和public

> Java四种权限修饰符可以修饰类的属性、构造器、方法、内部类
>
> 对于class类对象来说，只有缺省、public两种权限修饰符

|  修饰符   | 类内部 | 同一个包下 | 不同包的子类 | 同一个工程 |
| :-------: | :----: | :--------: | :----------: | :--------: |
|  private  |  支持  |            |              |            |
|   缺省    |  支持  |    支持    |              |            |
| protected |  支持  |    支持    |     支持     |            |
|  public   |  支持  |    支持    |     支持     |    支持    |

***

## 类的成员之构造器的声明与使用

> 所有类都有自己的构造器

### 构造器的特征

+ 具有与类相同的名称
+ 它不声明返回值类型（与声明为void不同）
+ 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值

***

### 构造器的作用

> 构造器主要用来创建类的对象
>
> 可以初始化类对象的成员变量或调用方法，初始化对象的信息

```java
Person p = new Person();//new + 构造器
```

***

### 关于构造器的说明

+ 如果没有显式地定义类的构造器，则系统默认提供一个空参的构造器

+ 定义构造器的格式为：权限修饰符 类名（形参列表）{}

  ```java
  public Person(){}
  public Person(String name){
    this.name = name;
  }
  ```

+ 一个类中定义的多个构造器彼此之间构成重载
+ 一旦我们显式定义了构造器，系统就不再提供默认的空参构造器了
+ 一个类中至少会有一个构造器

***

#### 总结属性赋值的过程的先后顺序

> 以下1 2 3只执行一次，4可以反复执行

1. 属性自身默认初始化
2. 属性显式赋值
3. 属性构造器中初始化
4. 通过`对象.方法`或`对象.属性`的方式赋值

***

## this关键字

### this是什么

> 在Java中，this关键字较难理解，它的作用和其词义很接近
>
> + 它在方法内部使用，即这个方法所属对象的引用
> + 它在构造器内部使用表示该构造器正在初始化的对象
> + this表示当前对象，可以调用当前类属性、方法、构造器
>
> 什么时候需要使用this关键字？
>
> + 当在方法内部需要调用该方法的对象时，就用this

***

### this关键字调用属性和方法的使用

> this修饰属性与方法的时候指代的是当前类对象或当前正在创建的对象（用于构造器之中）

+ this可以修饰属性、方法、构造器
+ this可以理解为当前对象
+ 在类的方法中，我们可以使用`this.属性`和`this.方法`的方式，调用当前对象的属性或方法，但是通常情况下我们都选择省略`this.`，特殊情况下，当方法的形参和类的属性同名时，我们需要显式地使用`this.变量`的方式表明此变量是类的属性而非形参
+ 在类的构造器中，我们可以使用`this.属性`和`this.方法`的方式，调用当前正在创建的对象的属性或方法，但是通常情况下我们都选择省略`this.`，特殊情况下，当构造器的形参和类的属性同名时，我们需要显式地使用`this.变量`的方式表明此变量是类的属性而非形参

```java
//区分当前对象的成员变量与形参
public void setName(String name){
  this.name = name;
  this.eat();
}
```

***

### this关键字调用构造器的使用

+ 我们在类的构造器中，可以显式地使用`this(形参列表)`的方式显式地调用本类中指定的其他构造器
+ 构造器中不能通过`this(形参列表)`的方式调用自身
+ 如果一个类中有n个构造器，则最多有n-1个构造器中使用了`this(形参列表)`，剩下一个就是`super()`
+ 规定：`this(形参列表)`必须声明在构造器代码体首行（言外之意，构造器内部最多只能声明一个`this(形参列表)`，用于调用其他构造器

```java
//调用空参构造器
public Person(int age){
  this();
}

//调用带参构造器
public Person(){
  this(age);
}
```

***

## package、import关键字

### package关键字的使用

+ 为了更好地实现项目中路类的管理，我们提出了包的概念
+ 使用package声明类或接口所属的包，声明在源文件的首行
+ 包属于标识符，要遵循标识符的命名规则和规范，见名知意
+ 包名中每.一次，就代表一层文件夹
+ 补充：同一个包下不能命名重名的接口或者是类，当然，不同的包下可以

***

### import关键字的使用

+ 为使用定义在不同包中的Java类，需要使用import语句来引入指定包层次下所需要的类或全部类(.*)，import语句告诉编译期要到哪儿去寻找需要的类
+ 语法格式：import 包名.类名;
+ 在源文件中显式地使用import结构导入指定包下的类或接口
+ import结构声明在包的声明和类的声明之间
+ 若需要导入多个结构，则并列写出即可
+ 使用通配符xxx.*的方式，表明导入该xxx下的所有结构
+ 如果使用的类或接口是java.lang包下定义的，则不需要使用import结构
+ 如果使用的类或接口是本包下定义的则也可以省略import结构
+ 若在源文件中使用了不同包下同名的类，则必须至少有一个类需要使用全类名的方式声明使用
+ 使用xxx.\*的方式表明可以使用该xxx下的所有结构，但是若要想使用xxx子包下的结构还是需要显式导入（*不能包含子包，只能表示当前包层次）
+ import  static：表示导入指定的类或接口中的静态结构（属性或方法）

```java
//当想使用不同包下同名的类时，导入结构需要区分
Person p = new Person();
com.martha.exer.Person p1 = new com.martha.exer.Person();//全类名结构

//静态导入示例
import static java.lang.System.*;
out.print();
```

***

# 第五章  面向对象编程（中）

## 面向对象特征之继承性

### 继承性的好处

+ 减少了代码的冗余，提高了代码的**重用性**
+ 便于功能的扩展
+ 为之后的多态性的使用提供了前提条件

***

### 继承性的格式

> class A extends B{}
>
> + A称为子类（派生类，subclass）
> + B称为父类（超类、基类、superclass）

***

### 继承性的体现

+ 一旦子类A继承父类B之后，**子类**A中就**获取**了**父类**B中声明的**所有的结构**（属性和方法）
+ 特别地，**父类中**声明为**private的属性或方法**，**子类继承**了父类之后，仍然认为**获取到了**父类中私有的结构，只是**因为封装性**的影响，使得**子类不能直接调用**父类中私有的结构而已
+ 子类继承父类之后，还可以声明自己特有的属性和方法，实现功能的拓展，子类和父类的关系不同于集合和子集的关系，**子类的功能更为强大**

***

### 关于继承性的说明

> **Java只允许单继承或多层继承，不允许多重继承**

+ 一个子类只能有一个父类
+ 一个父类可以有多个子类
+ 多重继承中，子父类是相对的概念
+ 子类直接继承的父类称为**直接父类**，间接继承的父类称为**间接父类**
+ **子类继承了父类**之后，就**获取**了**直接父类**和**间接父类中**声明**的所有结构**

+ 子父类是相对的概念，若有多重继承，那么就存在直接父类与间接父类，子类继承父类之后，子类就获取了直接父类与间接父类中声明的所有属性和方法

***

### Object类的理解

> 如果我们没有显式声明一个类的父类，则此类默认继承于java.lang.Object类
>
> 所有的Java类都直接或间接地继承于java.lang.Object类（除了该类本身），意味着所有的类都具有Object类中声明的所有结构和功能

## 方法的重写

### 方法重写的定义

> 在子类中可以根据需要对从父类中继承来的方法进行改造，也成为方法的重置、覆盖，在程序执行时，子类的方法将覆盖父类的方法
>
> 子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作
>
> 重写之后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类后方法

***

### 方法重写的要求

+ 子类重写的方法必须和父类被重写的方法具有相同的方法名和参数列表（子类重写的方法的方法名和形参列表和父类被重写的方法的方法名和形参列表相同）
+ 关于子类重写的方法的返回值类型的要求
  + 子类重写的方法的返回值类型不能大于父类被重写方法的返回值类型
  + 父类被重写的方法返回值类型是void，那么子类重写的方法返回值类型也只能是void
  + 父类被重写的方法返回值类型是引用数据类型，那么子类重写的方法返回值类型可以是A类或者A类的子类
  + 父类被重写的方法返回值类型是基本数据类型，那么子类重写的方法返回值类型必须和父类的返回值类型完全一样（父类被重写方法的返回值类型为A类型，那么子类重写的方法的返回值类型只能是A类型或A类型的子类类型）
+ 关于子类重写的方法的权限修饰符的要求
  + 子类重写的方法使用的权限修饰符不小于父类被重写方法的权限修饰符，但可以相等
  + 子类不能重写父类中声明为private权限的方法
+ 子类重写的方法抛出的异常类型不大于父类被重写方法所抛出的异常类型

***

### 方法重写的注意点

> 子类与父类中同名同参数的方法必须同时声明为非static的（才可以重写），或者同时声明为static的（不构成重写），因为static的方法是属于类的，子类无法覆盖父类的方法
>
> 子父类方法存在覆盖，属性不存在覆盖
>
> 当子类重写父类方法之后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法

***

## super关键字

### super是什么？

> super可以理解为父类对象（包括间接父类），super可以用来调用父类的属性、方法、构造器

### super关键字调用属性和方法的使用

+ 我们可以在子类的方法或构造器中，通过使用`super.属性`或`super.方法`的方式，显式地调用父类中声明的属性或方法。但是通常情况下，我们习惯省略super（通常开发中，子父类不会出现同名属性）
+ 特殊情况下，当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式地使用`super.属性`的方式，表明调用的是父类中的属性
+ 当子类重写了父类中的方法之后，想在子类的方法中调用父类中被重写的方法时，则必须显式地使用`super.方法`的方式表明调用的是父类中被重写的方法

***

### super关键字调用构造器的使用

+ 我们可以在子类的构造器中显式地使用`super(形参列表)`的方式，调用父类中声明的指定的构造器
+ `super(形参列表)`的使用必须声明在子类构造器的首行，即在类的构造器中，`this(形参列表)`与`super(形参列表)`只能二选一出现，不能同时存在
+ 在子类的构造器中，若没有显式地声明`this(形参列表)`或`super(形参列表)`，则默认系统调用的是`super()`;也就是当我们创建子类的对象时，一开始就调用了父类的空参构造器
+ 在类的多个构造器中，至少有一个使用了`super(形参列表)`调用父类的构造器

***

## 子类对象实例化的全过程

### 子类对象实例化的过程

> **从结果上来看：**
>
> + 子类继承父类之后，就获取了父类中声明的属性或方法（继承性）
> + 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性（包括间接父类）
>
> **从过程上来看：**
>
> + 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器...直到调用了java.lang.Object类中的空参构造器为止，正因为我们加载过所有父类的结构（构造器），所以在内存中（堆空间）就有父类中的结构，子类对象才可以考虑进行调用
>
> **要明确：**
>
> + 虽然创建子类对象时，调用了父类的构造器，但是自始自终就创建过一个对象，既为new出的子类对象

***

## 面向对象特征之多态性

### 多态性的理解

> 可以理解为一个事物的多种形态
>
> 父类的引用指向子类的对象（子类的对象赋给父类的引用）

```java
//父类的引用指向子类的对象(或子类的对象赋值给父类的引用)
Person p = new Man();
//当调用父类同名同参数的方法时，实际执行的是子类重写父类的方法（虚拟方法调用）
p.eat();//实际运行调用的为Man类重写的eat()方法
p.id;//实际调用的是Person类的id属性
Person p = new Woman();
```

***

### 多态性的使用

+ 有了对象的多态性之后，我们在编译期p是Person类型，所以只能调用父类中声明的方法，不能调用子类中特有的方法，但在运行期，我们实际执行的是子类重写父类的方法，即编译看左边(Person p)，运行看右边(new Man();）
+ 虚拟方法调用，有了对象的多态性之后，我们在编译期只能调用父类中声明的方法，但在运行时，我们实际执行的是子类中重写父类的方法
+ 对象的多态性只适用于方法不适用于属性，因为属性不存在被重写，若调用的是属性那么就只看左边
+ 多态性减少了大量重载方法，使得一个方法可以实现不同对象的功能
+ 有了对象的多态性之后，内存中实际上是加载了子类特有的属性和方法的，但由于引用变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用，只能通过强制类型转换（向下转型）才能调用子类特有的属性和方法，使用强转时，可能出现ClassCastException类型转换异常，所以需要使用到instanceof关键字判断是否为该对象子类，是的话则强转

***

### 多态性的使用前提

+ 存在有类的继承关系
+ 子类中存在对父类的方法重写，否则就没有必要new 一个子类

***

### 多态性的总结

+ 编译看左边，运行看右边（编译看父类，运行看子类）
+ 对象的多态性只适用于方法，不适用于属性，对于属性来说，编译和运行都看左边，也就是看父类
+ 多态是运行时行为，编译的时候为父类类型，而方法的调用是在运行时确定的，所以调用的是子类重写后的方法（也称动态绑定）

***

### 虚拟方法调用的再理解

> 子类中定义了与父类同名同参数的方法，再多态情况下，将此时的父类方法看作一个虚拟方法，父类根据赋给它的不同子类对象，动态地调用属于子类的该方法，这样的方法调用在编译期是无法确定的

**方法重载与重写的以及多态方法调用的小结**

+ 重载是指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同的参数表，对同名的方法名称做修饰，对于编译器而言，这些同名方法就成了不同方法，他们的调用地址在编译期就绑定了。另外，Java的重载是可以包括父类和子类的，子类可以重载父类同名不同参数的方法，所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定
+ 而对于多态，只有等到方法调用的那一刻，解释运行器才会知道所要调用的具体方法，这称为晚绑定或动态绑定
+ ==若它不是晚绑定就不是多态==

***

### instanceof操作符

**instanceof关键字的使用**

> A instanceof B：意为检验A是否为类B的对象，返回值为boolean型
>
> + 要求类A所属的类必须和类B必须是子类和父类的关系，否则编译错误
> + 如果类A属于类B的子类C，返回值也为true

```java
//为了避免向下转型时出现类型转换异常，在转型之前，先进行instanceof判断，一旦返回true，就进行向下转型，若返回false就规避了异常风险，不进行向下转型
Person p = new Man();
if(p instanceof Man){
  Man m = (Man)p;
  m.earnMoney();
}

if(p instanceof Person){//true}
if(p instanceof Object){//true}
```

***

## Object类的使用

> Object类是所有Java类的根父类，如果在类的声明中未使用extends关键字指明其父类，默认父类为java.lang.Object根父类
>

### Object类中的功能介绍

+ Object类中的属性和方法具有通用性，==只有方法==没有属性
+ Object类只声明了一个空参的构造器,所有类对象实例化过程最终都会调用到该构造器
+ `protected void finalize()`若垃圾收集器发现该对象在栈里边没有引用指向，那么就会调用该方法回收该对象，我们不要主动调用，在对象被回收之前对象自己会先调用该方法

***

### Object类中的主要结构

|             方法名称              |     类型     |        方法描述        |
| :-------------------------------: | :----------: | :--------------------: |
|          public Object()          | 空参构造方法 |         构造器         |
| public boolean equals(Object obj) |   普通方法   |  比较两个对象是否相等  |
|       public int hashCode()       |   普通方法   |       取得Hash值       |
|     public String toString()      |   普通方法   |     对象打印时调用     |
|            getClass()             |   普通方法   |  获取当前对象的所属类  |
|    protected  Object  clone()     |   普通方法   |   克隆一个对象并返回   |
|    getClass().getSuperclass()     |   普通方法   | 获取当前对象的直接父类 |
|    protected  void finalize()     |   普通方法   |     对象回收时调用     |

```java
//Obejct类中定义的equals方法实际上与==的作用是相同的,那么就需要重写equals方法比较两个对象的实体内容是否相同
public boolean equals(Object obj){
  return (this==obj);
}
```

***

### Object类equals、toString方法的使用

#### ==与equals的区别

+ **==**
  + 是一种运算符，可用于基本数据类型和引用数据类型变量中
    + 若比较的是基本数据类型变量，比较的是两个变量保存的数据值是否相同（基本数据变量类型可以不相同，只是值拿来作比较，但不和布尔型作比较，会编译出错）
    + 若比较的是引用数据类型变量，比较的是两个对象的地址值是否相同，即两个引用是否指向同一个对象实体，另外，必须保证运算符左右两边对象类型相同，否则编译出错
+ **equals**
  + 是一个方法，而非运算符，只能用于引用数据类型之间的比较
  + Object类中equals方法，实际上还是用的是\==来比较对象的地址值是否相等，所以Object类中的equals方法作用与==的作用是相同的
  + 像String、File、Date、包装类等都重写了Object类中的equals方法，重写之后，比较的就不单单是对象的两个对象的引用是否相等了，而是比较两个对象的实体内容（属性）是否相同

***

#### 重写equals方法的原则

+ 对称性：A equals B和B equals A的结果都应该相同
+ 自反性：A equals A结果必须为true
+ 传递性：A  equals  B为true，B  equals C也为true，则A  equals  C必须为true
+ 一致性：A  equals B，只要二者内容不变，则无论比较多少次结果都必须相同
+ 在任何情况下，A equals null，都返回false，A  equals  与A不同的对象永远返回false

***

#### Object类toString方法的使用

> 当我们输出一个对象的引用变量时，实际就调用了当前对象的toString()方法
>
> String  toString()方法在Object类中定义，其返回值为String类型，返回类名和它的引用地址
>
> 在进行String和其他类型的连接操作时，自动调用该方法
>
> 可以根据需要在用户自定义类型中重写toString()方法，如String类重写了toString()方法，返回的是字符串的值
>
> 基本数据类型转换为String类型时，调用了对应包装类的toString()方法
>
> String、Date、File、包装类等都重写了Object类中的toString方法，使得在调用对象的toString方法时，返回实体内容信息
>
> 自定义类也可以重写toString方法，当调用此方法时，返回此对象实体属性内容

```java
//Object类中toString方法的定义
public String toString(){
  return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

***

## 包装类的使用

> 包装类是针对八种基本数据类型定义的相应的引用类型，也称封装类，有了类的特点就可以调用类中的方法，Java才是真正面向对象
>
> 除了int、char的包装类分别为Integer、Character，其余六种类型的包装类均为首字母大写
>
> 以下除了倒数两种类型，其余六种数值型的父类为Number类

| 基本数据类型 |  包装类   |
| :----------: | :-------: |
|     byte     |   Byte    |
|    short     |   Short   |
|     int      |  Integer  |
|     long     |   Long    |
|    float     |   Float   |
|    double    |  Double   |
|   boolean    |  Boolean  |
|     char     | Character |

```java
//基本数据类型转换为包装类（方式一）
int num = 1;
//基本数据类型转换为包装类，则调用相应包装类的构造器即可
Integer i = new Integer(num);
//包装类转换为基本数据类型，则直接调用xxxValue()即可，xxx表示基本数据类型
int number = i.intValue();

//自动装箱与自动拆箱（方式二）
int i = 1;
Integer i2 = i;//直接赋值给包装类类型即可实现自动装箱
int number = i2;//直接赋值给基本数据类型变量即可实现自动拆箱

//基本数据类型、包装类转换为String类型
int i = 1;
String str = i + "";//（方式一）基本数据类型变量直接作连接运算转换为String类型

/*
（方式2）利用valueof进行转换，String.valueOf(基本数据类型变量或包装类类型变量)，返回的就是String类型，不管是基本数据类型或包装类类型都可以通过valueof转换为String类型
*/
int i = 1;
String str = String.valueOf(i);

//String转换为基本数据类型或包装类类型，调用包装类的parsexxx方法，转换为基本数据类型或包装类类型
String i = "123";
int i = Integer.parseInt(i);
```

**Integer自动装箱内部剖析**

> integer内部定义了IntegerCache结构IntegerCache中定义了Integer数组，该数组保存了从-128～127的整数，若我们使用自动装箱的方式，给Integer赋值的范围在此之间，可以直接使用数组中的元素，不用再去new了，若超出该范围，则需要new，如此以来就可以提高一定效率，因为我们较常使用该范围内的数

***

# 第六章  面向对象编程（下）

## static关键字

> 当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或者无论产生了多少个对象的情况下，某些特定的数据在内存空间中只有一份，例如所有的中国人都有一个国家名称，每一个中国人都共享这个国家的名称，不必在每个中国人的实例对象中都单独分配一个用于代表国家名称的变量（static声明的变量不是每一个对象独立拥有，而是大家共享的）

### static关键字的使用

> static意为静态的，可以用于修饰属性、方法、代码块、内部类，不可以修饰构造器

***

### 使用static修饰属性

> 被static修饰的变量称为静态变量或类变量

**属性按是否被static修饰又分为**

+ 静态属性（类变量）

  > 对于静态属性而言，当我们创建了多个类的对象，多个对象之间共享该静态属性，当通过其中一个对象修改了该静态属性值，会导致所有对象的该静态属性值被修改

+ 非静态属性（实例变量）

  > 对于实例变量而言，当我们创建了类的多个对象，每个对象都独立地拥有一套类的非静态属性，当修改其中一个非静态属性时，不影响其他对象中的该属性值

***

#### static修饰属性的其他说明

+ 静态变量随着类的加载而加载，可以通过`类.静态变量`的方式来进行调用
+ ·静态变量的加载要早于对象的创建
+ 由于类只会加载一次，则静态变量在内存中也只会存在一份，存在在方法区的静态域中
+ 类可以调用类变量不可以调用实例变量
+ 对象可以调用类变量和实例变量，实例变量随着类对象的创建而加载的

***

#### 类变量和实例变量的内存解析

![image-20210612024509544](./JavaNotes_images\image-20210612024509544.png)

***

### 使用static修饰方法

> 被static修饰的方法称为静态方法

#### static修饰方法的其他说明

+ 随着类的加载而加载，可以通过`类.静态方法`的方式进行调用

+ 类可以调用静态方法，不能调用非静态方法
+ 对象可以调用静态和非静态的方法
+ 静态方法中只能调用静态方法和静态属性
+ 非静态方法中既可以调用静态方法和静态属性也可以调用非静态方法和属性

***

### static使用注意点

+ 在静态方法内不能使用this和super关键字，因为其表示当前对象，对象尚未出生，所以没有构造器
+ 关于静态属性和方法，要从生命周期的角度去理解

***

### 开发中，怎样确定一个属性要声明为static

> 属性是可以被多个对象所共享的，不会随着对象的不同而不同
>
> 类中的常量时常也声明为static的

***

### 开发中，怎样确定一个方法要声明为static

> 操作静态属性的方法也通常声明为static的
>
> 工具类中的方法习惯声明为static的，就没有必要造对象了

***

### 单例设计模式

> 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式，设计模式就像是经典的棋谱以应对不同的棋局，免去我们再自己思考和摸索套路
>
> 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器访问权限设置为private，如此，就不能通过new关键字在类的外部产生类的对象，但在类内部可以产生该类的对象，因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类的变量也必须定义成静态的

#### 单例设计模式的优点

> 单例模式只生成一个实例，减少了系统性能的开销，当一个对象的产生需要较多的资源时，如读取配置、产生其它依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决

***

#### 单例设计模式的应用场景

+ 网站的计数器
+ 应用程序的日志应用
+ 数据库连接池
+ 读取配置文件的类
+ Application
+ Windows的任务管理器
+ Windows的回收站

****

#### 饿汉式和懒汉式的区别

+ 饿汉式
  + 好处：饿汉式是线程安全的
  + 坏处：对象加载时间过长（生命周期过长，等到类被消除时才释放）（对象一开始就加载好了，在内存空间中加载时间过长）

+ 懒汉式
  + 好处：延迟对象的创建，一定程度上节省了内存空间
  + 坏处：没改造前，是线程不安全的

```java
//饿汉式
class Test{
  private Test testInstance = new Test();
  //私有化构造器
  private Test(){}
  
  //返回实例变量
  public Test getInstance(){
    return testInstance;
  }
}

//懒汉式
class Test(){
  private Test instance = null;
  private Test(){}
  public Test getInstance(){
    if(instance == null){
      instance = new Test();
    }
    return instance;
  }
}
```

***

## 理解main方法的语法

```java
public class Test{
  public static void main(String[] args){
    
  }
}
```

**main方法的使用说明**

+ main方法作为程序的入口出现
+ main方法也是一个普通的静态方法
+ main方法也可以作为我们与控制台交互的一种方式（之前使用的时Scanner）

***

## 类的成员之代码块

> 也称为初始化块

**代码块的作用**

> 用于初始化类和对象

### 代码块的分类

> 代码块如果有修饰的话，只能使用static，称为静态代码块

+ 非静态代码块
  + 内部可以有执行语句
  + 随着对象的创建而执行，每创建一个对象就会执行一次
  + 可以在创建对象的同时，对对象的属性等进行初始化
  + 若一个类中定义了多个非静态代码块，则按照声明的先后顺序依次执行（一般也不会声明多个）
  + 非静态代码块可以调用静态结构和非静态结构
+ 静态代码块
  + 内部可以有执行语句
  + 随着类的加载而执行且==只会执行一次==
  + 可以初始化类的相关信息，如静态属性等
  + 若在一个类中定义了多个静态代码块，则按照声明的先后顺序依次执行（一般也不会声明多个）
  + 静态代码块的执行要优先于非静态代码块的执行
  + 静态代码块内只能调用静态的属性和静态的方法，不能调用非静态的结构

***

### 总结对属性可以赋值的位置

+ 属性自身默认初始化
+ 属性被显式初始化
+ 属性在构造器中初始化
+ 通过`对象.属性`或`对象.方法`的方式进行初始化
+ 在代码块中赋值

***

### 总结属性赋值的先后顺序

+ 属性自身默认初始化
+ 属性被显式初始化或在代码块中被赋值（先声明的先执行）
+ 属性在构造器中初始化
+ 通过`对象.属性`或`对象.方法`的方式进行初始化

***

## final关键字

> final关键字意为最终的，最后的

### final关键字可以用于修饰的结构

> 可用于修饰类、方法、变量

### final修饰类的声明和使用

> 被final关键字修饰的类不能够被其他类所继承，如String类、System类、StringBuffer类

```java
//声明格式为：
public final class Creature{}
//public class Person extends Creature{}被final修饰的类不可以被继承
```

***

### final修饰方法的声明和使用

> 被final关键字修饰的方法不能够被子类重写，如Object类中的getClass方法

```java
//声明格式为：
public final void run(){}
```

***

### final修饰变量的声明和使用

```java
//声明格式为：final 数据类型 常量名 = 常量值
final int width =  10;//常量显式初始化
final int age;
{
  age = 10;//常量在代码块中初始化
}
public Person(){
  age = 20;//常量在构造器中初始化
}
public void method(final int age){
  //age = 10;当final修饰形参时，在方法体内不可以修改该形参的值
}
```

+ 被final关键字修饰的“变量”称为常量
+ 被修饰的常量必须得赋上值
+ final修饰属性，可以考虑的赋值位置有：
  + 显式初始化
  + 代码块中初始化
  + 构造器中初始化
  + ==不可以在方法中初始化==（不清楚方法是否会被调用，若没被调用，则相当于没被初始化）
+ final修饰局部变量
  + 被final关键字修饰的变量，该变量的值不可以被修改
  + 被final关键字修饰的方法形参，表明此形参是一个常量，当我们调用此方法时，给常量形参赋值一个实参，一旦赋值以后，在该方法内就只能在方法体内使用此形参，就是不能重新赋值
+ ==static  final==修饰属性称作全局常量

***

## 抽象类和抽象方法

> 随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般更通用，类的设计应该保证父类子类能够共享特征，有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类

### abstract关键字的使用

> abstract可以理解为抽象的
>
> abstract可以用于修饰类和方法

### abstract修饰类的声明和使用

```java
//声明格式为：
public abstract class HelloWord{}
```

+ 一旦声明为了抽象类，该类就不可以被实例化
+ 抽象类中一定有构造器，可供其子类对象实例化时调用（涉及到子类实例化的全过程）
+ 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作（抽象类的使用前提：继承性）

***

### abstract修饰方法的声明和使用

```java
//声明格式为：
public abstract void method();
```

+ 抽象方法只有方法的声明，没有方法体
+ 包含有抽象方法的类一定是一个抽象类（不想让对象调用该方法，那么类也就必须是抽象类），反之，抽象类中可以没有抽象方法
+ 子类继承抽象类之后，要么重写抽象类中的抽象方法，要么就子类自身也声明为抽象类，只有子类重写了所有的抽象方法，此子类才可以实例化

***

### abstract关键字使用的注意点

+ abstract关键字不能修饰属性、构造器、代码块等结构
+ abstract不能用于修饰私有方法、静态方法以及final修饰的类和方法（abstract和final是死对头）

***

### 创建抽象类的匿名子类对象

```java
public abstract class Hello{
  public abstract void method();
}
public class Test{
  public static void main(String[] args){
    Hello h = new Hello(){
      public void method(){
        System.out.println("我是一个匿名子类的对象，我重写了抽象方法，我只执行一次");
      }
    };
   	h.method();//我是一个匿名子类，我重写了抽象方法，我只执行一次
  }
}
```

***

## 接口（Interface）

### 接口的概述

> + 有时需要从几个类中派生出一个子类，继承他们所有的属性和方法，但是Java不支持多重继承，有了接口就可以得到多重继承的效果
> + 有时需要从几个类中抽取出一些共同的特征，而他们之间又不是子父类的关系，仅仅是具有相同的行为特征而已
> + 接口就是规范，定义的是一组规则，体现了现实世界中，“如果你是/要，则必须能”的思想，继承是一个“是不是”的关系，而接口实现则是“能不能”的关系
> + 接口的本质是契约、标准、规范，就像法律一样，制定好，大家都要遵守

***

### 接口的定义和使用

+ 接口是使用==interface关键字==来声明的

+ 在Java语言中，类和接口是并列的两个结构

+ 接口中不能定义构造器，意味着接口不能够实例化

+ Java开发中，通过让类实现（implements）接口的方式来使用，如果实现类实现了接口中所有的抽象方法，则此实现类就可以实例化，反之，实现类没有实现接口中所有的抽象方法，则此实现类仍为抽象类

+ 关于JDK7(Java7版本)及之前的定义：只能定义全局常量及抽象方法

  ```java
  /*
  	全局常量的声明：接口中的常量都是public的
  	书写时可以省略public static final三个关键字，省略依然还在，只是你看不见
  	即使省略public static final，在接口中依然认为是常量
  */
  interface Hello{
    public static final int AGE = 21
    //可省略为int AGE = 21;效果都是一样的 
  }
  
  /*
  抽象方法的声明：当然public abstract依然可以省略
  */
  interface Hello{
    public abstract void method();
    //可省略为void method();效果依然一样
    //public Hello(){}接口中不能定义构造器
  }
  ```
  
+ 关于JDK8的定义

  > 除了定义全局常量和抽象方法之外，还可以定义静态方法和默认方法

***

### 接口的多实现和接口的继承性

+ Java类可以实现多个接口，弥补了Java类的单继承性的局限性

+ 所实现的多个接口之间用逗号隔开

+ 一个类有继承有实现的格式：类  A  extends   B  implements C,D,E..{}（先继承再实现）

+ 接口与接口之间可以继承，并且可以多继承，格式为接口AA  extends  接口BB，接口CC..

  ```java
  //单继承类多实现接口
  class Student extends Person implements A,B,C{
    
  }
  
  //接口之间也可以多继承
  interface Other extends A,B,C{}
  interface A{}
  interface B{}
  interface C{}
  ...
  ```

***

### 接口使用的补充

> 接口的具体使用，能够体现多态性
>
> 接口实际上可以看作是一种规范
>
> 开发中，体会面向接口编程

***

### 接口和抽象类有哪些异同点

+ 相同点
  + 接口和抽象类都不能够实例化
  + 都可以被继承
+ 不同点
  + 抽象类和接口是并列的结构，抽象类为类体系，接口为接口体系
  + 抽象类有构造器，而接口不能声明构造器
  + 抽象类只能单继承，接口可以多继承
  + 抽象类为class关键字定义，接口为interface关键字定义
  + 类与类之间是单继承的关系，类与接口之间是多实现关系，接口与接口之间是多继承关系，随着JDK的不断迭代，接口在往类的方向在靠近，使得接口的功能可拓展性更强

### 实现接口的匿名类对象

```java
class Test(){
  public static void main(String[] args){
    Computer computer = new Computer();
    Printer printer = new Printer();//非匿名实现类兼非匿名对象
    //1.创建了接口(USB)的非匿名实现类(Printer)的非匿名对象(printer)
    computer.transferData(printer);
    //2.创建了接口(USB)的非匿名实现类(Printer)的匿名对象(new Printer())
    computer.transferData(new Printer());
    //3.创建了接口(USB)的匿名实现类的非匿名对象(phone)
    USB phone = new USB(){
      @Override
      public void start() {
        System.out.println("手机开始工作");
      }
      @Override
      public void stop() {
        System.out.println("手机停止工作");
      }
    };
    computer.transferData(phone);
    //4.创建了接口(USB)的匿名实现类的匿名对象
    computer.transferData(new USB(){
      @Override
      public void start() {
        System.out.println("mp3开始工作");
      }
      @Override
      public void stop() {
        System.out.println("mp3停止工作");
      }
    });
  }
}
class Computer {
  //传输数据
	public void transferData(USB usb) {
		usb.start();
		System.out.println("具体传输数据的细节");
		usb.stop();
	}
}

interface USB {
	void start();
	void stop();
}

class Flash implements USB {
	@Override
	public void start() {
		System.out.println("U盘开始工作");
	}
	@Override
	public void stop() {
		System.out.println("U盘停止工作");
	}
}

class Printer implements USB {
	@Override
	public void start() {
		System.out.println("打印机开始工作");
	}
	@Override
	public void stop() {
		System.out.println("打印机停止工作");
	}
}
```

***

### 接口的应用

#### 代理模式

> 代理模式是Java开发中使用较多的设计模式，代理设计就是为其他对象，提供一种代理以控制对该对象的访问

**代理模式的应用场景**

+ 安全代理：屏蔽对真实角色的直接访问
+ 远程代理：通过代理类处理远程方法调用
+ 延迟加载：先加载轻量级的代理对象，真正需要时再加载真实对象（如要开发一个打文档查看软件，大文档中可能有100mb的图片，在打开文件时不可能将所有图片都加载出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开）
+ 代理模式的分类
  + 静态代理：静态定义一个代理类
  + 动态代理：动态生成代理类（JDK自带的代理类需要反射等知识）

***

#### 工厂模式

> 实现创建者和调用者的分离

**工厂模式的分类**

+ 无工厂模式

+ 简单工厂模式
  + 优点：实现了创建者和调用者的分离
  + 缺点：对于增加新产品，不增加代码的话，是无法进行扩展的，违反了开闭原则（对扩展开放，对修改封闭）
+ 工厂方法模式
  + 优点：实现了创建者与调用者的分离
  + 缺点：对于增加新产品还是会有添加代码的情况，所以就提出了动态创建工厂的角色，就需要与反射相结合
+ 抽象工厂模式
  + 抽象工厂模式和工厂方法模式的区别就在于需要创建对象的复杂程度上，出现了族的概念

***

### Java8中接口的新特性

> Java8中，你可以为接口添加静态方法和默认方法；从技术角度来说，这是完全合法的，只是它看起来违法了接口作为一个抽象定义的理念

#### 静态方法

+ 静态方法使用static关键字修饰，可以通过`接口名称.静态方法名称`直接调用静态方法，并执行其方法体，我们经常相互一起使用的类中使用静态方法，你可以在标准类库中找到像Collection/Collections或者Path/Paths这样成对的接口和类

+ 接口中定义的静态方法只能通过接口调用，该接口的实现类、子类都无法通过对象直接调用

  ```java
  public interface StaticMethodInterface{
    public static void staticMethod(){
      System.out.println("我有方法体，不需要实现类重写");
    }
  }
  //实现类SubClass
  class SubClass implements StaticMethodInterface{
    public static void main(String[] args){
      SubClass s = new SubClass();
      //s.staticMethod();实现类对象无法直接通过对象调用接口中的静态方法
    }
    //实现类自己定义的方法
    public void run(){
      StaticMethodInterface.staticMethod();//调用接口中的静态方法只能通过接口名称.静态方法来调用
    }
  }
  //接口子类
  class SubInterface extends StaticMethodInterface{
    public static void method() {
  		StaticMethodInterface.staticMethod();
  	}
  }
  ```

#### 默认方法

+ 默认方法使用default关键字修饰，可以通过实现类对象来调用；我们在以由的接口中提供新方法的同时，还保持了与旧版本代码的兼容性【比如Java8中API中对Collection、List、Comparator等接口提供了丰富的默认方法】，说白了，就是接口中定义的默认方法方便其实现类直接调用并使用
+ 通过接口实现类的对象可以调用接口中的默认方法，当然实现类也可以重写接口中的默认方法，调用时，仍然调用的是重写以后的方法
+ ==类优先原则==如果子类（或实现类）继承的父类和实现的接口中（与接口的多少无关）同时声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的方法（该原则只针对方法来说）

+ ==接口冲突==：如果实现了实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么实现类没有重写此方法的情况下，会编译报错，因为不知道实现类等下调用的该方法是哪一个接口中的

```java
/*
	@author Martha-X
 	JDK8中除了定义全局常量和抽象方法外，还可以定义静态方法和默认方法
 	静态方法与默认方法都具有方法体
*/
public interface Interface {
	public static final int age = 1;//全局常量
	public abstract void run();//抽象方法
	//静态方法
	public static void staticMethod() {
		System.out.println("Java8中的静态方法");
	}
	//默认方法：public可以省略，默认方法提供给实现类调用,default在此是关键字
	public default void defaultMethod() {
		System.out.println("Java8中的默认方法");
	}
	
}
```

```java
//第二点示例
//接口
public interface DefaultMethodInterface{
  public default void method(){
    System.out.println("我是接口中的默认方法");
  }
  //以上方法可以省略public
  default void method(){
    System.out.println("我是接口中的默认方法");
  }
}
//子类实现接口
class SubClass implements DefaultMethodInterface{
  //程序的入口
  public static void main(String[] args){
    SubClass sub = new SubClass();
    sub.method();//输出---“我是重写接口中默认方法后的方法”
    //实现类对象可以调用接口中的默认方法，若该接口中的默认方法被实现类重写了，则执行的是实现类中重写后的方法
  }
  //对接口中的默认方法进行重写,default关键字不写
  public void method(){
    System.out.println("我是重写接口中默认方法后的方法")
  }
}
```

```java
//第三点类优先原则示例
public interface DefaultMethodInterface{
  default void method(){
    System.out.println("我是接口中的默认方法");
  }
}
//父类
public class SuperClass{
  public void method(){
    System.out.println("我是父类中的方法");
  }
}
//子类既继承父类又实现接口
class SubClass extends SuperClass implements DefaultMethodInterface{
  //程序的入口
  public static void main(String[] args){
    SubClass sub = new SubClass();
    sub.method();//输出---“我是父类中的方法”
  }
}
```

```java
//第四点接口冲突示例
public interface DefaultMethodInterfaceA{
  default void method(){
    System.out.println("我是接口中的默认方法");
  }
}
public interface DefaultMethodInterfaceB{
  default void method(){
    System.out.println("我是接口中的默认方法");
  }
}
//子类实现多接口，编译报错，要么重写接口中的method方法，否则编译器不知道实现类要调用的是哪一个方法
class SubClass implements DefaultMethodInterfaceA,DefaultMethodInterfaceB{
  
}
```

#### 如何在实现类中调用父类或接口中未被重写的方法

```java
public interface Interface{
  default void method(){
    System.out.println("我是接口中的默认方法");
  }
}
public class SuperClass{
  public void method(){
    System.out.println("我是父类中的方法"); 
  }
}
public SubClass extends SuperClass implements Interface{
  public void method(){
     System.out.println("我是子类重写的方法");
  }
  //子类、实现类自己定义的方法
  public void myMethod(){
    method();//调用该类中自己重写后的方法
    super.method//调用父类中未被重写的方法
    Interface.super.method();//调用接口中未被重写的默认方法
  }
}
```

***

## 类的成员之内部类

> 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类
>
> 在Java中，允许将一个类B声明在另一个类A中，B称为==内部类==，A称为==外部类==
>
> InnerClass一般用在定义它的类或语句块内，在外部引用它时，必须给出一个完整的名称

### 内部类的分类

#### 成员内部类

+ 非静态内部类
+ 静态内部类

```java
public class Person{
  //大脑 非静态成员内部类
  class Brain{}
  //心脏 静态成员内部类
  static class Heart{}
}
```

##### 成员内部类的特点

+ 一方面作为外部类的成员
  + 作为外部类的成员，就可以调用到外部类的结构，静态非静态还是有区别的
  + 作为外部类的成员，就可以使用static关键字修饰，外部类不能使用static修饰
  + 作为外部类的成员，可以被四种权限修饰符修饰，外部类只能被两种权限修饰符修饰（public、default）
+ 另一方面作为一个类
  + 成员内部类内可以定义属性、方法、构造器等（当然内部类中也可以定义内部类，只不过没必要）
  + 成员内部类可以使用final关键字修饰，修饰后则表示该类不能被继承，不用final修饰则可以被继承
  + 可以被abstract关键字修饰，表明该内部类不能被实例化

***

##### 如何实例化成员内部类的对象

```java
public class Person{
  public static void main(String[] args){
    //非静态成员内部类的实例对象
    Person person = new Person();
    Person.Heart heart = person.new Heart();
    //静态成员内部类的实例对象
    Person.Brain brain = new Person.Brain();
  }
  
  //非静态的成员内部类
  class Heart{}
  //静态的成员内部类
  static class Brain{}
}
```

***

##### 如何在成员内部类中区分调用外部类的结构

```java
public class Person{
  String name;
  public static void main(String[] args){
    //非静态成员内部类的实例对象
    Person person = new Person();
    Person.Heart heart = person.new Heart();
  }
  
  //非静态的成员内部类
  class Heart{
    String name;
    public void method(String name){
      	System.out.println(name);//调用当前方法形参
		System.out.println(this.name);//调用本类(Heart)中的name属性
		System.out.println(Person.this.name);//调用外部类(Person)的name属性
    }
  }
}
```

***

#### 局部内部类

+ 方法内内部类
+ 代码块内部类
+ 构造器内部类

```java
public class Person{
  //在一个方法内部定义局部内部类
  public void method() {
    class AA{}
  }
  //在非静态代码块中定义局部内部类
  {
    class BB{}
  }
  //在静态代码块中定义内部类
  static {
    class CC{}
  }
  //在构造器中定义局部内部类
  public Person() {
    class DD{}
  }
}
```

##### 开发中局部内部类的使用

```java
public class Person{
	// 没有返回值的方法体局部内部类很少见
	public void method() {
		class AA {
		}
	}

	// 返回了一个实现了Comparable接口的类的对象【非匿名实现类的匿名对象】
	public Comparable getComparable() {
		// 创建一个实现了Comparable接口的局部内部类
		class MyComparable implements Comparable {

			@Override
			public int compareTo(Object o) {
				return 0;
			}

		}
		return new MyComparable();
	}
	
	// 返回了一个实现了Comparable接口的类的对象2【匿名实现类的匿名对象】
	public Comparable getMyComparable() {
		return new Comparable() {

			@Override
			public int compareTo(Object o) {
				return 0;
			}
			
		};
	}
}
```

##### 局部内部类的一个使用注意点

> 在局部内部类的方法中（如以下的show方法），若要调用局部内部类所声明方法中的局部变量的话，要求此局部变量声明为final的常量，移动（安卓）开发常用，从生成的文件的生命周期来说，该方法会传一个副本给局部内部类，那么该”变量“就只能使用，不能修改，修改也没用

```java
public class InnerClassTest {
	public void method() {
		final int num = 10;//final在JDK8以后可省略，JDK7以及之前的版本要求此局部变量显式地声明为final的
		class AA{
			public void show() {
				System.out.println(num);
			}
		}
	}
}
```

# 第七章 异常处理

## 异常概述与异常体系结构

> 在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统运行的过程中仍然会遇到一些问题，因为很多问题不是靠代码就能够避免的，如客户输入数据的格式、读取的文件是否存在、网络是否始终保持通畅等等

### 异常概述

> 在Java语言中，将程序发生的不正常情况称为异常，开发过程中的语法错误和逻辑错误不属于异常

***

### Java程序在执行过程中所发生的异常可分为两类

#### Error（错误）

> Java虚拟机无法解决的==严重问题==。如JVM系统内部错误、资源耗尽等严重情况；比如StackOverflowError(栈溢出)和OOM(堆溢出)，一般不编写针对性的代码进行处理

***

#### Exception（异常）

> 其它因编程错误或偶然的外在因素导致的==一般性问题==，可以使用针对性的代码进行处理
>
> 例如：
>
> + 空指针访问
> + 试图读取不存在的文件
> + 网络连接中断
> + 数组下标越界
>
> 对于这些错误，一般有两种解决方法：
>
> + 遇到错误就终止程序的运行
> + 在编写程序时，就考虑错误的检测、错误消息的提示、以及错误的处理
>
> 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生，如除数为0，数组下标越界等，分为==编译时异常==与==运行时异常==

***

### 常见的异常体系结构

+ java.lang.Throwable：异常最高父类
  + java.lang.Error：一般不编写代码进行处理，通过后缀判断是Error还是Exception
  + java.lang.Exception：可以进行异常的处理
    + 编译时异常(checked)：又称受检异常，执行javac.exe命令时，可能出现的异常
      + IOException
        + FileNotFoundException
      + ClassNotFoundException
    + 运行时异常(unchecked)（RuntimeException）：又称非受检异常，执行java.exe命令时，出现的异常
      + NullPointerException
      + ArrayIndexOutOfBoundsException
      + ClassCastException
      + NumberFormatException
      + InputMismatchException
      + ArithmeticException

***

## 常见的异常及举例说明

```java
//常见编译时异常，举例说明如下:
@Test
public void test7() {
  File file = new File("hello.text");
  FileInputStream f = new FileInputStream(file);
  int data = f.read();
  while (data != -1) {
    System.out.println((char)data);
    data = f.read();
  }
}
```

```java
//常见运行时异常，举例说明如下:
// NullPointerException
@Test
public void test1() {
  String str = null;
  System.out.println(str.charAt(0));
}

// ArrayIndexOutOfBoundsException
@Test
public void test2() {
  int[] arr = new int[1];
  System.out.println(arr[2]);
}

// ClassCastException
@Test
public void test3() {
  Object obj = new Date();
  String str = (String) obj;
}

// NumberFormatException
@Test
public void test4() {
  String str = "123";
  str = "abc";
  Integer i = new Integer(str);
}

// InputMismatchException
@Test
public void test5() {
  Scanner s = new Scanner(System.in);
  int i = s.nextInt();
  System.out.println(i);
}

// ArithmeticException
@Test
public void test6() {
  System.out.println(6 / 0);
}
```



***

## 异常处理方式一：try-catch-finally

> 在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进除法运算时，要检测分母为0、数据为空，输入的是不是数值。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此需要采用异常处理机制
>
> Java异常处理机制，是将可能会进行异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅、易于维护
>
> + Java提供的是异常处理的抓抛模型
> + Java程序的执行过程中若出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常
> + 异常对象的生成
>   + 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，若当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出
>   + 由开发人员手动创建——Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通类对象一样

### 异常的处理两个过程：抓抛模型

#### 抛的过程

> 程序在正常的执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出，抛给程序的调用者，一旦抛出对象之后，其后的代码就不再执行

***

#### 抓的过程

> 抓的过程：可以理解为异常的处理方式
>
> + try-catch-finally
> + throws

***

### try-catch-finally的使用

+ try{}中需包含可能会出现异常的代码体，在执行过程中一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型去catch中进行匹配
+ 根据实际问题可以写多个catch（==范围小的先写，范围大的后写==），一旦try中的异常对象匹配到某一个catch时，就会将此异常对象抓住进行处理，一旦处理完成，就跳出当前try-catch结构（前提是没有finally的情况下），继续执行try-catch之后的代码
+ catch中的异常类型，如果没有子父类关系，则谁声明在先，谁声明在后无所谓，若满足子父类关系，则要求子类一定要声明在父类之前，否则报错
+ 常用的异常对象方法调用处理方式
  + e.printStackTrace();==比较常用，返回值类型为void==
  + e.getMessage();返回值类型为String
+ 在try结构中声明的变量，在出了该结构后，就失效了，属于局部变量
+ try-catch-finally结构可以嵌套使用
+ 开发中，由于运行时异常比较常见，所以我们通常不针对运行时异常编写try-catch-finally，对于编译时异常，就一定要try-catch处理，否则字节码文件都生成不了，使得编译时异常延迟至运行时
+ finally是可选的，根据实际需要判断是否存在必须执行的代码，如关闭资源等
  + 即使catch中又出现异常了，或者try中有return语句、catch中存在return语句，也会执行finally块
  + 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，需要我们手动地进行资源的释放，该释放操作就需要声明在finally当中

```java
try{
  //可能会出现异常的代码体
}catch(异常类型1 变量名1){
  e.printStackTrace();//经常调用的方法
  e.getMessage();//经常调用的方法，返回值类型为String
}catch(异常类型2 变量名2){//根据实际问题可以写多个catch
  e.printStackTrace();//经常调用的方法
  e.getMessage();//经常调用的方法，返回值类型为String
}finally{//finally可以选则写或不写
  //此处的代码无论如何都会被执行，我们将一定要执行的代码放入finally{}中
}
```

***

## 异常处理方式二：throws+异常类型

+ `throws + 异常类型`写在方法的声明处，指明此方法执行时，可能会抛出的异常类型，一旦方法执行出现异常时，仍会在异常代码处生成一个异常类对象，此对象满足throws后的异常类型时，就会被抛出，异常代码==后续的代码就不再执行==
+ try-catch-finally是真正地将异常处理掉了，throws只是将异常抛给了方法的调用者，并没有真正将异常处理掉

```java
//throws示例，多个异常类对象用逗号隔开
public void method() throws IOException,Exception(){}
```

***

### 重写的方法异常抛出的规则

+ 子类重写的方法抛出的异常类型不能大于(但可以等于或者没有)父类被重写方法抛出的异常类型

***

## 开发中选择哪种方式处理异常

> 开发中如何选择使用try-catch-finally，还是使用throws？
>
> + 如果父类中被重写的方法没有使用`throws+异常类型`方式处理异常，那么子类重写的方法也不能使用throws，意味着子类重写的方法若有异常只能使用try-catch-finally方式进行处理自己的异常
>
>   ```java
>   class SuperClass{
>     public void method(){}
>   }
>   class SubClass extends SuperClass{
>     @Override
>     public void method(){//父类中方法没有抛出异常，子类重写后更不能抛出，所以只能自己处理
>       try{
>         //...
>       }catch(){
>         
>       }finally{
>         
>       }
>     }
>   }
>   ```
>
> + 执行的方法中先后又调用了另外的几个方法，那么这几个方法是递进关系执行的，建议这几个方法使用`throws+异常类型`的方式进行处理，而执行的方法可以考虑使用try-catch-finally进行处理
>
>   ```java
>   public void method1()throws FileNotFoundException{}
>   public void method2()throws ClassCastException{}
>   public void method3()throws IOException{}
>   public void test(){
>     try{
>       //递进关系如下
>       method1();
>    	  method2();//我需要method1方法执行返回的结果
>     	method3();//我需要method2方法执行返回的结果
>     }catch(Exception e){
>       e.printStackTrace();
>     }finally{
>       //...
>     }
>   }
>   ```

***

## 手动抛出异常：throw

**关于异常对象的产生**

+ 系统自动生成的异常对象
+ 手动生成一个异常类对象并抛出(throw)

```java
//代码示例
public class Person{
  private int age;
  
  public void setAge(int age){
    if(age > 0){//若传入的年龄合法，则进行赋值
      this.age = age;
    }else{//若输入不合法，手动抛出异常对象
      throw new RuntimeException("输入的年龄不合法");
    }
  }
} 
```

***

## 自定义异常类

+ 使自定义异常类继承于现有的异常类
  + RuntimeException
  + Exception
+ 提供全局常量：serialVersionUID
+ 提供重载的构造器

```java
public class MyException extends RuntimeException {
	//序列号类标识的全局常量，可自行修改，使其能够唯一标识这个类就行了
	static final long serialVersionUID = -7034897190745766939L;
	//空参构造器
	public MyException() {

	}
	//message使用父类中的属性
	public MyException(String message) {
		super(message);
	}
}
```

***

## 总结异常处理的5个关键字

+ try：执行可能产生异常的代码

+ catch：捕获异常
+ finally：无论是否发生异常，代码总被执行
+ throw：手动生成一个异常类对象并抛出==异常的生成阶段==，声明在方法体内
+ throws：异常处理的一种方式，==声明方法可能要抛出的异常类对象==，声明在方法声明处

***

# 第八章 多线程

## 基本概念：程序、进程、线程

### 程序(program)

> 程序是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象

***

### 进程(process)

> 进程是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程——生命周期
>
> 如运行中的QQ程序或mp3播放器
>
> + 程序是静态的，进程是动态的
> + 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域

***

### 线程(thread)

> 进程可以进一步细化为线程，是一个程序内部的一条执行路径
>
> + 若一个进程同一时间并行执行多个线程，该程序就是支持多线程的
> + 线程作为调度和执行的单位，每个线程拥有独立的运行==栈和程序计数器(pc)==，线程切换的开销小
> + 一个进程中的多个线程共享着相同的内存单元和内存地址空间（==共享堆空间和方法区==）→他们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程中通信更加简便、高效。但多个线程操作共享的系统资源可能会存在安全隐患==线程安全问题==

### 单核CPU和多核CPU的理解

> 单核CPU其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费用才能通过，那么CPU就好比这个收费人员，若某个人不想交钱，那么收费人员可以将其==挂起==（晾着他，等他想通了，交了钱，再去收费），但是因为CPU时间单元特别短，因此感觉不出来
>
> 多核CPU才能更好地发挥多线程的效率（现在的服务器都是多核的）
>
> 一个Java应用程序java.exe，其实至少有三个线程
>
> + main()主线程
> + gc()垃圾回收线程
> + 异常处理线程：当然如果发生异常会影响主线程

***

### 并行与并发

> 并行：多个CPU同时执行多个任务。比如多个人同时做不同的事情
>
> 并发：一个CPU（采用时间片快速切换）“同时”执行多个任务。比如秒杀、多个人做同一件事（1000人同时抢10台IPHONE）

### 使用多线程的优点

> 背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需要多线程呢？

+ 提高应用程序的相应。对图形化界面更有意义，可增强用户体验
+ 提高计算机系统CPU的利用率
+ 改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

***

### 何时需要多线程?

+ 程序需要同时执行两个或多个任务
+ 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等
+ 需要一些后台运行的程序时

***

## 线程的创建和使用

### 线程的创建和启动

> Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现

### Thread类的特性

> 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体
>
> 通过该Thread对象的start()方法来启动这个线程，而非直接调用run()

***

### 多线程的创建方式一之继承Thread类

+ 创建一个继承于Thread类的子类
+ 重写Thread类中的run()方法
+ 创建Thread类的此子类对象
+ 通过此子类对象去调用Thread类中的start()方法，以下为start方法的两个作用
  + 启动当前线程
  + 调用当前线程的run()方法

```java
public class ThreadTest {
    public static void main(String[] args) {
      	//创建子类对象
        SubClass s = new SubClass();
        //通过子类对象调用Thread类中start方法
        s.start();
      	//如下操作是在主线程中执行
        for (int i = 0; i < 20; i++) {
            if (i % 2 == 0) {
                System.out.println(i + "===MAIN");
            }
        }
    }
}

//创建一个子类继承Thread类
class SubClass extends Thread {
    //重写Thread类的run方法,将此线程执行的操作声明在run()方法中
    @Override
    public void run() {
      	//该线程执行输出偶数的操作
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
            }
        }
    }
}
```

***

#### 创建过程中两个问题的说明

+ 我们不能通过直接调用run()方法的方式启动线程 
+ 不可以让已经调用过start()方法的线程，再调用start()方法，即不可以让同一个子类对象调用两次start()方法，需要重新创建一个子类线程对象，再使其调用start()方法，==要想创建多个线程就创建多个Thread子类对象==

```java
public class ThreadTest {
    public static void main(String[] args) {
        SubClass s = new SubClass();        
        s.run();//不能通过run()方法直接启动线程，而是通过start方法才能启动一个线程，直接调用run方法还是意味着主线程一条线程去执行
      	s.start();
      	s.start();//不合法的线程状态，只能重新创建一个子类对象再进行调用
      	SubClass s2 = new SubClass();
      	s2.start();
        for (int i = 0; i < 20; i++) {
            if (i % 2 == 0) {
                System.out.println(i + "===MAIN");
            }
        }
    }
}

//创建一个子类继承Thread类
class SubClass extends Thread {
    //重写Thread类的run方法,将此线程执行的操作声明在run()方法中
    @Override
    public void run() {
      	//该线程执行输出偶数的操作
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
            }
        }
    }
}
```

***

#### 创建Thread类的匿名子类对象

```java
public class ThreadDemo{
  public static void main(String[] args){
    new Thread(){//匿名子类
      @Override
      public void run(){
        //遍历100以内的偶数
        for (int i = 0; i < 100; i++) {
          if (i % 2 == 0) {
            System.out.println(Thread.currentThread().getName() + "偶数:" + i);
          }
        }
      }
    }.start();
    
    new Thread(){//匿名子类
      @Override
      public void run(){
        //遍历100以内的奇数
        for (int i = 0; i < 100; i++) {
          if (i % 2 != 0) {
            System.out.println(Thread.currentThread().getName() + "奇数:" + i);
          }
        }
      }
    }.start();
  }
}
```

***

### Thread类的有关方法介绍

|           方法声明            |                           方法描述                           |
| :---------------------------: | :----------------------------------------------------------: |
|         void start()          |            启动当前线程，调用当前线程的run()方法             |
|             run()             | 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中<br />线程在被调度(唤醒)时执行的操作 |
|       String getName()        |                      返回当前线程的名称                      |
|   void setName(String name)   |                        为该线程起名称                        |
| static Thread currentThread() | 返回当前执行代码的线程。在Thread子类中就是this，通常用于主线程和Runnable实现类 |
|      static void yield()      | 线程让步<br />暂停当前正在执行的线程，将执行机会让给优先级相同或更高的线程<br />若队列中没有同优先级的线程，忽略此方法<br />释放当前CPU的执行权，不代表自己不会再次抢到 |
|            join()             | 当某个程序执行流中调用其它线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join()线程执行完为止<br />低优先级的线程也可以获得执行<br />在线程A中调用线程B的join方法，此时线程A就会进入阻塞状态，直到线程B执行完毕后，线程A才继续执行 |
|            stop()             |          强制线程生命期结束，不推荐使用，已经过时了          |
|            sleep()            | 让当前线程睡眠(阻塞)指定毫秒数，在指定的毫秒时间内，当前线程是阻塞状态 |
|       boolean isAlive()       | 判断线程是否还存活，线程执行中为true，执行完毕后就返回false  |

***

### 线程优先级的设置

#### 线程的调度

##### 调度策略

> + 时间片
> + 抢占式：高优先级的线程抢占CPU

***

##### Java的调度方法

> 同优先级线程组成先进先出队列（先到先服务），使用时间片策略
>
> 对高优先级，使用优先调度的抢占式策略，即高优先级会抢占低优先级的执行权

***

#### 线程的优先级

##### 线程的优先等级

> 优先级一共10档，1→10，低→高
>
> 高优先级的线程要抢占低优先级线程CPU的执行权，但是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完毕后，低优先级的线程才执行

+ MAX_PRIORITY:10【最高优先级】
+ MIN_PRIORITY:1【最小优先级】
+ NORM_PRIORITY:5【默认优先级】：无论是主线程main还是其他线程，没有设置过优先级，默认都是5

***

##### 线程优先级涉及的方法

> getPriority();返回线程的优先值
>
> setPriority(int newPriority)改变线程的优先级

***

##### 线程优先级说明

+ 线程创建时继承父线程的优先级
+ 低优先级只是获得调度的概率较低，并非一定是在高优先级线程之后才被调用

***

### 多线程的创建方式二之实现Runnable接口

+ 定义一个实现了Runnable接口的类
+ 实现类去实现Runnable接口中的抽象方法——run()方法
+ 创建实现类的对象
+ 将此对象作为参数传递至Thread类的构造器中，创建Thread对象
+ 通过Thread对象调用start()方法启动线程

```java
public class ThreadTest2 {
    public static void main(String[] args) {
        MyThread m = new MyThread();//创建实现类的对象
        Thread t = new Thread(m);//创建Thread类对象，并将实现类对象作为参数传递至构造器中
        t.setName("线程1");
        t.start();//通过Thread对象调用start()方法
      	Thread t2 = new Thread(m);//再开一条线程，共用同一个MyThread对象即可，除非功能不同
      	t2.setName("线程2");
      	t2.start();
    }
}
//自定义类实现Runnable接口
class MyThread implements Runnable{
  	//重写run方法
    @Override
    public void run() {
        System.out.println("我是一条线程" + Thread.currentThread().getName());
    }
}
```

***

### 两种创建线程方式的对比

> 开发中，我们优先选择实现Runnable接口的方式

+ 实现Runnable接口的方式没有类的单继承性的局限性
+ 实现的方式更适合用于处理多个线程共享数据的情况

***

### 两种创建线程方式的联系

> public class Thread implements Runnable{}

+ Thread类其实也是实现了Runnable接口
+ 两种方式都需要重写run()方法，将线程的逻辑声明在run()方法中

***

### 线程的分类(了解)

> Java中的线程分为两类：
>
> + 守护线程
> + 用户线程

+ 他们在几乎每个方面都是相同的，唯一的区别就是判断JVM何时离开
+ 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以将一个用户线程变成一个守护线程
+ Java垃圾回收线程就是一个典型的守护线程
+ 若JVM中都是守护线程，当前JVM将退出
+ 形象理解：兔死狗烹、鸟尽弓藏

***

## 线程的生命周期

> JDK中用Thread.State内部类定义了线程的几种状态
>
> 要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下五种状态：

+ 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
+ 就绪：处于新建状态的线程被start()启动后，将进入线程队列等到CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源
+ 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能
+ 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态
+ 死亡：线程完成了它的全部工作或线程被提前强制性地终止或出现异常导致结束

![image-20210709020504331](./JavaNotes_images\image-20210709020504331.png)

+ suspend()挂起与resume()，已经过时了，了解即可
+ 一个线程的最终状态就是死亡，而不是阻塞

***

## 线程的同步

### 理解线程的安全问题

> 多个线程对同一个数据进行操作，可能会出现线程的安全问题

***

### 同步代码块处理实现Runnable接口的线程安全问题

> 在Java中，我们通过同步机制来解决线程的安全问题

#### 同步代码块

```java
//格式
synchronized(同步监视器){
  //需要被同步的代码
}

//代码示例
public class WindowTicketTest {
    public static void main(String[] args) {
        Window w = new Window();//唯一的Window对象
        Thread t = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);
        t.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");
        t.start();
        t2.start();
        t3.start();
    }
}

class Window implements Runnable {
    private int ticket = 100;

    @Override
    public void run() {
        while (true) {
            synchronized(this){//此时的this就代表唯一的Window对象
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + "窗口卖出第" + ticket + "票");
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}
```

***

#### 同步代码块说明

+ 操作共享数据的代码，即为需要被同步的代码，不能包含代码多了，也不能包含代码少了
  + 共享数据：多个线程共同操作的变量；如ticket票就是共享数据
  + 同步监视器，俗称锁，任何一个类的对象都可以充当锁，但是==要求多个线程必须共用同一把锁，锁有且只有一个==
+ 同步代码块的方式
  + 解决了线程的安全问题——好处
  + 操作同步代码时只能有一个线程参与，其它线程在等待，相当于一个单线程的过程，相对来讲效率低一些，但还是要用——局限性
  + 在实现Runnable接口创建多线程的方式中，我们可以考虑使用this来充当一把锁，因为共享数据所处的对象只有一个

***

### 同步代码块处理继承Thread类的线程安全问题

> 对象可以充当锁，类也可以充当锁，==类也是对象==，以下两个是相同的都可以充当锁，在继承中的线程安全问题要慎用this作为锁
>
> + getClass()
> + Window.class

```java
public class WindowTicketTest2 {
    public static void main(String[] args) {
        Window2 w1 = new Window2();
        Window2 w2 = new Window2();
        Window2 w3 = new Window2();
        w1.setName("线程1");
        w2.setName("线程2");
        w3.setName("线程3");
        w1.start();
        w2.start();
        w3.start();
    }
}
class Window2 extends Thread{
    private static Object obj= new Object();//唯一的锁
    private static int ticket = 100;
    @Override
    public void run() {
        while (true) {
            synchronized(super.getClass()){//也可以使用obj或当前类对象Window2.class(类只会加载一次)，类也是对象
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + "窗口卖出第" + ticket + "票");
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}
```

***

### 同步方法处理实现Runnable接口的线程安全问题

> 如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的

```java
//代码示例
public class WindowTest3 {
    public static void main(String[] args) {
        Window3 w = new Window3();
        Thread t = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);
        t.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");
        t.start();
        t2.start();
        t3.start();
    }
}

class Window3 implements Runnable {
    private int ticket = 100;
    private synchronized void method(){//同步方法的锁就是this
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "窗口卖出第" + ticket + "票");
            ticket--;
        }
    }
    @Override
    public void run() {
        while (true) {
            method();
            if(ticket == 0){
                break;
            }
        }
    }
}
```

***

### 同步方法处理继承Thread类的线程安全问题

```java
public class WindowTest4 {
    public static void main(String[] args) {
        Window4 w1 = new Window4();
        Window4 w2 = new Window4();
        Window4 w3 = new Window4();
        w1.setName("线程1");
        w2.setName("线程2");
        w3.setName("线程3");
        w1.start();
        w2.start();
        w3.start();
    }
}

class Window4 extends Thread {
    private static int ticket = 100;

    private static synchronized void method() {//同步监视器：w1,w2,w3，同步方法默认的this在继承中可能无效了，所以只能将该方法声明为static的
        //该方法static了，那么就不可能使用this，那么当前方法使用的锁就是Window4.class
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "窗口卖出第" + ticket + "票");
            ticket--;
        }
    }

    @Override
    public void run() {
        while (true) {
            method();
            if (ticket == 0) {
                break;
            }
        }
    }
}
```

***

### 关于同步方法的总结

+ 同步方法仍然涉及到同步监视器（锁），只是不需要我们显式地声明
+ 非静态的同步方法，默认的同步监视器为this；静态的同步方法，它的同步监视器是当前类本身xxx.class

***

### 线程的死锁问题

#### 死锁

> 不同的线程分别占用对方所需要的同步资源不放弃，都在等待对方放弃自己所需要的同步资源，就形成了线程的死锁
>
> 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
>
> 我们使用同步时，要避免出现死锁，就像不要写死循环

#### 死锁的解决方法

+ 专门的算法、原则
+ 尽量减少同步资源的定义
+ 尽量避免嵌套同步

***

### Lock(锁)的方式解决线程安全问题

> 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步，同步锁使用Lock对象来充当
>
> java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源前应先获得Lock对象
>
> ReentranLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentranLock，可以显式加锁、释放锁

```java
public class LockTest {
    public static void main(String[] args) {
        Window w = new Window();
        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);
        t1.setName("线程1");
        t2.setName("线程2");
        t3.setName("线程3");
        t1.start();
        t2.start();
        t3.start();
    }
}

class Window implements Runnable {
    private int ticket = 100;
    //在实现类中实例化ReentrantLock对象
    private ReentrantLock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true) {
            try{
                lock.lock();//调用lock方法获取自动同步监视器，lock以下直至unlock之间的代码都是单线程的，所以安全
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + "售票，票号为" + ticket);
                    ticket--;
                } else {
                    break;
                }
            }finally {
                lock.unlock();//调用解锁的方法
            }
        }
    }
}
```

***

### synchronized与lock的异同点

+ 相同点
  + 二者都可以解决线程安全问题
+ 不同点
  + synchronized机制在执行完相应的同步代码以后，自动地释放同步监视器，故synchronized被称为隐式锁
  + lock需要手动地启动同步(lock.lock())，同时结束同步也需要手动实现(lock.unlock())，故lock被称为显式锁
  + synchronized有代码块锁和方法锁，而lock只有代码块锁
  + 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性(提供更多的子类)
  + 建议优先考虑使用lock锁，再考虑同步代码块，再考虑同步方法（灵活程度由高到低排序）

***

## 线程的通信

> 线程通信涉及到三个方法
>
> + wait()：一旦执行到此方法，当前线程就进入阻塞状态，并释放同步监视器
> + notify()：一旦执行到此方法，就会唤醒被wait()的一个线程，如果有多个线程被wait()，我们就唤醒优先级高的那个线程
> + notifyAll()：一旦执行到此方法，就会唤醒所有被wait()的线程

**三个方法的说明**

+ 这三个方法必须使用在同步代码块或同步方法中
+ 这三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会报异常
+ 这三个方法是定义在Object类中的

```java
//两个线程交替打印1-100
public class Test {
    public static void main(String[] args) {
        MyThread m = new MyThread();
        Thread t1 = new Thread(m);
        Thread t2 = new Thread(m);
        t1.setName("线程1");
        t2.setName("线程2");
        t1.start();
        t2.start();
    }
}

class MyThread implements Runnable {
    private int number = 0; 

    @Override
    public void run() {
        while (true) {
            synchronized (this) {//若同步监视器是自定义的Object obj = new Object();
                notify();//省略了this，如果是自定义的obj，就需要显式声明为obj.wait() ||obj.notify()
                if (number <= 100) {
                    System.out.println(Thread.currentThread().getName() + "--" + number);
                    //0 1 线程1wait 1  2 3 4
                    number++;
                    try {
                        wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else {
                    break;
                }

            }

        }
    }
}
```

***

### sleep和wait的异同点

+ 相同点
  + 一旦执行方法，都可以使得当前线程进入阻塞状态
+ 不同点
  + 两个方法声明的位置不同：Thread类中声明的sleep()方法；Object类中声明的wait()方法
  + 调用的要求不同：sleep()方法可以在任何需要的场景下调用；wait()方法需要使用在同步代码块和同步方法
  + 关于是否释放同步监视器：如果两个方法都是用在同步代码块或同步方法之中，sleep()方法不会释放锁，wait()会释放锁

***

### 经典例题：生产者/消费者问题

> 生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品(比如：20)，如果消费者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产：如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走商品
>
> 这里可能出现两种问题
>
> + 生产者比消费者快时，消费者就会漏掉一些数据没有取到
> + 消费者比生产者快时，消费者会取相同的数据

***

## JDK5.0新增线程的创建方式

### 新增方式一之实现Callable接口

> 与Runnable相比，Callable功能更加强大
>
> + call()方法相比run()方法，可以有返回值
> + 方法可以抛出异常
> + 支持泛型返回值
> + 需要借助FutureTask类，比如获取返回结果

#### Future接口介绍

+ 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等
+ FutureTask是Future接口的唯一实现类
+ FutureTask同时实现了Runnable、Callable接口，它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值

```java
public class ThreadNew {
    public static void main(String[] args) {
        //③创建Callable接口实现类的对象
        NumberThread n = new NumberThread();
        //④将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(n);//得到一个futureTask对象
        //⑤将FutureTask的对象作为参数传入到Thread的构造器中，创建Thread对象，并调用start()方法
        Thread t = new Thread(futureTask);
        t.setName("线程");
        t.start();
        try {
            //get()方法的返回值即为futureTask构造器参数Callable实现类重写的call方法的返回值
            Object sum = futureTask.get();
            System.out.println("1-100之中偶数的总和为" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
//①定义一个实现Callable接口的实现类
class NumberThread implements Callable {
    //②实现call方法，将此线程需要执行的操作声明在call方法中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            if (i % 2 == 0) {
                sum += i;
            }
        }
        return sum;
    }
}
```

***

#### 如何理解实现Callable接口的方式创建多线程比实现Runnable接口的方式创建多线程方式强大？

+ call()方法是可以有返回值的
+ call()方法可以抛出异常，被外面的操作捕获，进而获取异常的信息
+ Callable接口是支持泛型的

***

### 新增方式二之使用线程池

> 背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大
>
> 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池子中，可以避免频繁创建和销毁、实现重复利用，类似生活中的公交工具
>
> 好处：
>
> + 提高响应速度，减少了创建新线程的时间
> + 降低了资源消耗，重复利用线程池中线程，不需要每次都创建
> + 便于线程管理
>   + 核心池大小：corePoolSize
>   + 最大线程数：maximumPoolSize
>   + 线程没有任务时，最多保存多长时间后会终止：keepAliveTime
>
> 总结：创建多线程的方式有四种

```java
public class ThreadPool {
    public static void main(String[] args) {
        //①提供指定线程数量的线程池，以下包含10条线程
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //设置线程池的属性,要强转
        ThreadPoolExecutor t = (ThreadPoolExecutor) executorService;
        t.setCorePoolSize(15);
        //...
        //②执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
        // executorService.submit();//适合使用于Callable
        executorService.execute(new NumberThread2());//适合使用于Runnable
        executorService.execute(new NumberThread3());//适合使用于Runnable
        executorService.shutdown();//线程池不用了就关闭
    }
}

class NumberThread2 implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + "-" + i);
            }
        }
    }
}

class NumberThread3 implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + "-" + i);
            }
        }
    }
}
```

***

# 第九章 Java常用类

## 字符串相关的类

### String类及常用方法

> String类：代表字符串，使用一对""引起来表示。Java程序中的所有字符串字面值（如”abc“）都作为此类的实例出现
>
> String对象的字符内容是存储在一个字符数组final char value[]中的
>
> String类是一个final类，代表==不可变的字符序列==，简称：不可变性，不可以被继承（不可变性体现在如下几点）
>
> + 当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的value字符数组进行重新赋值，因为该数组是final的
> + 对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的字符数组value进行修改
> + 当调用String的replace()方法修改内部指定字符或字符串时，也需要重新指定内存区域赋值
> + 所以，String代表不可变的字符序列，==只要字面量存在改动都会重新指定内存区域赋值==
>
> 字符串是常量，用双引号引起来标识，他们的值在创建之后不能更改
>
> String类实现了Serializable接口，表示==字符串是支持序列化的==
>
> String类实现了Comparable接口，表示==字符串可以比较大小==
>
> 通过字面量的方式（意思就是不用去new一个对象，String是可以直接赋值的一个类对象），给一个字符串赋值，此时的字符串值声明在字符串常量池中
>
> 字符串常量池中是不会存储相同内容（也就是两个相同值）的字符串的，内容若找到相同的，那么就不会再新声明一个，而是使用原先有的（如下图）

```java
/*
  String：字符串，使用一对""引起来表示
  String类声明为final的，不可以被继承
  String类实现了Serializable接口，表示字符串是支持序列化的
*/
@Test
public void test1() {
  String s1 = "abc";//字面量的定义方式，意思就是不用去new一个对象，String是可以直接赋值的一个类对象
  String s2 = "abc";
  s1 = "hello";
  System.out.println(s1==s2);//false，比较s1和s2的地址值
  System.out.println(s1);//hello
  System.out.println(s2);//abc
}
```

***

#### String对象的创建及存储区域

```java
String str = "hello";//通过字面量的方式赋值，其值会存储在字符串常量池中
String str = new String();//本质上是this.value = new char[0];
String str = new String(String original);//this.value = original.value;
String str = new String(char[] a);//this.value = Arrays.copyOf(value,value.length);
String str = new String(char[] a,int startIndex,int count);

//面试题：通过String s = new String("abc");方式创建对象，在内存中创建了几个对象？两个
//①一个是在堆空间中new的对象
//②char型数组对应的常量池中的数据--"abc"，若已经有"abc"在内存中，则要考虑要不要考虑原有的char结构

/*
 常量与常量的拼接结果是在常量池，且常量池不会存在相同内容的常量
 只要拼接时有一个是变量，结果就在堆空间中
 如果拼接的结果调用intern()方法，返回值就在常量池中
*/
String s1 = "javaEE";
String s2 = "Hadoop";
String s3 = "javaEEHadoop";
String s4 = "javaEE" + "Hadoop";
String s5 = s1 + "Hadoop";
String s6 = "javaEE" + s2;
String s7 = s1 + s2;
System.out.println(s3 == s4);//true
System.out.println(s3 == s5);//false
System.out.println(s3 == s6);//false
System.out.println(s5 == s6);//false
System.out.println(s3 == s7);//false
System.out.println(s5 == s7);//false
System.out.println(s6 == s7);//false

String s8 = s5.intern();//此时返回得到的s8使用的常量池中已经存在的"javaEEHadoop"
System.out.println(s3 == s8);//true

```

![image-20210712015057932](./JavaNotes_images\image-20210712015057932.png)

***

#### String类常用方法及使用描述

> 什么情况下，indexOf和lastIndexOf返回值相同？
>
> + 字符串中存在一个唯一的str，返回值皆为该str索引下标
> + 字符串中不存在str，返回值皆为-1

|                           方法定义                           |                           方法描述                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                         int length()                         |                       返回字符串的长度                       |
|                    char charAt(int index)                    |                      返回某索引处的字符                      |
|                      boolean isEmpty()                       |                      判断是否是空字符串                      |
|                     String toLowerCase()                     | 使用默认语言环境<br />将String中的所有字符转为小写<br />==不改变原有字符串== |
|                     String toUpperCase()                     | 使用默认语言环境<br />将String中的所有字符转为大写<br />==不改变原有字符串== |
|                        String trim()                         | 返回去除前导空白与尾部空白后的字符串副本<br />包含在字符串中的空格不会去除<br />不改变原有字符串== |
|                       boolean equals()                       |                   比较字符串的内容是否相同                   |
|                  boolean equalsIgnoreCase()                  |               忽略大小写判断两个字符串是否相等               |
|                  String concat(String str)                   |    将指定字符串连接到此字符串的结尾处<br />等同于连接符 +    |
|             int compareTo(String anotherString)              | 比较两个字符串的大小<br />返回负数则当前方法调用者小<br />返回正数则当前方法调用者大<br />返回0则二者相等 |
|               String substring(int beginIndex)               | 返回一个新的字符串<br />它是此字符串从beginIndex开始截取到最后一个子字符串<br />==包括beginIndex下标元素== |
|        String substring(int beginIndex,int endIndex)         | 返回一个新字符串<br />他是此字符串从beginIndex开始截取到endIndex的一个子字符串<br />==包括beginIndex下标元素<br />但不包括endIndex下标元素（左闭右开）== |
|               boolean endsWith(String suffix)                |               判断此字符串是否以指定的后缀结束               |
|              boolean startsWith(String prefix)               |               判断此字符串是否以指定的前缀开始               |
|        boolean startsWith(String prefix,int toffset)         |    测试此字符串从指定索引开始的子字符串是否以指定前缀开始    |
|               boolean contains(CharSequence s)               | 当且仅当此字符串中包含指定的char值序列时返回true<br />否则返回false |
|                   int indexOf(String str)                    | 返回指定子字符串在此字符串中第一次出现处的索引<br />==注意indexOf和lastIndexOf若未找到子字符串则返回-1== |
|            int indexOf(String str,int fromIndex)             | 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br />==注意indexOf和lastIndexOf若未找到子字符串则返回-1== |
|                 int lastIndexOf(String str)                  | 返回指定子字符串在此字符串中最右边出现处的索引<br />==注意indexOf和lastIndexOf若未找到子字符串则返回-1== |
|          int lastIndexOf(String str,int fromIndex)           | 返回指定子字符串在此字符串中最后一次出现处的索引<br />从指定的索引开始反向搜索<br />==注意indexOf和lastIndexOf若未找到子字符串则返回-1== |
|          String replace(char oldChar,char newChar)           | 返回一个新的字符串<br />它是通过用newChar替换字符串中出现的所有oldChar得到的<br />==不改变原有字符串== |
| String replace(CharSequence target,CharSequence replacement) | 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串 |
|      String replaceAll(String regex,String replacement)      | 使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串 |
|     String replaceFirst(String regex,String replacement)     | 使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串 |
|                boolean matches(String regex)                 |             告知此字符串是否匹配给定的正则表达式             |
|                 String[] split(String regex)                 |            根据给定的正则表达式的匹配拆分此字符串            |
|            String[] split(String regex,int limit)            | 根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个<br />如果超过了，剩下的全部都放到最后一个元素中 |

***

#### String与基本数据类型的转换复习

```java
public void test(){
  String str = "12";
  //String转换为基本数据类型，调用xxx包装类的parseXxx方法
  int number = Integer.parseInt(str);
  //基本数据类型转换为String
  String str = String.valueOf(number);
}
```

***

#### String与包装类型的转换复习

```java
public void test(){
  String str = "123";
  //String转换为包装类
  Integer number = new Integer(str);
  Integer number = Integer.valueOf(str);//也行
  //包装类转换为String
  String str = 	String.valueOf(number);
}
```

***

#### String与char[]\(字符数组)之间的转换

```java
//String转换为char型数组（字符数组）:调用字符串的toCharArray方法即可
public void test(){
  String str = "abc123";
  char[] charArray = str.toCharArray();
  for(char c:charArray){
    System.out.print(c);
  }
}
//字符数组转换为String:只需要调用String类的构造器即可
public void test(){
  char[] charArr = new char[]{'h','e','l','l','o'};
  String str = new String(charArr);
  System.out.print(str);//hello
}
```

***

#### String与byte[]\(字节数组)之间的转换

**字符串→字节数组**

|           方法名称           |                           方法描述                           |
| :--------------------------: | :----------------------------------------------------------: |
|   public byte[] getBytes()   | 使用平台默认的字符集将此字符串编码为byte字节序列<br />并将结果存储到一个新的字节数组中 |
| getBytes(String charsetName) | 使用指定的字符集将字符串编码到字节序列<br />并将结果存储到一个新的字节数组中 |

**字节数组→字符串**

|                方法名                |                           方法描述                           |
| :----------------------------------: | :----------------------------------------------------------: |
|            String(byte[])            | 通过使用平台默认字符集解码指定的字节数组<br />并返回一个新的字符串 |
|  String(byte[],String charsetName)   | 通过使用指定字符集解码指定的字节数组<br />并返回一个新的字符串 |
| String(byte[],int offset,int length) | 用指定的字节数组的一部分构造一个字符串对象<br />即从数组起始位置offset开始截取length个字节构造一个新的字符串对象 |

```java
//String转换为字节数组（编码）:调用字符串的getBytes的方法即可
public void test(){
  String str = "abc123中国";
  byte[] byteArray = str.getBytes();//使用默认的字符集进行编码转换:当时设置过eclipse，所以就是UTF-8
  System.out.print(Arrays.toString(byteArray));//[97,98,99,49,50,51,-28,-72,-83,-27,-101,-67]
  byte[] gbks = str.getBytes("GBK");//指定字符集GBK进行编码转换,字符集名称不区分大小写，也可以是gbk
  System.out.print(Arrays.toString(gbks));//[97,98,99,49,50,51,-42,-48,-71,-6]
  
  /*
  	编码:字符串转换为字节（即看得懂→看不懂的二进制数据）
  	解码:编码的逆过程，字节转换为字符串（即看不懂→看得懂的数据）
  	注意：编码解码只针对与字节才有的定义
  			 编码字符集和解码字符集不一致就会出现乱码
  */
}
//字节数组转换为String（解码）:调用String的构造器即可
public void test(){
  byte[] b = new byte[]{97,98,99,49,50,51,-42,-48,-71,-6};
  String s = new String(b);//没指定则使用默认字符集解码
  String s = new String(gbks,"GBK");//对GBK编码后的字节数组使用GBK字符集进行解码就不会出现乱码的情况
  //说明:解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码
}
```

***

#### 面试中String算法考查的说明

**常见算法题目（464）**

***

### StringBuffer、StringBuilder

> java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象
>
> StringBuffer很多方法都与String相同
>
> 作为参数传递时，方法内部可以改变值
>
> StringBuilder与StringBuffer非常类似，均代表可变的字符序列，而且提供的相关功能方法也都一样
>
> ==注意：作为参数传递的话，方法内部String不会改变原有String值，StringBuffer、StringBuilder会改变原有的值==

#### String、StringBuffer、StringBuilder三者的异同点

+ 相同点
  + 三者的底层都是用char型数组存储数据的
+ 不同点
  + String代表不可变的字符序列——final char[] value;
  + StringBuffer代表可变的字符序列——char[] value，且是线程安全的，因为线程安全所以效率偏低（==考虑多线程时推荐使用==）
  + StringBuilder代表可变的字符序列——char[] value，是JDK5.0新增的，线程不安全，所以效率高（==不考虑多线程或多线程不操作共享数据时推荐使用==）
+ 效率上对比，StringBuilder快于StringBuffer快于String，不涉及多线程就真的推荐==StringBuilder==

***

#### StringBuffer源码解析

```java
public void test(){
  String str = new String();//相当于char[] value = new char[0];
  StringBuffer sf = new StringBuffer();//相当于char[] value = new char[16];即底层创建了一个默认长度(容量)为16的字符数组，对于字符(长度)使用count计数
  System.out.print(sf.length());//0
  sf.append('a');//相当于value[0] = 'a';
  sf.append('b');//相当于value[1] = 'b';
  
  StringBuffer sf2 = new StringBuffer("abc");//相当于char[] value = new char["abc".length() + 16];即底层都会空出16个字符空间，底层字符数组的容量就是构造器字符串参数的长度 + 16
  System.out.print(sf2.length);//3，因为底层返回的是count，而非value.length，所以实际字符串多长就是多长
  
  /*
  	若追加数据，导致底层char数组容不下了，那么就需要扩容底层的数组
  	默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中，再重新赋值给value
  	所以，开发中建议使用StringBuffer(int capacity)或StringBuilder(int capacity)指定容量的构造器,避免再去扩容与复制，效率高些
  */
}
```

***

#### StringBuffer的常用方法

> 增：append(xxx)
>
> 删：delete(int start,int end)
>
> 改：setCharAt(int index,char c)
>
> 查：charAt(int index)
>
> 插入：insert(int offset,xxx)
>
> 长度：length()
>
> 遍历：for + charAt()

|                       方法名                       |                           方法描述                           |
| :------------------------------------------------: | :----------------------------------------------------------: |
|              StringBuffer append(xxx)              | 提供了很多重载的append()方法，用于进行字符串拼接<br />拼接在字符串尾部 |
|       StringBuffer delete(int start,int end)       |  删除指定位置开始到指定位置结束的内容<br />遵循左闭右开原则  |
| StringBuffer replace(int start,int end,String str) |      把[start--end]位置替换为str<br />遵循左闭右开原则       |
|        StringBuffer insert(int offset,xxx)         |      在指定位置上插入xxx<br />当前索引位置上的数据后移       |
|               StringBuffer reverse()               |                      将当前字符序列逆转                      |
|           public int indexOf(String str)           | 返回指定子字符串在此字符串中第一次出现处的索引<br />==注意indexOf和lastIndexOf若未找到子字符串则返回-1== |
|     public String substring(int start,int end)     | 返回一个新字符串，不会改变原有字符串<br />他是此字符串从beginIndex开始截取到endIndex的一个子字符串<br />==包括beginIndex下标元素<br />但不包括endIndex下标元素（左闭右开）== |
|                 public int length                  |                     返回字符串的实际长度                     |
|           public char charAt(int index)            |                    返回指定索引位置的字符                    |
|      public void setCharAt(int index,char ch)      |                    替换指定索引位置的字符                    |

***

## JDK8之前的日期时间API

### System静态方法

> java.lang.System类提供了public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的13位时间差（称为时间戳），此方法适用于计算时间差，通常也用于计算代码执行时间、判断效率
>
> 计算世界时间的主要标准有：
>
> + UTC（Coordinated Universal Time）
> + GMT（Greenwich Mean Time）
> + CST（Central Standard Time）

```java
public void test() {
  long time = System.currentTimeMillis();
  System.out.println(time);//1626312686705
}
```

***

### Java中两个Date类的使用

#### java.util.Date类

##### 两个构造器的使用

> new Date()：创建一个对应当前时间的Date对象
>
> new Date(long date)：创建指定毫秒数的Date对象

```java
public void test(){
  Date date = new Date();//空参构造器
	System.out.println(date.toString());//Thu Jul 15 09:39:31 CST 2021
  Date date1 = new Date(1626313283936L);
	System.out.println(date.toString());//Thu Jul 15 09:39:31 CST 2021
}
```

***

##### 两个方法的使用

> toString()：显示当前时间/指定时间的年、月、日、时、分、秒
>
> getTime()：获取当前Date对象对应的毫秒数（时间戳）

```java
public void test(){
  Date date = new Date();//空参构造器
	System.out.println(date.toString());//Thu Jul 15 09:39:31 CST 2021
  System.out.println(date.getTime());//1626313283936
}
```

***

#### java.sql.Date类

> java.sql.Date对应着数据库中的日期类型的变量
>
> + 如何实例化
> + 如何将java.util.Date对象转换为java.sql.Date对象

##### 实例化Date对象

```java
public void test(){
  //创建java.sql.Date对象
  java.sql.Date date = new java.sql.Date(1626313283936L);
  System.out.print(date);
}
```

***

##### 将java.util.Date对象转换为java.sql.Date对象

```java
public void test(){
  //方式一
  Date date = new java.sql.Date(1626313283936L);//多态
  System.out.print(date);//2021-07-15,看起来像字符串，其实是Date类型
  //方式二
  Date date = new Date();
  java.sql.Date date7 = new java.sql.Date(date.getTime());
}
```

***

### Calendar日历类的使用

> java.util.Calendar（日历类）
>
> Calendar是一个抽象基类，主要用于完成日期字段之间相互操作的功能
>
> 获取Calendar实例的方法
>
> + 使用Calendar.getInstance()方法
> + 调用它的子类GregorianCalendar的构造器
>
> 一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取地想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND
>
> + public void set(int field,int value)
> + public void add(int field,int amount)
> + public final Date getTime()
> + public final void setTime(Date date)
>
> 注意：
>
> + 获取月份时，一月是0，二月是1，以此类推12月是11
> + 获取星期时，周日是1，周一是2，周六是7

```java
//实例化
public void calendarTest(){
  // 方式一：创建其(Calendar)子类的对象
  Calendar c = Calendar.getInstance();
  // 方式二：调用其(Calendar)静态方法getInstance()
  Calendar c2 = Calendar.getInstance();
  System.out.println(c2.getClass());//其实方式一方式二都一样，都是new子类的对象class java.util.GregorianCalendar
}

//常用方法
public void method(){
  //get()方法
  Calendar calendar = Calendar.getInstance();
  int day = calendar.get(Calendar.DAY_OF_MONTH);// 这个月的第几天
  System.out.println(day);//19
  int dayOfYear = calendar.get(Calendar.DAY_OF_YEAR);// 这一年的第几天
  System.out.println(dayOfYear);//200
  // set()
  calendar.set(Calendar.DAY_OF_MONTH, 22);// 设置当天是这个月的第22天，对本身进行修改，所以说Calendar是可变的
  System.out.println(calendar.get(Calendar.DAY_OF_MONTH));// 22
  // add()
  calendar.add(Calendar.DAY_OF_MONTH, 3);// 在这个月第几天的基础上 + 3天，要减去就设置为负数
  System.out.println(calendar.get(Calendar.DAY_OF_MONTH));// 25

  // getTime()：Calendar类转换为Date类
  Date date = calendar.getTime();
  System.out.println(date);// Sun Jul 25 09:42:41 CST 2021

  // setTime()：Date类转换为Calendar类
  Date date1 = new Date();
  calendar.setTime(date1);
  System.out.println(calendar.get(Calendar.DAY_OF_MONTH));// 19
}
```

***

### SimpleDateFormat类

> Date类的API不易于国际化，大部分都被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类
>
> + 它允许进行格式化与解析：
>   + 格式化：日期转换为字符串
>   + 解析：格式化的逆过程，字符串转换为日期
> + 格式化
>   + SimpleDateFormat()：默认的模式和语言环境创建对象
>   + public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用public String format(Date date)方法格式化时间对象date
> + 解析：public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期
> + 要注意的是，==解析日期所使用的格式需与格式化日期所使用的格式相同==

```java
//默认构造器日期格式化，将日期转换为字符串
public void test(){
  Date date = new Date();//创建一个当前日期对象
  SimpleDateFormat sdf = new SimpleDateFormat();//创建SimpleDateFormat对象
  String dateString = sdf.format(date);//调用format的方法格式化当前日期为字符串
  System.out.print(dateString);//默认格式化格式：21-7-19 上午7:12
}

//指定格式构造器格式化日期（主要开发中使用的格式）
public void test(){
  Date date = new Date();//创建一个当前日期对象
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");//创建指定格式的SimpleDateFormat对象
  String dateString = sdf.format(date);//调用format的方法格式化当前日期为字符串
  System.out.print(dateString);//指定格式化格式：2021-07-19 07:22:05
}
```

```java
//解析
public void test() throws ParseException{
  Date date = new Date();
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
  String dateString = sdf.format(date);
  System.out.print(dateString);//2021-07-19 08:42:34
  //按格式化格式进行解析：要求字符串必须符合SimpleDateFormat识别的格式（通过SimpleDateFormat构造器参数体现的）
  Date newDate = sdf.parse(dateString);//也可以指定字符串常量时间
  System.out.print(newDate);//Mon Jul 19 08:42:34 CST 2021
}
```

***

## JDK8中新日期时间API

> JDK1.0中包含了一个java.util.Date类，但是它的大多数方法都已经在JDK1.1引入Calendar类之后被弃用了，而Calendar类不比Date类好多少，他们面临的问题是
>
> + 可变性：像日期和时间这样的类应该是不可变的
> + 偏移性：Date中的年份是从1900年开始的，而月份都是从0开始的
> + 格式化：格式化只对Date有用，Calendar则不行
> + 此外他们也不是线程安全的，不能处理闰秒等等
>
> ==第三次引入的API是成功的==，并且Java8中引入的java.time API已经纠正了过去的缺陷，将来很长一段时间内他都会为我们服务
>
> Java8吸收了Joda-Time（一个jar包，JDK7或之前的版本需要导入）的精华，以一个新的开始为Java创建优秀的API。新的java.time中包含了所有关于--
>
> + 本地日期（LocalDate）
> + 本地时间（LocalTime）
> + 本地日期时间（LocalDateTime）
> + 时区（ZoneDateTime）
> + 持续时间（Duration）
>
> --的类。历史悠久的Date类新增了toInstant()方法，用于将Date转换成新的表示形式。这些新增的本地化时间日期API大大简化了日期时间和本地化的管理
>
> **新时间日期API**
>
> + java.time：包含值对象的基础包 
> + java.time.chrono：提供对不同的日历系统的访问
> + java.time.format：格式化和解析时间和日期
> + java.time.temporal：包括底层框架和扩展特性
> + java.time.zone：包含时区支持的类
>
> 说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一

### LocalDate、LocalTime、LocalDateTime

> LocalDate、LocalTime、LocalDateTime类是其中比较重要的三个类，他们的实例是不可变的对象，分别表示使用ISO-8601日历系统（即公历）的日期、时间、日期和时间。它们提供了简单的本地日期或时间， 并不包含当前的时间信息，也不包含与时区相关的信息
>
> + LocalDate代表IOS格式（yyyy-MM-dd）的日期，可以存储生日、纪念日等日期
> + LocalTime表示一个时间，而非日期
> + ==LocalDateTime==表示日期和时间，这是一个最常用的类之一，相较于上面两个，使用频率高些

#### 三个类的常用方法及描述

|                          静态方法名                          |                           方法描述                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                            now()                             |               获取当前的日期、时间、日期加时间               |
|                             of()                             |      设置指定的年、月、日、时、分、秒<br />==无偏移量==      |
| int getDayOfMonth()<br />int getDayOfYear()<br />DayOfWeek getDayOfWeek() | 获取当月的第几天<br />获取当年的第几天<br />获取当天是星期几，返回对应星期的枚举值（如Monday..） |
|                          getMonth()                          |    获取时间中的月份，返回一个Month的枚举值（如January..）    |
|                getMonthValue()<br />getYear()                |   获取时间中的月份，返回数字（1-12）<br />获取时间中的年份   |
|         getHour()<br />getMinute()<br />getSecond()          | 获取时间中对应的小时数<br />获取时间中对应的分钟数<br />获取时间中对应的秒钟数 |
| withDayOfMonth()<br />withDayOfYear()<br />withMonth()<br />withYear() | 将时间中的月份天数改为指定值并返回新的对象<br />将时间中的年份天数改为指定值并返回新的对象<br />将时间中的月份改为指定值并返回新的对象<br />将时间中的年份改为指定值并返回新的对象<br />==由于返回新的对象，所以体现了不可变性== |
| plusHours()<br />plusDays()<br />plusWeeks()<br />plusMonths()<br />plusYears()<br /> | 向当前时间对象添加几小时<br />向当前时间对象添加几天<br />向当前时间对象添加几周<br />向当前时间对象添加几个月<br />向当前时间对象添加几年 |
| minusHours()<br />minusDays()<br />minusWeeks()<br />minusMonths()<br />minusYears()<br /> | 从当前时间对象减去几小时<br />从当前时间对象减去几天<br />从当前时间对象减去几周<br />从当前时间对象减去几个月<br />从当前时间对象减去几年 |

#### 三个类常用方法的代码示例

```java
//通过调用now()静态方法返回当前类对象的时间——实例化类对象（具体当前时间以当前为准）
LocalDate dateNow = LocalDate.now();// 获取当前的日期
System.out.println(dateNow);// 2021-09-17

LocalTime timeNow = LocalTime.now();// 获取当前的时间
System.out.println(timeNow);// 13:14:59.303

LocalDateTime dateTimeNow = LocalDateTime.now();// 获取当前的日期加时间
System.out.println(dateTimeNow);// 2021-09-17T13:14:59.303
--------------------------------------------------------------------------------------------------------
//通过调用of()静态方法设置指定的年|月|日|时|分|秒|并且没有偏移量以返回指定日期与时间对象
LocalDate dateAppointed = LocalDate.of(2021, 9, 17);// 指定月和日，即日期
System.out.println(dateAppointed);// 2021-09-17

LocalTime timeAppointed = LocalTime.of(13, 14, 59);// 指定时分秒，即时间
System.out.println(timeAppointed);// 13:14:59

LocalDateTime dateTimeAppointed = LocalDateTime.of(2021, 9, 17, 13, 14, 59);// 指定年月日时分秒，即日期加时间
System.out.println(dateTimeAppointed);// 2021-09-17T13:14:59
--------------------------------------------------------------------------------------------------------
//通过调用getXxx()方法返回具体的年|月|日|时|分|秒|或枚举值，此处以LocalDateTime指定日期时间举例
LocalDateTime dateTimeAppointed = LocalDateTime.of(2021, 9, 17, 13, 14, 59);// 指定时间
int dayOfMonth = dateTimeAppointed.getDayOfMonth();// 此处为获取当前指定时间中9月份的天数（为9月份的第几天）
System.out.println(dayOfMonth);// 17

int dayOfYear = dateTimeAppointed.getDayOfYear();// 此处为获取当前指定时间中2021年的天数（为2021年的第几天）
System.out.println(dayOfYear);//260：9月17日这一天是2021年的第260天

DayOfWeek dayOfWeek = dateTimeAppointed.getDayOfWeek();// 此处为获取当前指定时间中17号这一天是周几
System.out.println(dayOfWeek);// FRIDAY

Month month = dateTimeAppointed.getMonth();// 此处为获取当前指定时间中9月份对应的枚举值
System.out.println(month);// SEPTEMBER

int monthValue = dateTimeAppointed.getMonthValue();// 此处为获取当前指定时间中对应的月份数字值
System.out.println(monthValue);// 9

int year = dateTimeAppointed.getYear();// 此处为获取当前指定时间中的对应的年份
System.out.println(year);// 2021

int hour = dateTimeAppointed.getHour();// 此处为获取当前指定时间中对应的小时数
System.out.println(hour);// 13

int minute = dateTimeAppointed.getMinute();// 此处为获取当前指定时间中对应的分钟数
System.out.println(minute);// 14

int second = dateTimeAppointed.getSecond();// 此处为获取当前指定时间中对应的秒钟数
System.out.println(second);// 59
--------------------------------------------------------------------------------------------------------
//通过调用withXxx()方法将时间修改为指定的日期|时间值并返回新的对象，此处以LocalDateTime指定日期时间举例
LocalDateTime dateTimeAppointed = LocalDateTime.of(2021, 9, 17, 13, 14, 59);// 指定时间
LocalDateTime updateDayOfMonth = dateTimeAppointed.withDayOfMonth(30);//此处为修改当前指定时间中月份对应的天数
System.out.println(updateDayOfMonth);// 2021-09-30T13:14:59

LocalDateTime updateDayOfYear = dateTimeAppointed.withDayOfYear(201);// 此处为修改当前指定时间中年份对应的天数
System.out.println(updateDayOfYear);// 2021-07-20T13:14:59

LocalDateTime updateMonthValue = dateTimeAppointed.withMonth(10);// 此处为修改当前指定时间中的月份
System.out.println(updateMonthValue);// 2021-10-17T13:14:59

LocalDateTime updateYear = dateTimeAppointed.withYear(2023);// 此处为修改当前指定时间中的年份
System.out.println(updateYear);// 2023-09-17T13:14:59
--------------------------------------------------------------------------------------------------------
//通过调用plusXxx()方法将对象中的年|月|日|时|分|秒进行加法操作并返回新的对象，此处以LocalDateTime指定日期时间举例
LocalDateTime dateTimeAppointed = LocalDateTime.of(2021, 9, 17, 13, 14, 59);// 指定时间
LocalDateTime addHours = dateTimeAppointed.plusHours(3);// 向当前指定时间对象中对应的小时数进行加3小时操作
System.out.println(addHours);// 2021-09-17T16:14:59

LocalDateTime addDays = dateTimeAppointed.plusDays(3);// 向当前指定时间对象中对应的天数进行加3天操作
System.out.println(addDays);// 2021-09-20T13:14:59

LocalDateTime addWeeks = dateTimeAppointed.plusWeeks(3);// 向当前指定时间对象中对应的天数进行加3周操作（21天）
System.out.println(addWeeks);// 2021-10-08T13:14:59

LocalDateTime addMonths = dateTimeAppointed.plusMonths(3);// 向当前指定时间对象中对应的月份进行加3个月操作
System.out.println(addMonths);// 2021-12-17T13:14:59

LocalDateTime addYears = dateTimeAppointed.plusYears(3);// 向当前指定时间对象中对应的年份进行加3年操作
System.out.println(addYears);// 2024-09-17T13:14:59
--------------------------------------------------------------------------------------------------------
//通过调用minusXxx()方法将对象中的年|月|日|时|分|秒进行减法操作并返回新的对象，此处以LocalDateTime指定日期时间举例
LocalDateTime dateTimeAppointed = LocalDateTime.of(2021, 9, 17, 13, 14, 59);// 指定时间
LocalDateTime dateTimeAppointed = LocalDateTime.of(2021, 9, 17, 13, 14, 59);// 指定时间
LocalDateTime subHours = dateTimeAppointed.minusHours(3);// 向当前指定时间对象中对应的小时数进行减3小时操作
System.out.println(subHours);// 2021-09-17T10:14:59

LocalDateTime subDays = dateTimeAppointed.minusDays(3);// 向当前指定时间对象中对应的天数进行减3天操作
System.out.println(subDays);// 2021-09-14T13:14:59

LocalDateTime subWeeks = dateTimeAppointed.minusWeeks(3);// 向当前指定时间对象中对应的天数进行减3周操作（21天）
System.out.println(subWeeks);// 2021-08-27T13:14:59

LocalDateTime subMonths = dateTimeAppointed.minusMonths(3);// 向当前指定时间对象中对应的月份进行减3个月操作
System.out.println(subMonths);// 2021-06-17T13:14:59

LocalDateTime subYears = dateTimeAppointed.minusYears(3);// 向当前指定时间对象中对应的年份进行减3年操作
System.out.println(subYears);// 2018-09-17T13:14:59
```

***

### 瞬时Instant

> Instant：时间线上具体的一个瞬时点。这可能被用来记录应用程序中的事件时间戳（==Instant的使用类似于java.util.Date==）
>
> 在处理时间和日期的时候，我们通常会想到年月日时分秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中这个数从1970年开始，以秒为单位；同样的，在Java中也是从1970年开始，但以毫秒为单位
>
> java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息。例如，时区概念上讲，它只是简单地表示自1970年1月1日0时0分0秒(UTC)开始的毫秒数，因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级别
>
> 1ns = 10^-9次方s  1秒= 1000毫秒=10^6^次方微秒=10^9^次方纳秒

#### Instant的常用方法及描述

> 时间戳是指格林威治时间1970-01-01 00:00:00（北京时间1970-01-01 08:00:00）起到现在的总秒数

|            方法名            |                           方法描述                           |
| :--------------------------: | :----------------------------------------------------------: |
|            now()             |           静态方法，返回默认UTC时区的Instant类对象           |
| ofEpochMilli(long epocMilli) | 静态方法，返回1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类对象 |
| atOffset(ZoneOffset offset)  |         结合即时的偏移量来创建一个OffsetDateTime对象         |
|        toEpochMilli()        |     返回1970-01-01 00:00:00到当前时间的毫秒数，即时间戳      |

#### Instant常用方法的代码示例

```java
//通过调用now()静态方法返回当前Instant类对象默认本初子午线的标准时间——实例化类对象
Instant instantTime = Instant.now();// 获取本初子午线对应的标准时间，即相较于我们东八区少8个小时的时间
LocalDateTime dateTimeNow = LocalDateTime.now();// 获取当前日期加时间
System.out.println(dateTimeNow);// 2021-07-21T02:19:56.169:当前时间
System.out.println(instantTime);// 2021-07-20T18:19:56.091Z:与当前时间差出8个小时
--------------------------------------------------------------------------------------------------------
//通过调用toEpochMilli()方法获取自1970年1月1日0时0分0秒(UTC)开始至今的毫秒数
Instant instantTime = Instant.now();// 获取本初子午线对应的标准时间对象，即相较于我们东八区少8个小时的时间
long millis = instantTime.toEpochMilli();// 获取自1970年1月1日0时0分0秒(UTC)开始的毫秒数
System.out.println(System.currentTimeMillis());//1626805796330
System.out.println(millis);// 1626805796330:与System类获取时间戳方法的返回值相同
--------------------------------------------------------------------------------------------------------
//通过调用atOffset(ZoneOffset offset)方法调整时间偏移量，使instantTime不再使用默认的时区表示时间
Instant instantTime = Instant.now();// 获取本初子午线对应的标准时间，即相较于我们东八区少8个小时的时间
LocalDateTime dateTimeNow = LocalDateTime.now();// 获取当前日期加时间
OffsetDateTime offSetDateTime = instantTime.atOffset(ZoneOffset.ofHours(8));// 添加时间的偏移量为我们所在的东八区，所以在此对象基础上加8小时，并返回一个OffsetDateTime对象，使用该对象获取当前调整过的时区时间
System.out.println(dateTimeNow);// 当前东八区时间：2021-07-21T02:24:04.624
System.out.println(offSetDateTime);// 调整本初子午线默认时区时间后：2021-07-21T02:24:04.548+08:00
--------------------------------------------------------------------------------------------------------
//通过调用ofEpochMillis(long millis)静态方法，返回1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类对象
Instant instantTime = Instant.now();// 获取本初子午线对应的标准时间，即相较于我们东八区少8个小时的时间
long millis = instantTime.toEpochMilli();// 获取自1970年1月1日0时0分0秒(UTC)开始的毫秒数	
OffsetDateTime instantMilliTime = Instant.ofEpochMilli(millis).atOffset(ZoneOffset.ofHours(8));// 通过给定的毫秒数获取一个instant实例再将其设置偏移量至东八区时间，返回一个OffsetDateTime对象
LocalDateTime dateTimeNow = LocalDateTime.now();// 获取当前日期加时间
System.out.println(dateTimeNow);//2021-07-21T02:42:21.910
System.out.println(instantMilliTime);//2021-07-21T02:42:21.910+08:00
```

***

### DateTimeFormatter类：格式化与解析日期时间

> java.time.format.DateTimeFormatter类（类似于SimpleDateFormat）：该类提供了三种格式化方法
>
> + 预定义的标准格式，如
>   + ISO_LOCAL_DATE
>   + ISO_LOCAL_TIME
>   + ISO_LOCAL_DATE_TIME
> + 本地化相关的格式，括号中需要选定参数，每个方法的参数不一样，不同参数输出的日期|时间格式也不同
>   + ofLocalizedDateTime(参数)
>     + FormatStyle.LONG
>     + FormatStyle.MEDIUM
>     + FormatStyle.SHORT
>   + ofLocalizedDate(参数)
>     + FormatStyle.LONG
>     + FormatStyle.MEDIUM
>     + FormatStyle.SHORT
>     + FormatStyle.FULL
> + 自定义的格式，如
>   + ofPattern("yyyy-MM-dd hh:mm:ss E");

#### DateTimeFormatter常用方法及描述

|           方法名           |                       方法描述                        |
| :------------------------: | :---------------------------------------------------: |
| ofPattern(String pattern)  | 静态方法，返回一个指定字符格式的DateTimeFormatter对象 |
| format(TemporalAccessor t) |           格式化一个日期、时间，返回字符串            |
|  parse(CharSequence text)  |       将指定格式的字符序列解析为一个日期、时间        |

#### DateTimeFormatter常用方法的代码示例

```java
// 实例化方式一：使用预定义的标准格式ISO_LOCAL_DATE_TIME、_ISO_LOCAL_DATE、ISO_LOCAL_TIME三者之一进行实例化
DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;// 使用预定义标准格式之一实例化DateTimeFormatter对象
--------------------------------------------------------------------------------------------------------
//通过调用format(TemporalAccessor t)方法将一个日期时间对象类型格式化为字符串类型
DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;//使用标准的预定义格式之一ISO_LOCAL_DATE_TIME实例化一个DateTimeFormatter对象
LocalDateTime dateTime = LocalDateTime.now();// 创建ISO_LOCAL_DATE_TIME格式所对应的一个LocalDateTime对象
String timeStr = formatter.format(dateTime);// 格式化日期转换为字符串
System.out.println(dateTime);// 2021-07-21T10:14:10.589：LocalDateTime类型
System.out.println(timeStr);// 2021-07-21T10:14:10.589：String类型——格式还是默认为指定的预定义标准格式，所以不变
--------------------------------------------------------------------------------------------------------
// 通过调用parse(CharSequence text)方法将一个字符串类型的日期时间转换为日期时间对象类型
DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;// 使用标准的预定义格式之一ISO_LOCAL_DATE_TIME实例化一个DateTimeFormatter对象
TemporalAccessor dateTime = formatter.parse("2021-07-21T10:14:10.589");// 解析字符串类型的日期时间
System.out.println(dateTime);// {},ISO resolved to 2021-07-21T10:14:10.589：调用了TemporalAccessor的toString()方法
--------------------------------------------------------------------------------------------------------
//实例化方式二：使用本地化相关的格式ofLocalizeddDateTime(参数)进行实例化
DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);
LocalDateTime dateTime = LocalDateTime.now();// 实例化ofLocalizedDateTime()方法对应的LocalDateTime对象
String timeStr = formatter.format(dateTime);// 将日期时间使用本地格式格式化为字符串
System.out.println(dateTime);// 2021-07-21T10:51:56.588：LocalDateTime类型
System.out.println(timeStr);// 格式为：21-7-21 上午10:51：字符串类型
TemporalAccessor parseTime = formatter.parse(timeStr);// 解析字符串类型的日期时间
System.out.println(timeStr);// 21-7-21 上午10:51
System.out.println(parseTime);// {},ISO resolved to 2021-07-21T10:51
--------------------------------------------------------------------------------------------------------
//重点之实例化方式三：使用自定义的格式，如ofPattern("yyyy-MM-dd hh:mm:ss")方法实例化DateTimeFormatter对象
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");// 自定义格式创建对象
LocalDateTime dateTime = LocalDateTime.now();// 获取当前时间
String timeStr = formatter.format(dateTime);// 使用指定格式将日期时间格式化为字符串
System.out.println(dateTime);// 2021-07-21T10:59:56.080：LocalDateTime类型
System.out.println(timeStr);// 2021-07-21 10:59:56：字符串类型
TemporalAccessor parseTime = formatter.parse("2021-07-21 10:59:56");//解析字符串类型的日期时间：要求格式要与formatter对象的自定义格式相对应
System.out.println(parseTime);//{MicroOfSecond=0, MinuteOfHour=59, NanoOfSecond=0, SecondOfMinute=56, HourOfAmPm=10, MilliOfSecond=0},ISO resolved to 2021-07-21
```

***

### 其他API类

+ ZoneId：该类中包含了所有的时区信息，一个时区的ID，如Europe/Paris
+ ZonedDateTime：一个在ISO-8601日历（公历）系统时区的日期时间，如2007-12-03T10:15:30+01.00 Europe/Paris
  + 其中每个时区都对应着ID，地区ID都为"{区域}/{城市}"的格式，例如Asia/Shanghai等
+ Clock：使用时区提供对当前即时、日期和时间的访问的时钟
+ Duration：持续时间，用于计算两个时间间隔
+ Period：日期间隔，用于计算两个日期的间隔
+ TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期时间调整到“下一个工作日”等操作
+ TemporalAdjusters：该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的长同TemporalAdjuster的实现

***

## Java比较器

> 说明：Java中的对象，正常情况下，只能进行比较—— == 或 !=，不能使用 > 或 <，但是在开发场景中，我们需要对多个对象进行排序，言外之意就需要比较对象的大小，如何实现？需要使用以下两个接口中的任何一个
>
> 在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题
>
> Java实现对象排序的方式有两种：
>
> + ==自然排序==：java.lang.Comparable
> + ==定制排序==：java.util.Comparator

### Comparable接口

> Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序
>
> 实现Comparable的类必须实现compareTo(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零
>
> 实现Comparable接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器
>
> 对于类C的每一个e1和e2来说，当且仅当e1.compareTo(e2) == 0与e1.equals(e2)具有相同的boolean值时，类C的自然排序才叫做与equals一致，建议最好使自然排序与equals一致

```java
//自然排序实现第一步：使自定义类实现Comparable接口并重写compareTo()方法
public class Person implements Comparable{
  private String name;
  private int age;
  public Person(String name,int age){
    this.name = name;
    this.age = age;
  }
  @Override
  public int compareTo(Object obj){
   	if(obj instanceof Person){
    	Person other = (Person) obj;
      return this.age - other.age
    }else{
      throw new RuntimeException("传入的类型不匹配");
    }
  }
}

//第二步就可以使用Arrays.sort()或Collections.sort()对Person类对象数组进行排序
public static void main(String[] args){
  Person[] personArr = new Person[3];
  personArr[0] = new Person("Martha",23);
  personArr[1] = new Person("Martha",13);
  personArr[2] = new Person("Martha",25);
  Arrays.sort(personArr);// 使用Arrays.sort()方法进行排序
  System.out.println(Arrays.toString(personArr));
  
  List<Person> list = new ArrayList<Person>();// 使用Collections.sort()方法进行排序
  list.add(new Person("Martha",23));
  list.add(new Person("Martha",13));
  list.add(new Person("Martha",25));
  Collections.sort(list);
  for (Person p : list) {
    System.out.println(p);
  }
}
```

***

### Comparator接口

> 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序，强行对多个对象进行整体排序的比较
>
> 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0则表示相等；返回负整数，表示o1小于o2
>
> 可以将Comparator传递给sort方法（如Collections.sort()或Arrays.sort()）,从而允许在排序顺序上实现精确控制
>
> 还可以使用Comparator来控制某些数据结构，如有序set或有序映射的顺序，或者为那些没有自然顺序的对象collection提供排序

```java
Person p = new Person("Martha", 21);
Person p2 = new Person("Beth", 22);
Person p3 = new Person("Aaserati", 43);
Person p4 = new Person("Martha", 23);
Person[] arr = new Person[4];
arr[0] = p;
arr[1] = p2;
arr[2] = p3;
arr[3] = p4;
Arrays.sort(arr, new Comparator() {
  @Override
  public int compare(Object o1, Object o2) {
    if (o1 instanceof Person && o2 instanceof Person) {
      Person p1 = (Person) o1;
      Person p2 = (Person) o2;
      if (p1.getName().equals(p2.getName())) {
        return -Integer.compare(p1.getAge(), p2.getAge());//年龄从高到低
      } else {
        return p1.getName().compareTo(p2.getName());//姓名从低到高
      }
    }
    return 0;
  }
});
System.out.println(Arrays.toString(arr));
```

***

### Comparable接口与Comparator的使用对比

+ 实现Comparable接口的方式一旦指定，就能够保证Comparable实现类在任何位置都可以比较大小
+ Comparator接口属于临时性的比较（相当于一次性筷子）

***

## System类

> System代表系统，系统的很多属性和控制方法都放置在该类的内部，该类位于java.lang包
>
> 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用
>
> 成员变量
>
> + System类内部包含in、out、err三个成员变量，分别代表标准输入流（键盘输入），标准输出流（显示器）和标准错误输出流（显示器）
>
> 成员方法
>
> + native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间（格林威治时间）1970.1.1.0.0.0所差的毫秒数
>
> + void exit(int status)：该方法的作用是退出程序，其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等
>
> + void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况
>
> + String getProperty(String key)：该方法的作用是获取属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示
>
> + |    属性名    |      属性说明      |
>   | :----------: | :----------------: |
>   | java.version | Java运行时环境版本 |
>   |  java.home   |    Java安装目录    |
>   |   os.name    |   操作系统的名称   |
>   |  os.version  |   操作系统的版本   |
>   |  user.name   |   用户的账户名称   |
>   |  user.home   |    用户的主目录    |
>   |   user.dir   | 用户的当前工作目录 |

```java
String javaVersion = System.getProperty("java.version");
System.out.println("java的version:" + javaVersion);// java的version:1.8.0_291

String javaHome = System.getProperty("java.home");
System.out.println("java的home:" + javaHome);// java的home:E:\Develop\Java\jdk1.8.0_291\jre

String osName = System.getProperty("os.name");
System.out.println("os的name:" + osName);// os的name:Windows 10

String osVersion = System.getProperty("os.version");
System.out.println("os的version:" + osVersion);// os的version:10.0

String userName = System.getProperty("user.name");
System.out.println("user的name:" + userName);// user的name:Martha-X

String userHome = System.getProperty("user.home");
System.out.println("user的home:" + userHome);// user的home:C:\Users\Administrator

String userDir = System.getProperty("user.dir");
System.out.println("user的dir:" + userDir);// user的dir:E:\DevelopProjects\eclipse_workspace\JavaSenior
```

***

## Math类

> java.lang.Math提供了一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型

|           方法名           |                方法描述                 |
| :------------------------: | :-------------------------------------: |
|           abs()            |               计算绝对值                |
| acos,asin,atan,cos,sin,tan |                三角函数                 |
|            sqrt            |                 平方根                  |
|   pow(double a,double b)   |                a的b次幂                 |
|            log             |                自然对数                 |
|            exp             |                e为底指数                |
|   max(double a,double b)   |                求最大值                 |
|   min(double a,double b)   |                求最小值                 |
|          random()          |           返回0.0-1.0的随机数           |
|    long round(double a)    | double类型数据a转换为long型（四舍五入） |
|  toDegrees(double angrad)  |                弧度→角度                |
|  toRadians(double angdeg)  |                角度→弧度                |

***

## BigInteger与BigDecimal

### BigInteger对应整型

> Integer类作为int的包装类，能存储的最大整数值为2^31^-1，Long类也是有限的，最大为2^63^-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了
>
> java.Math包的BigInteger类可以==表示不可变的任意精度的整数==，想表示多少位就表示多少位。BigInteger提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法。另外，BigInteger还提供以下运算：模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作
>
> **构造器**
>
> + BigInteger(String value)：根据字符串构建BigInteger对象

|                      方法名                       |                           方法描述                           |
| :-----------------------------------------------: | :----------------------------------------------------------: |
|              public BigInteger abs()              |             返回此BigInteger的绝对值的BigInteger             |
|         BigInteger add(BigInteger value)          |             返回其值为（this+value）的BigInteger             |
|      BigInteger substract(BigInteger value)       |             返回其值为（this-value）的BigInteger             |
|       BigInteger multiply(BigInteger value)       |             返回其值为（this*value）的BigInteger             |
|        BigInteger divide(BigInteger value)        |             返回其值为（this/value）的BigInteger             |
|      BigInteger remainder(BigInteger value)       |             返回其值为（this%value）的BigInteger             |
| BigInteger[] divideAndRemainder(BigInteger value) | 返回包含（this/value）后跟（this%value）的两个BigInteger的数组 |
|           BigInteger pow(int exponent)            |           返回其值为（this.exponent）的BigInteger            |

***

### BigDecimal对应浮点型

> 一般的Float类和Double类可以用来做科学计算或者工程计算，但在商业计算中，要求数字精度比较高，故用到java.Math.BigDecimal类
>
> BigDecimal类支持不可变的、任意精度的符号十进制定点数
>
> 构造器
>
> + public BigDecimal(double value)
> + public BigDecimal(String value)
>
> 常用方法
>
> + public BigDecimal add(BigDecimal augend)
> + public BigDecimal substract(BigDecimal subtrahend)
> + public BigDecimal multiply(BigDecimal multiplicand)
> + public BigDecimal divide(BigDecimal divisor,int scale(保留的小数位),int roundingMode(模式，如需要四舍五入之类的))

***

# 第十章 枚举类与注解

## 枚举类

> 类的对象只有有限个，确定的，即可以使用枚举类。举例如下
>
> + 星期：Monday-Sunday
> + 性别：Man-Woman
> + 季节：Spring-Winter
> + 支付方式：Cash（现金）、WeChatPay（微信支付）、Alipay（支付宝）、BankCard（银行卡）、CreditCard（信用卡）
> + 就职状态：Busy、Free、Vocation、Dimission（离职状态）
> + 订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）
> + 线程状态：创建、就绪、运行、阻塞、死亡
>
> 当需要定义一组==常量==时，强烈建议使用枚举类
>
> 如果枚举类中只有一个对象，则可以作为单例模式的实现方式
>
> 枚举类中的属性
>
> + 枚举类对象的属性不应该允许被改动，所以应该使用private final修饰
> + 枚举类使用private final修饰的属性应该在构造器中为其赋值
> + 若枚举类显式定义了带参数的构造器，则在列出枚举值时也必须对应地传入构造器实际参数

### 如何自定义枚举类

+ 方式一：JDK5.0之前，自定义枚举类

  ```java
  //自定义枚举类
  class Season {
    public static void main(String[] args) {
  		Season spring = Season.SPRING;
  		System.out.println(spring);// Season [seasonName=春天, seasonDesc=春暖花开]
  	}
  	// ①声明Season对象的属性
  	private final String seasonName;// 季节名称
  	private final String seasonDesc;// 季节描述
  
  	// ②私有化类的构造器
  	private Season(String seasonName, String seasonDesc) {
  		this.seasonName = seasonName;
  		this.seasonDesc = seasonDesc;
  	}
  
  	// ③提供当前枚举类的多个对象（一组常量）：该多个对象必须是public static final的
  	public static final Season SPRING = new Season("春天", "春暖花开");
  	public static final Season SUMMER = new Season("夏天", "夏日炎炎");
  	public static final Season FALL = new Season(" 秋天", "秋高气爽");
  	public static final Season WINTER = new Season("冬天", "白雪皑皑");
  
  	// ④其他诉求：获取枚举类对象的属性
  	public String getSeasonName() {
  		return seasonName;
  	}
  
  	public String getSeasonDesc() {
  		return seasonDesc;
  	}
  
  	// 通常我们也会提供toString()方法
  	@Override
  	public String toString() {
  		return "Season [seasonName=" + seasonName + ", seasonDesc=" + seasonDesc + "]";
  	}
  }
  ```

+ 方式二：JDK5.0，可以使用enum关键字定义枚举类

  ```java
  //使用enum关键字来定义枚举类,enum关键字定义的枚举类默认继承于java.lang.Enum类
  enum Season{
    public static void main(String[] args){
      Season summer = Season.SUMMER();
      System.out.println(summer);// 不重写toString()方法默认输出SUMMER常量对象名，因为不是继承Object类即不输出地址值，此处不指定父类默认继承于java.lang.Enum类，重写toString()方法则按toString()方法格式输出
    }
    //①首先提供当前枚举类的对象，多个对象之间用逗号隔开，末尾对象封号结束（去除相同部分，保留必要部分）
    SPRING("春天", "春暖花开"),
  	SUMMER("夏天", "夏日炎炎"),
  	FALL(" 秋天", "秋高气爽"),
  	WINTER("冬天", "白雪皑皑");
    
    //声明枚举类的属性，此处的private final要留着
    private final String seasonName;
    private final String seasonDesc;
    
    // ④其他诉求：获取枚举类对象的属性
  	public String getSeasonName() {
  		return seasonName;
  	}
  
  	public String getSeasonDesc() {
  		return seasonDesc;
  	}
  
  }
  ```

***

### Enum类的主要方法

|       方法名        |                           方法描述                           |
| :-----------------: | :----------------------------------------------------------: |
|      values()       | 返回枚举类型的对象数组。<br />该方法可以很方便地遍历所有的枚举常量对象 |
|      valueOf()      | 传递枚举类型的Class对象和枚举常量名称给静态方法valueOf，会得到与参数匹配的枚举常量<br />若没有与之匹配的枚举类常量对象，则抛异常 |
|     toString()      | 得到当前枚举常量的名称，你可以通过重写这个方法来使得到的结果更加易读 |
|      equals()       | 在枚举类型中可以直接使用"=="来比较两个枚举常量是否相等。<br />Enum提供的equals方法，也是直接使用"\=="实现的。<br />它的存在是为了在Set、List和Map中使用。注意，equals是不可变的 |
|     hashCode()      |   Enum实现了hashCode()来和equals()保持一致。它也是不可变的   |
| getDeclaringClass() | 得到当前枚举常量所属类型的Class对象<br />可以用它判断两个枚举类型是否属于同一个枚举类型 |
|       name()        |      得到当前枚举常量的名称<br />建议优先使用toString()      |
|      ordinal()      |                    得到当前枚举常量的次序                    |
|     compareTo()     | 枚举类型实现了Comparable接口，这样可以比较两个枚举常量的大小（按照声明的顺序排列） |
|       clone()       | 枚举类型不能被Clone。<br />为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone() |

***

### 实现接口的enum关键字枚举类

+ 情况一：实现接口，在enum类中实现抽象方法

```java
interface Info{
  void show();
}
enum Season implements Info{
  @Override
  public void show(){
    System.out.println("这是一个季节")
  }
}
```

+ 情况二（特别）：每一个枚举类常量对象都实现接口中的方法即可，每一个枚举类都会执行各自重写后的该方法

```java
interface Info{
  public abstract void show();
}
enum Season implements Info{
 	SPRING("春天", "春暖花开"){
    @Override
    public void show(){
      System.out.println("这是一个春天")
    }
  },
	SUMMER("夏天", "夏日炎炎"){
    @Override
    public void show(){
      System.out.println("这是一个夏天")
    }
  },
	FALL(" 秋天", "秋高气爽"){
    @Override
    public void show(){
      System.out.println("这是一个秋天")
    }
  },
	WINTER("冬天", "白雪皑皑"){
    @Override
    public void show(){
      System.out.println("这是一个冬天")
    }
  };
}
```

***

## 注解Annotation

### 注解的概述

> 从JDK5.0开始，Java增加了对元数据（MetaData）的支持，也就是Annotation注解，言外之意注解就是JDK5.0的新特性
>
> Annotation其实就是代码里的特殊标记，这些标记可以在编译、类加载、类运行时被读取并执行相应的处理。通过使用Annotation程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息、代码分析工具、开发工具及部署工具可以通过这些补充信息进行验证或者进行部署
>
> Annotation可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的name="value"键值对中
>
> 在JavaSE中，注解的使用目的比较简单。例如标记过时的功能、忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版本中遗留的繁琐冗余代码和XML配置等
>
> 未来的开发模式都是基于注解的，JPA（Java持久化API）也是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式

***

### 常见的Annotation举例

> 使用Annotation时要在其前面增加@符号，并将该Annotation当成一个修饰符使用，用于修饰它支持的程序元素

#### 示例一：生成文档相关的注解

> 关于以下注解的说明
>
> + @param、@return、@exception：只适用于方法
> + @param的格式要求：@param 形参名称 形参类型 形参说明
> + @return的格式要求：@return 返回值类型 返回值说明
> + @exception的格式要求：@exception 异常类型 异常说明
> + @param和@exception可以并列写多个

|  注解名称  |                           注解描述                           |
| :--------: | :----------------------------------------------------------: |
|  @author   |         标明开发该类模块的作者，多个作者之间逗号隔开         |
|  @version  |                      标明该类模块的版本                      |
|    @see    |                   参考转向，也就是相关主题                   |
|   @since   |                     从哪个版本开始增加的                     |
|   @param   |         对方法中某参数的说明，如果没有参数就不能标注         |
|  @return   |   对方法返回值的说明，如果方法的返回值类型是void就不能标注   |
| @exception | 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出异常就不能标注 |

***

#### 示例二：在编译时进行格式检查（JDK内置的三个基本注解）

|     注解名称      |                           注解描述                           |
| :---------------: | :----------------------------------------------------------: |
|     @Override     |             限定重写父类方法，该注解只适用于方法             |
|    @Deprecated    | 用于表示所修饰的元素（类、方法等）已经过时<br />通常是因为所修饰的结构危险或存在更好的选择 |
| @SuppressWarnings |                        抑制编译器警告                        |

***

### 示例三：跟踪代码依赖性，实现替代配置文件功能

>Servlet3.0提供了注解（Annotation）使得不再需要在web.xml文件中进行Servlet部署
>
>Spring框架中关于事务的管理

***

### 自定义注解

> 可参照SuppressWarnings定义，一般也很少自定义注解，都是使用现成的
>
> 定义新的Annotation类型使用@interface关键字
>
> 自定义注解自动继承了java.lang.annotation.Annotation接口
>
> Annotation的成员变量在Annotation定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组
>
> 可以在定义Annotation的成员变量时为其指定初始值，指定成员变量的初始值可以使用default关键字
>
> 如果只有一个参数成员，建议使用参数名为value
>
> 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式为”参数名 = 参数值“，若只有一个参数成员，且名称为value，可以省路“value=”
>
> 没有成员定义的Annotation称为标记（如@Override），包含成员变量的Annotation称为元数据Annotation
>
> 如果注解有成员，在使用注解时需要指明成员的值
>
> 注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义，自定义注解通常都会指明两个元注解：Retention、Target

```java
//①注解声明为@interface
public @interface MyAnnotation{
  //②内部定义成员，通常使用value表示
  String value() default "hello";
  //③可以指定成员的默认值，使用default定义
  //如果自定义注解没有成员，如@Override就表明是一个标识作用
}
```

***

### JDK中提供的4种元注解

> JDK的元注解是用于修饰其它注解而定义的，即修饰其它注解的注解
>
> JDK5.0提供了4个标准的meta-annotation类型，分别是：
>
> + Retention
> + Target
> + Documented
> + Inherited
>
> 元数据的理解：对现有数据修饰的一个数据叫做元数据，即String  和  name可以成为元数据，Martha称为数据
>
> String name = ”Martha“;

#### @Retention

> 只能用于修饰一个Annotation定义，用于指定被修饰注解的生命周期，@Retention包含一个RetentionPolicy类型的成员变量，使用@Retention时必须为该value成员变量指定值：
>
> + RetentionPolicy.SOURCE：在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释
> + RetentionPolicy.CLASS：在class文件中有效（即class字节码文件保留），当运行Java程序时，JVM不会保留注释，这是默认值
> + RetentionPolicy.RUNTIME：在运行时有效（即运行时保留），当运行Java程序时，JVM会保留注释。程序可以通过反射获取该注释

***

#### @Target

> 用于指定被修饰的注解能用于修饰哪些程序元素

***

#### @Documented

> 用于指定被该元注解修饰的注解类将被javadoc工具提取成文档，即该注解类在被javadoc解析时会保留下来。默认情况下，javadoc解析后是不包括注解的
>
> + 定义为Documented的注解必须设置Retention为RetentionPolicy.RUNTIME

***

#### @Inherited

> 被它修饰的注解将具有继承性，如果某个类使用了被该元注解修饰了的注解，则其子类将自动具有该注解
>
> + 若将标有该元注解的自定义注解标注在类级别上，子类则可以继承父类类级别的注解
> + 实际应用中，使用较少

***

### 利用反射获取注解信息（在反射部分涉及）

### JDK8中注解的新特性

#### 可重复注解

> 步骤
>
> + 在需要使用的重复注解类上方声明@Repeatable，成员值为绑定注解类.class
> + 重复注解类与绑定注解类的生命周期、可修饰结构等元注解声明需要一致

```java
@Repeatable(MyAnnotations.class)
@Retention(Retention.RUNTIME)
@Target({TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE})
public @interface MyAnnotation{
  String value() default "h";
}
@Retention(Retention.RUNTIME)
@Target({TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE})
public @interface MyAnnotations{
  MyAnnotation[] values();
}

@MyAnnotation(value="hi")
@MyAnnotation(value="hello")
public class Person{
  
}
```

***

#### 类型注解

+ Element.TYPE.PARAMETER：表示该注解能写在类型变量的声明语句中（如泛型声明）
+ ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中

```java
class Generic<@MyAnnotation T>{
  public void show()throws @MyAnnotation RuntimeException{
    ArrayList<@MyAnnotation String> list = new ArrayList<>();
    int num = (@MyAnnotation int)10L;
  }
}
```

***

# 第十一章 Java集合

## Java集合框架概述

> 一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java集合就像一种容器，可以动态地将多个对象的引用放入容器中
>
> **数组在内存存储方面的特点**：
>
> + 数组初始化以后，其长度就确定了
> + 数组声明的类型，就决定了进行元素初始化时的类型，即数组一旦定义好，其元素的类型也就确定了，我们也就只能操作指定类型的数据如String[] arr;int[] arr;Object[] arr
>
> **数组在存储数据方面的弊端**：
>
> + 数组一旦初始化以后，其长度就不可变了，不便于扩展
> + 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高（线性表结构）。同时无法直接获取实际存储元素的个数
> + 数组存储的数据是有序的、可以重复的——存储的数据的特点单一，对于无序的、不可重复的需求，数组无法满足
>
> Java集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组

+ 集合、数组都是对多个数据进行存储操作的结构，简称Java容器【说明此时的存储，主要指的是==内存层面的存储==，不涉及到持久化的存储】
+ Java集合可分为Collection和Map两种体系
  + Collection接口：单列集合数据，定义了存取一组对象的方法的集合
    + List：元素有序、可重复的集合数据——动态数组
      + ArrayList
      + LinkedList
      + Vector
    + Set：元素无序、不可重复的集合数据——高中讲的集合
      + HashSet
      + LinkedHashSet
      + TreeSet
  + Map接口：双列集合数据，保存具有映射关系“key-value”键值对的集合
    + HashMap
    + LinkedHashMap
    + TreeMap
    + HashTable
    + Properties

***

## Collection接口方法

> 向Collection接口的实现类中添加数据obj中，要求obj所在类要重写equals方法

|          方法名           |                           方法描述                           |
| :-----------------------: | :----------------------------------------------------------: |
|       add(Object e)       |                     将元素e添加到集合中                      |
|          size()           |                    获取添加的实际元素个数                    |
|   addAll(Collection c)    |           将另一个集合c中的元素全部添加进该集合中            |
|         isEmpty()         |                     判断当前集合是否为空                     |
|          clear()          |      清空集合元素\|<br />集合对象依然还在，就是没有元素      |
|   contains(Object obj)    | 判断当前集合中是否包含obj对象<br />会通过equals方法判断内容是否相等 |
| containsAll(Collection c) |         判断形参c中的所有元素是否都存在于当前集合中          |
|    remove(Object obj)     | 移除当前集合中对应的obj元素<br />会通过equals方法判断元素是否存在于集合中 |
|  removeAll(Collection c)  | 从当前集合中移除c集合中所有对应的元素（差集）<br />只会移除有与之对应的元素<br />移除后会改变当前集合 |
|        retainAll()        |          获取当前集合与c集合的交集，并改变当前集合           |
|    equals(Object obj)     | 要想返回true，需要当前集合和形参集合元素都相同<br />有序或无序也会影响返回值，取决于当前List实现类 |
|        hashCode()         |           根据集合中的元素返回当前集合对象的哈希值           |
|    Object[]  toArray()    |                   将当前集合对象转换为数组                   |
|   Arrays.asList(T...a)    | 调用Arrays类的静态方法asList()将数组转换为集合对象<br />可变形参就相当于是数组类型，可以传入一个数组<br />注意基本数据类型数组只会被识别为可变形参中的一个元素（输出地址值）<br />只有类对象数组如包装类才会识别其中的每个值（输出内容值） |
|        iterator()         |    返回Iterator迭代器接口的实例对象<br />用于遍历集合元素    |

***

## Iterator迭代器接口遍历Collection对象

> Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素
>
> GOF给迭代器模式的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需要暴露该对象的内部细节。迭代器模式就是为容器而生，类似于公交车上的售票员等
>
> Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象
>
> Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力，如果需要创建Iterator对象，则必须有一个被迭代的集合
>
> 集合对象每次调用iterator()方法都会得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前

|         方法名          |                           方法描述                           |
| :---------------------: | :----------------------------------------------------------: |
|    boolean hasNext()    |             判断当前集合对象中是否还有下一个元素             |
|         next()          | 先指针下移，指向下一个集合元素，可用于返回该位置上的集合元素 |
| default  void  remove() | 可以在遍历集合时移除集合中指定的元素<br />此方法不同于集合中直接调用的remove()方法 |

```java
//Iterator遍历集合对象使用示例
Collection coll = new ArrayList();// 创建集合对象并往里添加元素
coll.add("AAA");
coll.add(123);
coll.add(new Date());
Iterator iterator = coll.iterator();// 调用当前集合对象的iterator()方法返回一个迭代器对象
while (iterator.hasNext()) {// 若集合中指针后还有下一个元素则进入循环
  System.out.println(iterator.next());// 指针下移并打印集合中指针所指的集合元素
}
--------------------------------------------------------------------------------------------------------
//调用remove()方法移除集合中指定的元素
Collection coll = new ArrayList();// 创建集合对象并往里添加元素
coll.add("AAA");
coll.add(123);
coll.add(new Date());
Iterator iterator = coll.iterator();// 调用当前集合对象的iterator()方法返回一个迭代器对象
while(iterator.hasNext()){// 若集合中指针后还有下一个元素则进入循环
  Object obj = iterator.next();// 保存当前集合元素
  if("AAA".equals(obj)){// 判断当前集合元素是否是要移除的元素
    iterator.remove();// 是则移除
  }
}
Iterator iterator = coll.iterator();// 调用当前集合对象的iterator()方法返回一个新的迭代器对象
while (iterator.hasNext()) {// 若集合中指针后还有下一个元素则进入循环
  System.out.println(iterator.next());// 指针下移并打印集合中指针所指的集合元素，可以发现集合中已经没有"AAA"
}
```

***

### Iterator迭代器使用注意点

+ Iterator主要用于遍历Collection接口，不包含Map接口

+ Iterator可以删除集合的元素，但是是在遍历过程中通过调用迭代器对象的remove()方法，不是调用集合对象的remove()方法
+ 如果还未调用next()或在上一次调用next()方法之后已经调用了remove()方法，若再调用remove都会报异常IllegalStateException，即指针下本没有元素或没有元素（remove过）时，调用remove()方法会报异常
  + 指针指向第一个元素之前时，直接就调用remove()方法会报异常
  + 指针指向元素时，调用了两次remove()方法，也会报异常

***

## 新特性增强for循环遍历Collection或Array

> foreach循环又称为增强for循环
>
> 格式为：for(集合/数组元素类型  局部变量  ： 集合/数组对象){}

```java
//遍历集合对象
Collection coll = new ArrayList();// 创建集合对象并往里添加元素
coll.add("AAA");
coll.add(123);
coll.add(new Date());
for(Object obj : coll){// 内部仍然调用了Iterator迭代器
  System.out.prinln(obj);
}
--------------------------------------------------------------------------------------------------------
//遍历数组对象
int[] arr = new int[]{1,2,3,4};
for(int i : arr){
  System.out.println(i);
}
```

***

## Collection子接口一：List

### List接口概述

> 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组——动态数组
>
> List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引
>
> List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素
>
> JDK API中List接口的实现类常用的有
>
> + ArrayList
> + LinkedList
> + Vector

***

### ArrayList的源码分析

#### JDK7.0及之前ArrayList的源码

```java
ArrayList list = new ArrayList();// 调用ArrayList的空参构造器则在底层创建了长度为10的Object[] elementData数组
list.add(123);// 相当于emlementData[0] = new Integer(123);
...
list.add(11);// 若此次添加导致底层elementData数组容量不够，则扩容，默认情况下扩容为原有容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中
//结论：建议开发中使用带参的构造器,会避免在中间环节再扩容：ArrayList list = new ArrayList(50);//指定底层数组容量
```

***

#### JDK8.0ArrayList的变化

```java
ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}，并没有创建长度为10的数组
list.add(123);// 当第一次调用添加操作，底层才创建了长度为10的数组，并将数据123添加到elementData[0]
...
// 后续的添加与扩容操作与JDK7无异
```

***

#### 总结

+ JDK7中的ArrayList对象的创建类似于单例模式中的饿汉式
+ JDK8中的ArrayList对象的创建类似于单例模式中的懒汉式，延迟了数组的创建，一定程度上节省了内存

***

### LinkedList的源码分析

```java
LinkedList list = new LinkedList();// 内部声明了Node类型的first和last属性，默认值为null
list.add(123);// 将123封装到Node当中，创建了Node对象
// 其中Node定义为，体现了LinkedList双向链表的特性
private static class Node<E>{
  E item;
  Node<E> next;
  Node<E> prev;
  Node(Node<E> prev,E element,Node<E> next){
    this.item = element;
    this.next = next;
    this.prev = prev;
  }
}
```

***

### Vector的源码分析

```java
Vector vector = new Vector();// 构造器创建对象时，底层都创建了长度为10的数组，在扩容方面默认扩容为原来长度的2倍
```

***

### ArrayList、LinkedList、Vector三者的异同点

+ 相同点
  + 三个类都实现了List接口
  + 都是存储有序的、可重复的数据
+ 不同点
  + **ArrayList**作为List接口的主要实现类；**LinkedList**作为List接口的次要实现类；**Vector**作为List接口的古老实现类
  + **ArrayList**线程不安全，效率高；**LinkedList**；**Vector**是线程安全的，所以效率低
  + **ArrayList**使用Object[]数组类型顺序存储；**LinkedList**底层使用双向链表存储，对于频繁的插入删除操作效率比ArrayList高；**Vector**底层也是使用Object[]数组类型顺序存储

***

### List接口的常用方法

|                    方法名                     |                           方法描述                           |
| :-------------------------------------------: | :----------------------------------------------------------: |
|             void add(Object obj)              |            将指定元素obj添加至集合中<br />==增==             |
|           Object remove(int index)            |      移除指定index位置的元素，并返回此元素<br />==删==       |
|     Object set(int index,Object element)      |         更改指定index位置的元素为element<br />==改==         |
|             Object get(int index)             |             获取指定index位置的元素<br />==查==              |
|      void add(int index,Object element)       |           在index位置插入element元素<br />==插入==           |
|                  int size()                   |                 获取集合的长度<br />==长度==                 |
|           Iterator/foreach/普通循环           |                遍历集合中的元素<br />==遍历==                |
| boolean addAll(int index,Collection elements) |        从index位置开始将elements中所有的元素添加进来         |
|            int indexOf(Object obj)            | 返回obj元素在当前集合中首次出现的位置<br />若不存在则返回-1  |
|          int lastIndexOf(Object obj)          | 返回obj元素在当前集合中最后出现的位置<br />若不存在则返回-1  |
|    List subList(int fromIndex,int toIndex)    | 返回从fromIndex到toIndex位置（左闭右开区间）的子集合<br />==原有List不会被改变== |

***

## Collection子接口二：Set

> Set集合主要是用于存储==无序的、不可重复==的数据——犹如高中讲的集合
>
> Set接口中没有额外定义新的方法，使用的都是Collection中的方法

### Set实现类之一：HashSet

> HashSet是Set接口的典型实现，大多数时候使用Set集合时都是用这个实现类
>
> HashSet按照Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除的性能
>
> HashSet具有以下特点
>
> + 不能保证元素的排列顺序
> + HashSet不是线程安全的
> + 存入的集合元素可以为null
>
> HashSet集合判断两个元素相等的标准为：
>
> + 两个对象通过hashCode()方法比较相等
> + 两个对象的equals()返回值也相等
>
> 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则——==相等的对象必须具有相等的散列码（哈希值）==，即两个对象的equals()返回true，哈希值也必须相同

### Set接口实现类的对比

+ HashSet
  + LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历（遍历出来的顺序就是添加数据时的顺序）
+ TreeSet：要求放入TreeSet中的数据需要是同一个类型的数据，可以按照添加对象的指定属性进行排序

***

### Set接口无序性与不可重复性的理解

+ Set的无序性不等于随机性，以HashSet为例说明，HashSet存储的数据在底层数组中并非按照数组索引的顺序添加的，而是根据数据的哈希值决定的
+ Set的不可重复性：保证添加的元素按照equals()方法判断时不能返回true，即相同的元素只能添加进一个

### HashSet中元素的添加过程

> 向HashSet中添加A元素的过程
>
> + 首先调用A元素所在类的hashCode()方法，计算A元素的哈希值
> + 此哈希值接着通过某种函数计算出A元素在HashSet底层数组中的存放位置（即索引位置），判断该位置上是否已经有元素，如果此位置没有其它元素则A元素直接添加成功
> + 如果此位置上有其它元素B或者以链表形式存在的多个元素，首先比较A元素与B元素的哈希值，如果哈希值不同则元素A添加成功；如果哈希值相同，则需要调用A元素所在类的equals()方法，则B元素或其它多个元素作为形参传入A元素的equals()方法进行比较
>   + equals()方法返回true，则A元素添加失败
>   + equals()方法返回false，则A元素添加成功
>
> 对于位置上有其它元素还添加成功的情况，A元素与其它已经存在在指定索引位置上的元素以链表的方式存储
>
> + JDK7中A元素放入数组索引位置中，指向其它原有元素（原有的让给新来的，新来的指向原有的）
> + JDK8中，则为其它原有元素在数组索引位置中，指向A元素（原有的指向新来的）
> + 总结：七上八下，HashSet底层是使用数组 + 链表的结构

***

### 关于hashCode与equals方法的重写

> 向Set中添加数据，数据所在的类一定要重写hashCode()与equals()方法，且两个方法一定要保证一致性
>
> + 即两个对象的equals()返回true，哈希值也必须相同（直接同时生成两个方法即可保证一致性）

#### 重写hashCode()方法的基本原则

+ 在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的哈希值
+ 当两个对象的equals()方法比较返回值为true时，这两个对象的hashCode()方法返回的哈希值也应该相等
+ 对象中作为equals()方法比较的属性，都应该用来计算哈希值，即在equals方法中出现的属性，在hashCode方法中也应该出现

***

### LinkedHashSet的使用

> LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据之间还维护了两个引用，用于记录数据的前一个数据与后一个数据，对于频繁地遍历操作，LinkedHashSet效率高于HashSet

***

### TreeSet的自然排序

> 向TreeSet中添加的数据，要求是同一个对象类型，如都是String类型、都是Integer类型
>
> 自然排序中，比较两个对象是否相同的标准为：compareTo()方法的返回值，若返回值为0则认为两个对象相等，则不再是通过equals()方法进行比较了，若两个对象相等，则后来的对象无法添加进去

```java
//关于非自定义类TreeSet的使用说明
Set treeSet = new TreeSet();
//添加一致类型的自动装箱的Integer类型的数据
treeSet.add(-3);
treeSet.add(-35);
treeSet.add(65);
treeSet.add(5);
Iterator iterator = treeSet.iterator();
while(iterator.hasNext()){
  System.out.print(iterator.next() + " ");// 由于TreeSet的自然排序，输出结果为: -5 -3 5 65
}
--------------------------------------------------------------------------------------------------------
//关于自定义类的TreeSet的使用说明
//自定义类需要实现Comparable接口并重写compareTo()方法，指明按照啥属性排序
public class Person implements Comparable {
	private String name;
	private int age;

	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	/*
	 * 	按照姓名从小到大排列，姓名相同则按照年龄从小到大排列
	 */
	@Override
	public int compareTo(Object o) {
		if (o instanceof Person) {
			Person other = (Person) o;
			int result = this.name.compareTo(other.name);
			if (result != 0) {
				return result;
			} else {
				return Integer.compare(this.age, other.age);
			}
		} else {
			throw new RuntimeException("传入类型不一致");
		}
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}

}
Set treeSet = new TreeSet();
treeSet.add(new Person("Va", 21));
treeSet.add(new Person("Ab", 12));
treeSet.add(new Person("Ab", 11));
treeSet.add(new Person("Ec", 22));
Iterator iterator = treeSet.iterator();
while (iterator.hasNext()) {
  System.out.println(iterator.next());
}
```

***

### TreeSet的定制排序

> 在定制排序中比较两个对象是否相等的标准为：compare()方法，若返回值为0则认为两个对象相等，则不再是通过equals()方法进行比较了

```java
Comparator comparator = new Comparator(){
  //按照年龄从小到大排列
  @Override
  public int compare(Object o1,Object o2){
    if(o1 instanceof Person && o2 instanceof Person){
      Person p1 = (Person)o1;
      Person p2 = (Person)o2;
      return Integer.compare(p1.getAge(),p2.getAge());
    }else{
      throw new RuntimeException("传入类型不一致");
    }
    return 0;
  }
};
Set treeSet = new TreeSet(comparator);//将Comparator对象传入TreeSet构造器，则TreeSet会按照Comparator定制排序
treeSet.add(new Person("Va", 21));
treeSet.add(new Person("Ab", 12));
treeSet.add(new Person("Ab", 11));
treeSet.add(new Person("Ec", 22));
Iterator iterator = treeSet.iterator();
while (iterator.hasNext()) {
  System.out.println(iterator.next());
}
```

## Map接口

### Map接口及其多个实现类的对比

> Map:存储双列数据，存储键值对的数据——类似于高中的函数，实现类如下：

+ HashMap

  > + HashMap是Map接口的主要实现类
  > + HashMap线程不安全，但效率高
  > + HashMap支持存储null值的key或value
  > + HashMap底层实现在JDK7及之前为：数组 + 链表；在JDK8为：数组 + 链表 + 红黑树

  + LinkedHashMap

    > + LinkedHashMap是HashMap的子类
    > + LinkedHashMap可以在遍历Map元素时，按照添加的顺序实现遍历
    > + LinkedHashMap在原有的HashMap底层结构基础上，添加了一对指针，指针指向前一个和后一个元素，对于频繁的遍历操作，LinkedHashMap的执行效率高于HashMap

+ TreeMap

  > + TreeMap类似于TreeSet类，可以按照所添加的key-value对进行排序，实现排序遍历，此时考虑key的自然排序或者定制排序
  > + TreeMap底层使用的是红黑树，即二叉排序树的结构

+ Hashtable

  > + Hashtable是Map接口的古老实现类，在JDK1.0时就有了
  > + Hashtable线程安全，但效率低
  > + Hashtable不支持存储null值的key或value

  + Properties：

    > + Properties是Hashtable的子类
    > + 常用于处理配置文件，key和value都是String类型

***

### Map中存储的key-value的特点

+ Map中的key（==键==）
  + 是无序的、不可重复的，即使用Set存储所有的key
  + 以HashMap为例，HashMap要求key所在的类要重写hashCode()与equals()方法
+ Map中的value（==值==）
  + 是无序的、但可重复，使用Collection存储所有的value
  + 以HashMap为例，HashMap要求value所在的类要重写equals()方法
+ 一个键值对，即key-value构成了一个Entry对象
+ Map中的entry：是无序的、不可重复的，即使用Set存储所有的entry

***

### Map实现类之HashMap

> HashMap是Map接口使用频率最高的实现类
>
> HashMap允许存储null键与null值，与HashSet一样，不保证映射的顺序
>
> 所有的key构成的集合是Set：无序的、不可重复的，所以HashMap在存储键值对时，要求key所在的类要重写hashCode()与equals()方法
>
> 所有的value构成的集合是Collection：无序的、可重复的，所以HashMap在存储键值对时，要求value所在的类要求要重写equals()方法
>
> 一个key-value（键值对）构成一个Entry对象
>
> 所有的Entry构成的集合是Set：无序的、不可重复的
>
> HashMap判断两个key相等的标准为：
>
> + 两个key值通过equals()方法比较返回值为true
> + 两个key值的hashCode值也相等
>
> HashMap判断两个value相等的标准为：
>
> + 两个value通过equals()方法比较返回值为true

***

### Map接口中的常用方法

#### Map接口中的常用方法及描述

|                方法名                |                           方法描述                           |
| :----------------------------------: | :----------------------------------------------------------: |
| Object  put(Object key,Object value) |   将指定键值对添加到（或修改）当前map对象中<br />==增/改==   |
|      Object  remove(Object key)      |     移除指定key所对应的键值对，并返回value值<br />==删==     |
|       Object  get(Object key)        | 获取指定key所对应的value值<br />若key不存在则返回的value值为null<br />==查== |
|             int  size()              |           返回map对象中键值对的个数<br />==长度==            |
|   boolean  containsKey(Object key)   |                判断当前map中是否包含指定的key                |
| boolean  containsValue(Object value) |               判断当前map中是否包含指定的value               |
|          boolean  isEmpty()          |                   判断当前map对象是否为空                    |
|     boolean  equals(Object obj)      |               判断当前map对象与obj对象是否相等               |
|        void  putAll(Map map)         |           将map中所有的键值对存放到当前map调用者中           |
|            void  clear()             |                   清空当前map中的所有数据                    |

#### Map接口中的常用方法及代码示例

```java
//调用put()方法可添加指定键值对或修改重复键所对应的value值
Map map = new HashMap();// 创建HashMap的实现类对象
map.put("AA", 97);// 添加键值对数据
map.put(45, 123);
map.put("AA", 60);// 此处的数据会覆盖与其键"AA"相同键值对所应的value值
System.out.println(map);// 输出结果为：{AA=60, 45=123}
--------------------------------------------------------------------------------------------------------
//调用putAll()方法将map1中所有的键值对数据存入map中
Map map = new HashMap();// 创建map对象
map.put("AA", 98);// 往map中添加键值对数据
map.put("BB", 66);
Map newMap = new HashMap();// 创建新的newMap对象
newMap.put(1, 3.12);// 往newMap对象中添加键值对数据
newMap.put(2, 6.33);
map.putAll(newMap);// 将newMap中的数据全部添加进map对象中
System.out.println(map);// 输出结果为：{AA=98, BB=66, 1=3.12, 2=6.33}
--------------------------------------------------------------------------------------------------------
//调用remove(Object key)方法移除指定key所保存的键值对
Map map = new HashMap();// 创建map对象
map.put(1, 3.33);// 往map中添加键值对数据
map.put(2, 2.36);
map.put(3, 3.14);
map.remove(2);// 移除map中key为2所对应的键值对数据
System.out.println(map);// 输出结果为：{1=3.33, 3=3.14}
--------------------------------------------------------------------------------------------------------
//调用get(Object key)方法获取map对象中指定key所对应的value值
Map map = new HashMap();// 创建map对象
map.put(1, 3.33);// 往map中添加键值对数据
map.put(2, 2.36);
map.put(3, 3.14);
Object value = map.get(3);// 获取map对象中key为3所对应的value值
System.out.println(value);// 输出结果为：3.14
Object value2 = map.get(4);// 获取map对象中不存在的key所对应的value值
System.out.println(value2);// 输出结果为：null
--------------------------------------------------------------------------------------------------------
//调用containsKey(Object key)、containsValue(Object value)方法判断map对象中是否有对应的key或value值
Map map = new HashMap();// 创建map对象
map.put(1, 3.33);// 往map中添加键值对数据
map.put(2, 2.36);
map.put(3, 3.14);
boolean isKey = map.containsKey(2);// 判断当前map对象中是否存在一个key为2的键
boolean isValue = map.containsValue(3.14);// 判断当前map对象中是否存在一个value为3.14的值
System.out.println(isKey);// 输出结果为：true
System.out.println(isValue);// 输出结果为：true
--------------------------------------------------------------------------------------------------------
//调用clear()方法清空map对象中保存的所有键值对数据，并调用isEmpty()方法判断map对象是否为空
Map map = new HashMap();// 创建map对象
map.put(1, 3.33);// 往map中添加键值对数据
map.put("AB", "Martha");
map.put(new Person("Martha", 12), 21);
map.clear();// 清空当前map对象中保存的所有键值对数据
System.out.println(map);// 输出结果为：{}
System.out.println(map.isEmpty());//输出结果为：true
--------------------------------------------------------------------------------------------------------
//调用size()方法获取map对象中键值对的个数
Map map = new HashMap();// 创建map对象
map.put(1, 3.33);// 往map中添加键值对数据
map.put("AB", "Martha");
map.put(new Person("Martha", 12), 21);
System.out.println(map.size());// 输出结果为：3
--------------------------------------------------------------------------------------------------------
//调用equals(Object obj)方法判断当前map对象与obj对象是否相等
Map map = new HashMap();// 创建map对象
map.put(1, 3.33);// 往map中添加键值对数据
map.put(2, 2.36);
map.put(3, 3.14);
Map newMap = new HashMap();
newMap.putAll(map);
System.out.println(map.equals(newMap));//输出结果为：true
```

#### Map接口中元视图操作的方法及描述

|        方法名        |                     方法描述                     |
| :------------------: | :----------------------------------------------: |
|    Set  keySet()     |     返回所有key构成的Set集合<br />==遍历①==      |
| Collection  values() | 返回所有value构成的Collection集合<br />==遍历②== |
|   Set  entrySet()    |    返回所有键值对构成的Set集合<br />==遍历③==    |

#### Map接口中元视图操作的方法及代码示例

```java
//调用keySet()方法返回map对象中所有key构成的Set集合
Map map = new HashMap();// 创建HashMap的实现类对象
map.put("AA", 97);// 添加键值对数据
map.put(45, 123);
map.put("AA", 60);// 97被60覆盖
Set keySet = map.keySet();// 返回map对象中的所有key所构成的Set集合
Iterator iterator = keySet.iterator();// 创建keySet的迭代器对象
while (iterator.hasNext()) {
  System.out.print(iterator.next() + " ");// 输出结果为：AA 45 
}
--------------------------------------------------------------------------------------------------------
//调用values()方法返回map对象中所有值构成的一个Collection集合对象
Map map = new HashMap();// 创建HashMap的实现类对象
map.put("AA", 97);// 添加键值对数据
map.put(45, 123);
map.put("BB", 60);
Collection values = map.values();//返回map中所有value构成的Collection集合对象
for(Object obj : values){
  System.out.print(obj + " ");//输出结果为：97 60 123 
}
--------------------------------------------------------------------------------------------------------
//调用entrySet()方法返回map对象中所有键值对构成的一个Set集合对象
Map map = new HashMap();// 创建HashMap的实现类对象
map.put("AA", 97);// 添加键值对数据
map.put(45, 123);
map.put("BB", 60);
Set entrySet = map.entrySet();// 返回map对象中所有键值对构成的一个Set集合对象
Iterator iterator = entrySet.iterator();// 获取迭代器对象
while (iterator.hasNext()) {
  Object obj = iterator.next();// 每一个键值对为HashMap类型
  Map.Entry entry = (Map.Entry) obj;//向下转型为Map.Entry类型
  System.out.println(entry.getKey() + "--" + entry.getValue());
  /*
		输出结果为:
		AA--97 
		BB--60 
		45--123
	*/
}
//增强for循环方式遍历
for (Object obj : entrySet) {
  Map.Entry entry = (Map.Entry) obj;
  System.out.println(entry.getKey() + "--" + entry.getValue());
}
```

### TreeMap两种添加方式的使用

> 向TreeMap中添加key-value，要求key必须由同一个类创建的对象
>
> 因为要按照key进行排序
>
> + 自然排序
> + 定制排序

```java
//自然排序，要求自定义类实现Comparable接口并指定按照哪个属性进行比较操作
TreeMap map = new TreeMap();
map.put(new Person("Martha", 21), 15000);
map.put(new Person("Martha", 23), 21000);
map.put(new Person("Martha", 11), 18000);
Set entrySet = map.entrySet();
for (Object obj : entrySet) {
  Map.Entry entry = (Map.Entry) obj;
  System.out.println(entry.getKey() + "==" + entry.getValue());
}
//定制排序
TreeMap map = new TreeMap(new Comparator() {
	@Override
  public int compare(Object o1, Object o2) {
    if (o1 instanceof Person && o2 instanceof Person) {
      Person p1 = (Person) o1;
      Person p2 = (Person) o2;
      //按照年龄属性进行排序
      return p1.compareTo(p2);
    }
    throw new RuntimeException("类型不一致");
  }
});
map.put(new Person("Martha", 21), 15000);
map.put(new Person("Martha", 23), 21000);
map.put(new Person("Martha", 11), 18000);
Set entrySet = map.entrySet();
for (Object obj : entrySet) {
  Map.Entry entry = (Map.Entry) obj;
  System.out.println(entry.getKey() + "==" + entry.getValue());
}
```

***

### Map实现类之Properties

> Properties类是Hashtable的子类，该对象用于处理属性文件
>
> 由于属性文件里的key、value都是字符串类型，所以Properties里的key和value都是字符串类型
>
> 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法

```java
//假设有一个配置文件jdbc.properties，内容如下
name=Martha
password=123456
//代码如下
Properties pro = new Properties();
FileInputStream fis = new FileInputStream("jdbc.properties");
pro.load(fis);
String name = pro.getProperty("name");
String password = pro.getProperty("password");
System.out.println("name=" + name + ",password=" + password);//name=Martha,password=123456
fis.close();
```

***

### Map相关面试题

#### HashMap的底层实现原理

##### 以JDK7为例说明

```java
HashMap map = new HashMap();// 在实例化HashMap后，在底层创建了长度为16的Entry类型的一维数组：Entry[] table
..执行过多次put..
map.put(key1,value1);
/*
	在put时，首先调用key1所在类的hashCode方法，计算key1的哈希值，此哈希值经过某种算法计算之后，得到在Entry[]数组中的索引存放位置，若此位置上没有数据，此时的键值对（entry1）则添加成功
	若此位置上存在数据，意味着此位置上存在一个或多个数据(多个数据以链表形式存在)，则需要比较key1和已存在的一个或多个数据的哈希值，若key1的哈希值与已存在数据的哈希值都不相同，此时的键值对则也添加成功
	若key1的哈希值与已存在的某一个数据的哈希值相同，则需要继续调用key1所在类的equals()方法是否返回true
	若equals()方法返回false，则key-value键值对添加成功
	若equals()方法返回true，则使用value1替换与key1相同键所对应的value值，说明put方法也具有修改功能，做了一个替换操作
	关于原有索引位置上存在数据还添加成功的情况，此时的键值对和原来的数据以链表的方式存储
	
	在不断put()添加的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空时)扩容，默认的扩容方式，扩容为原来容量的2倍，并将原有的数据复制到新扩容的Entry[]数组中
*/
```

***

##### 以JDK8为例说明

```java
HashMap map = new HashMap();// 此时底层暂未创建长度为16的数组，且底层的数组为Node[]类型而非Entry[]类型
map.put(key,value);// 首次调用put()方法时，底层才创建长度为16的数组
/*
	JDK7中底层结构只有数组 + 链表
	JDK8中底层结构为：数组 + 链表 + 红黑树
	当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组长度 > 64 时，此时索引位置上的所有数据改为使用红黑树结构存储（否则就扩容就完事儿了），可以提高查找效率，小的放在左半边，大的放在右半边
	DEFAULT_INITIAL_CAPACITY:HashMap的默认容量为16
	DEFAULT_LOAD_FACTOR:HashMap的默认加载因子0.75
	threshold:扩容的临界值 = 容量 * 加载因子16*0.75 = 12
	TREEIFY_THRESHOLD:Bucket中链表长度大于该默认值，转化为红黑树
	MIN_TREEIFY_CAPACITY:被树化时最小的hash表容量为64
*/
```

***

#### LinkedHashMap的底层实现原理

> 按照添加的先后顺序依次遍历

```java
static class Entry<K,V> extends HashMap.Node<K,V> {
  Entry<K,V> before, after;// 能够记录添加的元素的先后顺序
  Entry(int hash, K key, V value, Node<K,V> next) {
    super(hash, key, value, next);
  }
}
```

#### HashMap和Hashtable的异同点

#### CurrentHashMap与Hashtable的异同点

## Collections工具类

> Collections是一个操作List、Set、Map等集合的工具类，即Collections可以操作Collection也可以操作Map
>
> Collections中提供了一系列静态方法对集合元素进行排序、查询、修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法
>
> Collections类中提供了多个synchronizedXxx()方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题，如List list = Collections.synchronizedList(new ArrayList());，此时返回的list就是线程安全的

### Collections工具类常用方法及描述

|                          方法名                           |                       方法描述                       |
| :-------------------------------------------------------: | :--------------------------------------------------: |
|                       reverse(List)                       |                 反转List中元素的顺序                 |
|                       shuffle(List)                       |              对List集合元素进行随机排序              |
|                        sort(List)                         |   根据元素的自然顺序对指定的List集合元素按升序排序   |
|                   sort(List,Comparator)                   | 根据指定的Comparator产生的顺序对List集合元素进行排序 |
|                    swap(List,int,int)                     |      将指定List集合中的i处元素和j处元素进行交换      |
|                  Object max(Collection)                   |      根据元素的自然顺序返回给定集合中的最大元素      |
|             Object max(Collection,Comparator)             |  根据Comparator指定的顺序，返回给定集合中的最大元素  |
|                  Object min(Collection)                   |      根据元素的自然顺序返回给定集合中的最小元素      |
|             Object min(Collection,Comparator)             |  根据Comparator指定的顺序，返回给定集合中的最小元素  |
|             int frequency(Collection,Object)              |           返回指定集合中指定元素的出现次数           |
|               void copy(List dest,List src)               |              将src中的内容复制到dest中               |
| boolean replaceAll(List list,Object oldVal,Object newVal) |                 使用新值替换List对象                 |

### Collections工具类常用方法及代码示例

```java
//copy(List dest,List src)方法比较特殊，需要撑开dest的size才能进行复制操作
List list = new ArrayList();
list.add(12);
list.add(-12);
list.add(122);
List dest = Arrays.asList(new Object[list.size()]);
Collections.copy(dest,list);
System.out.println(dest);//输出结果为：{12,-12,122}
```

### Collection和Collections的区别

***

# 第十二章 泛型与File

> 对泛型的理解一定程度上可以理解为标签，可以理解为垃圾分类，不能随便置入，方便分拣
>
> 泛型的设计背景：集合容器类在设计阶段或者声明阶段不能确定这个容器到底实际存在的是什么类型的对象，所以在JDK5.0之前只能将元素类型设计为Object，JDK5.0之后使用泛型来解决。因为这个时候出了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等都是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型
>
> + Collection<E>
> + List<E>
>
> 这个<E>就是类型参数，即泛型

## 为什么要有泛型

> 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中的某个属性的类型或者某个方法的返回值及参数类型。这个类型参数将在使用时（例如继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）
>
> 从JDK1.5之后，Java引入了“参数化类型”的概念，允许我们在创建集合时再指定集合元素的类型，正如List<String>，这表明该List只能保存字符串类型的对象
>
> JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参
>
> 为什么要有泛型呢？直接使用Object不是也可以存储数据吗？
>
> + 使用泛型可以解决元素存储的安全性问题，好比商品、药品标签不会弄错
> + 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别
> + 在集合中没有使用泛型时，任何类型的数据都可以添加进集合中，相对来说，类型也就不安全了（读取出来的对象若需要强转，可能会出现类型不匹配的异常）

***

## 在集合中使用泛型

> 集合接口或集合类在JDK5.0时都修改为带泛型的结构
>
> 在实例化集合类时，可以指明具体的泛型类型
>
> 指明完之后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为实例化时指定的泛型类型（如add(E e)——add(Integer e)）
>
> 泛型的类型必须是类，不能是基本数据类型，需要使用到基本数据类型的位置，使用包装类代替
>
> 若实例化时，没有指明泛型的类型，默认为Object类型

```java
//以ArrayList为例
ArrayList<Integer> list = new ArrayList<Integer>();// 在创建ArrayList对象时指明所要存放数据的类型
list.add(12);
list.add(32);
list.add(22);
//list.add("Martha");// 编译期就会进行类型检查，保证数据的类型安全
for(Integer score : list){
  int stuScore = score;// 可以避免强转操作
}
//以HashMap为例
Map<String,Integer> map = new HashMap<String,Integer>();
map.put("学生1",39);
map.put("学生2",44);
Set<Map.Entry<String,Integer>> entry = map.entrySet();// 泛型嵌套结构
Iterator<Map.Entry<String,Integer>> iterator = entry.iterator();
while(iterator.hasNext()){
  Map.Entry<String,Integer> entry = iterator.next();
  String key = entry.getKey();
  Integer value = entry.getValue();
}
```

***

## 自定义泛型结构

### 自定义泛型类的代码体现

```java
public class Person<T>{//此时的<T>就称为Person类的泛型
  public static void main(String[] args){
    Person p = new Person();//若定义了泛型类，实例化泛型类时没有指明类的泛型，则默认此泛型类型为Object类型
    p.setPersonT(123);//可存放Integer数据
    p.setPersonT("AA");//可存放String数据，所以类型不安全，建议在实例化泛型类时指明泛型类型
    
    Person<String> p1 = new Person<String>("Martha",21,"Martha-X");//实例化泛型类时指明泛型为String类型
    p1.setPersonT("Marthas");//由于指定了泛型类型所以只能传入泛型所指定的String类型
  }
  //此时类的内部结构就可以使用类的泛型
  String name;
  int age;
  T personT;
  
  public Person(){}
  
  public Person(String name,int id,T personT){
    this.name = name;
    this.id = id;
    this.personT = personT;
  }
  
  public void setPersonT(T personT){
    this.personT = personT;
  }
  
  public T getPersonT(){
    return personT;
  }
}
```

```java
//子类继承泛型类的第一种情况
public class student extends Person<String>{//此时的Student类不再是泛型类
  public static void main(String[] args){
    Student stu = new Student();// 由于子类在继承泛型父类时指明了泛型类型，则实例化子类对象时，不再需要指明泛型
    stu.setPersonT("字符串类型");// 调用父类方法时即为String类型
  }
}
//子类继承泛型类的第二种情况
public class Student<T> extends Person<T>{//此时的Student类仍然是泛型类
  public static void main(String[] args){
    Student<Integer> stu = new Student<Integer>();// 子类实例化时指明了泛型类型
    stu.setPersonT(132);// 实例化子类对象时指明了泛型类型为Integer型，所以传入的参数数据为Integer类型
  }
}
```

### 自定义泛型方法的代码体现

> ​	在方法中出现了泛型结构，**泛型参数与类的泛型参数无关**，即为泛型方法（**泛型方法与其所属的类是不是泛型类无关**），而**不是方法当中使用了类的泛型就是泛型方法**
>
> ​	泛型方法在调用时，指明泛型参数的类型，所以泛型方法可以是静态的（**泛型参数是在调用方法时确定的**，而非实例化时确定的）

```java
public <E> List<E> arrToList(E[] arr){//public后的<E>告诉编译器其实这是个泛型方法，泛型参数为E，具体泛型类型在调用方法时指定
  ArrayList<E> list = new ArrayList<>();
  for(E e : arr){
    list.add(e);
  }
  return list;
}
public static <E> List<E> arrToList(E[] arr){
  ArrayList<E> list = new ArrayList<>();
  for(E e : arr){
    list.add(e);
  }
  return list;
}
```

### 泛型类与泛型方法的使用场景举例

```java
public class DAO<T>{//database access object数据访问对象，用于访问数据库，表的共性操作DAO
  //增
  public void add(T t){}
  //删
  public void remove(T t){}
  //改
  public void update(T t){}
  //查
  public void select(T t){}
  //查具体某一个值:如多少条记录Long、某一个员工入职时间Date等等
  public <E> E getValue(){}
}
public class CustomerDao extends DAO<Customer>{//只能操作具体某一个表的DAO
  
}
```

### 自定义泛型类或泛型接口的注意点

> 泛型类可能有多个参数，此时应将多个参数一起放进尖括号内，多个泛型参数之间逗号隔开，如<K,V,...>
>
> 泛型类的构造器为public GenericClass(){}，public GenericClass<E>(){}是错误的
>
> 实例化后，操作原来泛型位置的结构必须与实例化时指定的泛型类型一致
>
> 泛型不同的引用之间不能相互赋值
>
> + 尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是运行时只能有一个ArrayList被加载到JVM中
>
> 泛型如果不确定，将被擦除，泛型对应的类型均按照Object类型处理，但不等价于Object。经验：泛型要使用就一路都用，要不用就一路都不要用（即一个类带有泛型最好还是用上）
>
> 如果泛型结构是一个接口或抽象类，则不可以创建泛型类的对象
>
> JDK1.7，泛型的简化操作，可以使用类型推断，如：ArrayList<String> list = new ArrayList<>();
>
> 泛型的指定中不能使用基本数据类型，所以可以使用对应包装类进行替换
>
> 在类或接口中声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型，但在静态方法中不能使用类的泛型，因为只有在实例化对象时才能指定泛型，而静态结构要早于对象的创建
>
> 异常类不能声明有泛型
>
> 不能使用new E[]定义数组，但是可以E[] elements = (E[]) new Object[capacity];，可参考ArrayList中源码声明Object[] elementData，而非泛型参数类型数组
>
> 父类有泛型，子类可以选择保留泛型也可以选择自己指定泛型类型
>
> ```java
> class Father<T1,T2>{}// 父类有两个泛型参数
> ```
>
> + 子类不保留父类的泛型：按需实现
>
>   + 没有类型 擦除
>
>     ```java
>     class Son<> extends Father{}//相当于class Son exnteds Father<Object,Object>
>     class Son<T3,T4> extends Father{}//相当于class Son<T3,T4> exnteds Father<Object,Object>在父类两个泛型参数的基础上自己额外又定义了两个泛型参数
>     ```
>
>   + 指定具体类型
>
>     ```java
>     class Son extends Father<String,Integer>{}
>     class Son<T3,T4> extends Father<String,Integer>{}//指明了父类中使用的两个泛型参数，自己在父类两个泛型参数基础上又额外定义了两个泛型参数
>     ```
>
> + 子类保留父类的泛型 泛型子类
>
>   + 全部保留
>
>     ```java
>     class Son<T1,T2> extends Father<T1,T2>{}
>     class Son<T1,T2,T3,T4> extends Father<T1,T2>{}//保留父类泛型参数自己额外定义了两个泛型参数
>     ```
>
>   + 部分保留
>
>     ```java
>     class Son<T2> extends Father<Integer,T2>{}//其中一个泛型参数是确定的，另外的不确定
>     class Son<T2,T3,T4> extends Father<Integer,T2>{}//其中一个泛型参数是确定的，另外的不确定，部分保留了一个T2，自己额外定义了两个泛型参数
>     ```
>
> 结论:子类必须是"富二代，子类除了指定或保留父类的泛型，还可以增加自己的泛型

***

## 泛型在继承上的体现

> 类A是类B的父类，但是G<A>和G<B>二者不具备子父类的关系，因为是看外层G类，两个G类是并列的关系，与泛型的子父类无关
>
> 类A是类B的父类，但是A<G>和B<G>二者就是子父类的关系

```java
Object obj = null;
String str = null;
obj = str;//可以赋值，存在子父类的关系，并且也是多态的一个体现

Object[] obj = null;
String[] str = null;
obj = str;//可以赋值，存在子父类的关系，并且也是多态的一个体现

List<Object> list = null;
List<String> list2 = null;
list = list2;//不可以赋值，此时的list和list2的类型(List)不具有子父类的关系，两者是并列的结构
/*反证法
假设list = list2;可以赋值，那么二者指向同一个堆空间地址值，那么当添加Objec类型的数据则可以添加成功，也可能混入非String类型的数据，所以会出错
*/
List<String> list = null;
ArrayList<String> arrayList = null;
list = arrayList;//可以赋值，相当于List<String> list = new ArrayList<String>();
```

## 通配符的使用

> 通配符\<?>是所有泛型类的父类，类A是类B的父类，但是但是G<A>和G<B>二者没有关系，但二者的共同父类为G<?>

```java
List<?> list = null;//作为以下两个类型或其他泛型类List的通用父类
List<Object> list1 = null;
List<String> list2 = null;
list = list1;//可以赋值
list = list2;//可以赋值
//定义通配符方法
public void print(List<?> list){
  Iterator<?> iterator = list.iterator();
  while(iterator.hasNext()){
    Object obj = iterator.next();//通配符返回的类型不确定，统一使用根父类Object接收
    System.out.println(obj);
  }
}
//这时候无论是什么泛型类的list都可以使用该方法进行遍历操作
print(list1);
print(list2);
```

### 使用通配符后数据的读取和写入要求

> 使用通配符后只能写入null值，可以读取数据，返回的数据类型为根父类Object类型

```java
List<Integer> list = new ArrayList<>();
list.add(12);
list.add(23);
List<?> list2 = null;
list2 = list;//将存放Integer类型的list对象赋值给通配符list，那么希望使用通配符list2对象进行数据的读取和写入该如何？
//list2.add(12);//对于List<?>就不能向其内部添加数据了，但是唯一能加入null值，因为null值是所有类类型的默认值
list2.add(null);//是可以添加的，但是没啥意义
//对于读取操作
Object obj = list2.get(0);//允许读取元素，读取的数据类型返回值为Object，不管你?的类型是啥都可以赋值为根父类
```

### 有限制条件的通配符的使用

> <? extends A>：G<? extends A>类可以看作G<A>和G<B>的父类，其中B是A的子类
>
> <? super A>：G<? super A>类可以看作G<A>和G<B>的父类，其中B是A的父类

```java
List<? extends Person> listExtendsPerson = null;//可以赋值为Person类型或Person的子类，可以看作 ≤ Person
List<? super Person> listSuperPerson = null;//可以赋值为Person类型或Person的父类，可以看作 ≥ Person

List<Person> listPerson = null;
List<Student> listStudent = null;
List<Object> listObject = null;

listExtendsPerson = listPerson;//可以赋值
listExtendsPerson = listSutdent;//可以赋值
listExtendsPerson = listObject;//不可以赋值

listSuperPerson = listStudent;//不可以赋值
listSuperPerson = listPerson;//可以
listSuperPerson = listObject;//可以赋值
//读取数据
listExtendsPerson = listSutdent;//可以赋值，但是所读出数据的返回值类型要最大,所以可以使用Person/Object接收，
Person p = listExtendsPerson.get(0);/Object obj = listExtendsPerson.get(0);

listSuperPerson = listPerson;//可以赋值，但是所读出数据的返回值类型必须为Object
Object obj = listSuperPerson.get(0);
//写入数据
listExtendsPerson = listSutdent;
//listExtendsPerson.add(new Student());//不可以添加，因为?可能是Student的子类或间接子类，Student作为父类不能赋值给子类——(-∞,Person]
listSuperPerson = listPerson;
listSuperPerson.add(new Person());//可以添加，但不可以添加Person的某一个父类——[Person，+∞)
listSuperPerson.add(new Student());//可以添加，Person和Person的子类都能放，体现了多态形式
/*
总结：父类不能赋值给子类<? extends Person>————(-∞,Person]
		 子类可以赋值给父类（多态）<? super Person>————[Person，+∞)
*/
```

## 泛型应用举例

> 用户在设计类的时候往往会使用类的关联关系，例如，一个人中可以定义一个信息 的属性，但是一个人可能有各种各样的信息（如联系方式、基本信息等），所以此信 息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可

```java
//package com.atguigu.java2;

interface Info{		// 只有此接口的子类才是表示人的信息
}
class Contact implements Info{	// 表示联系方式
	private String address ;	// 联系地址
	private String telephone ;	// 联系方式
	private String zipcode ;	// 邮政编码
	public Contact(String address,String telephone,String zipcode){
		this.address = address;
		this.telephone = telephone;
		this.zipcode = zipcode;
	}
	public void setAddress(String address){
		this.address = address ;
	}
	public void setTelephone(String telephone){
		this.telephone = telephone ;
	}
	public void setZipcode(String zipcode){
		this.zipcode = zipcode;
	}
	public String getAddress(){
		return this.address ;
	}
	public String getTelephone(){
		return this.telephone ;
	}
	public String getZipcode(){
		return this.zipcode;
	}
	@Override
	public String toString() {
		return "Contact [address=" + address + ", telephone=" + telephone
				+ ", zipcode=" + zipcode + "]";
	}
}
class Introduction implements Info{
	private String name ;		// 姓名
	private String sex ;		// 性别
	private int age ;			// 年龄
	public Introduction(String name,String sex,int age){
		this.name = name;
		this.sex = sex;
		this.age = age;
	}
	public void setName(String name){
		this.name = name ;
	}
	public void setSex(String sex){
		this.sex = sex ;
	}
	public void setAge(int age){
		this.age = age ;
	}
	public String getName(){
		return this.name ;
	}
	public String getSex(){
		return this.sex ;
	}
	public int getAge(){
		return this.age ;
	}
	@Override
	public String toString() {
		return "Introduction [name=" + name + ", sex=" + sex + ", age=" + age
				+ "]";
	}
}
class Person<T extends Info>{
	private T info ;
	public Person(T info){		// 通过构造器设置信息属性内容
		this.info = info;
	}
	public void setInfo(T info){
		this.info = info ;
	}
	public T getInfo(){
		return info ;
	}
	@Override
	public String toString() {
		return "Person [info=" + info + "]";
	}
	
}
public class GenericPerson{
	public static void main(String args[]){
		Person<Contact> per = null ;		// 声明Person对象
		per = new Person<Contact>(new Contact("北京市","01088888888","102206")) ;
		System.out.println(per);
		
		Person<Introduction> per2 = null ;		// 声明Person对象
		per2 = new Person<Introduction>(new Introduction("李雷","男",24));
		System.out.println(per2) ;
	}
}
```



# 第十三章 IO流

## File类的使用

> java.io.File类：该类是文件和文件目录路径的抽象表示形式，与平台无关，即File类的一个对象，代表一个文件或一个文件目录（文件夹），File类声明在java.io包下
>
> File能新建、删除、重命名文件和目录，但是File不能访问文件内容本身。若需要访问文件内容则需要使用IO流
>
> 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录
>
> File对象可以作为参数传递给流的构造器
>
> 当硬盘中真实存在一个文件或者目录时，创建File对象时，File类对象的各个属性会显式赋值
>
> 当硬盘中没有真实存在的文件或者目录对应时，那么创建对象时，除了指定的目录和路径之外，其它的属性都是取成员变量的默认值

### File类的实例化

|                 构造器名                 |                          构造器描述                          |
| :--------------------------------------: | :----------------------------------------------------------: |
|      public  File(String pathname)       | 以pathname为路径创建File类对象<br />可以是绝对路径或相对路径<br />若pathname是相对路径则默认路径在系统属性user.dir中存储 |
| public  File(String parent,String child) |         以parent为父路径，child为子路径创建File对象          |
|  public  File(File parent,String child)  |         根据一个File父类对象和子文件路径创建File对象         |

> 以下所有的file对象暂时只是内存层面的对象，因为还未考虑进行操作，调用file.toString()方法时，只是将文件路径作输出操作

```java
//调用File(String pathname)以pathname为路径的构造器实例化File类对象
File file1 = new File("hello.txt");//相对于当前工程下的文件hello.txt/在IDEA中是相对于当前Module下
File file2 = new File("D:\\workspace\\JavaSenior\\day08\\hello.txt");//绝对路径，双斜杠为了避免转义字符
System.out.println(file1);//输出结果为：hello.txt
System.out.println(file2);//输出结果为：D:\\workspace\\JavaSenior\\day08\\hello.txt
--------------------------------------------------------------------------------------------------------
//调用File(String parent,String child)以parent为父路径(上一层目录)，child为子路径(子目录或文件)创建File对象
File file = new File("D:\\workspace\\JavaSenior","day08\\hello.txt");
System.out.println(file);//输出结果为：D:\workspace\JavaSenior\day08\hello.txt
--------------------------------------------------------------------------------------------------------
//调用File(File parent,String child)根据一个File父类对象的路径和子文件路径创建File对象
File fileParent = new File("D:\\workspace\\JavaSenior","day08");
File file = new File(fileParent,"hi.txt");
System.out.println(file);//输出结果为：D:\workspace\JavaSenior\day08\hi.txt
```

### 路径分隔符的使用说明

> 路径中每级目录之间用一个路径分隔符隔开
>
> 路径分隔符和系统有关
>
> + Windows和Dos系统默认使用"\\"来表示
> + UNIX和URL使用"/"来表示
>
> Java程序支持跨平台运行，因此路径分隔符要慎用
>
> 为了解决这个隐患，File类提供了一个全局常量：public static final String separator，可根据操作系统动态地提供路径分隔符

```java
//代码举例
File file = new File("D:\\Java\\hello.txt");//双斜杠为了避免转义:可替换如下
File file = new File("D:" + File.separator + "Java" + File.separator + "hello.txt");//在不同操作系统下都通用
```

### File类的常用方法及描述

|                方法名                |                           方法描述                           |
| :----------------------------------: | :----------------------------------------------------------: |
|  public  String  getAbsolutePath()   |                         获取绝对路径                         |
|      public  String  getPath()       |                           获取路径                           |
|      public  String  getName()       |                           获取名称                           |
|     public  String  getParent()      |           获取上层文件目录路径<br />若无则返回null           |
|        public  long  length()        |       获取文件长度（字节为单位）<br />不能获取目录长度       |
|     public  long  lastModified()     |             获取文件最后一次修改的时间（毫秒数）             |
|      public  String[]  list();       |         获取指定目录下所有文件或者文件目录的名称数组         |
|     public  File[]  listFiles()      |          获取指定目录下所有文件或者文件目录File数组          |
| public  boolean  renameTo(File dest) | 把文件重命名并移动到指定的文件路径<br />要想返回true，需要file1在硬盘中存在且dest不能存在 |
|    public  boolean  isDirectory()    |                      判断是否是文件目录                      |
|      public  boolean  isFile()       |                        判断是否是文件                        |
|      public  boolean  exists()       |                         判断是否存在                         |
|      public  boolean  canRead()      |                         判断是否可读                         |
|     public  boolean  canWirte()      |                         判断是否可写                         |
|     public  boolean  isHidden()      |                         判断是否隐藏                         |
|   public  boolean  createNewFile()   | 创建文件<br />若此文件存在则不创建返回false<br />==若创建的文件没有写盘符路径则默认创建在项目路径下== |
|       public  boolean  mkdir()       | 创建文件目录<br />若此文件目录存在则不创建<br />若此文件目录的上层目录不存在则不创建<br />==若创建的文件没有写盘符路径则默认创建在项目路径下== |
|      public  boolean  mkdirs()       | 创建文件目录<br />若此文件目录存在则不创建<br />若上层文件目录不存在则一并创建<br />==若创建的文件没有写盘符路径则默认创建在项目路径下== |
|      public  boolean  delete()       | 删除文件或者文件夹<br />Java中的删除不走回收站<br />==要删除的文件目录不能包含文件或文件目录== |

### File类使用的总结

+ File类中涉及到关于文件或者文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作，若需要读取或写入文件内容则必须使用IO流来完成
+ 后续File类或File类的对象常会作为参数传递到流的构造器中，指明读取或者写入的“终点”

## IO原理及流的分类

### Java IO原理概述

> I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输，如读写文件、网络通讯等
>
> Java程序中，对于数据的输入输出操作以“流（Stream）”的形式进行
>
> + 输入（Input）：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中
> + 输出（Output）：将程序（内存）中的数据输出到光盘、磁盘等存储设备中
>
> java.io包下提供了各种流的类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据

### 流的分类

+ 按照操作数据单位的不同分为
  + 字节流（8bit==1字节），主要传输非文本数据（视频、图片）
  + 字符流（16bit==2字节），主要传输文本数据（txt文本文件），不能使用字符流处理字节数据
+ 按照数据流的流向的不同分为
  + 输入流
  + 输出流
+ 按照流的角色的不同分为
  + 节点流：直接作用在文件上的流称为节点流
  + 处理流：在节点流基础之上又包了一层，外面包的这种流称为处理流，可加快传输速度

### IO流的体系结构

> + Java IO流共涉及40多个类，实际上都非常规则，都是从如下四个抽象基类派生出来的
> + 由四个基类派生出来的子类名称都是以其父类名称作为子类名的后缀

| 抽象基类 |    字节流    | 字符流 |
| :------: | :----------: | :----: |
|  输入流  | InputStream  | Reader |
|  输出流  | OutputStream | Writer |

<p align="center" style="font-weight:bolder;font-size:20px;color:#fc5531">IO流体系</p>

|    分类    | 性质               |       字节输入流        |        字节输出流        |      字符输入流       |       字符输出流       |
| :--------: | ------------------ | :---------------------: | :----------------------: | :-------------------: | :--------------------: |
|  抽象基类  | 父类               |     ==InputStream==     |     ==OutputStream==     |      ==Reader==       |       ==Writer==       |
|  访问文件  | 节点流<br />文件流 |   ==FileInputStream==   |   ==FileOutputStream==   |    ==FileReader==     |     ==FileWriter==     |
|  访问数组  | 处理流             |  ByteArrayInputStream   |  ByteArrayOutputStream   |    CharArrayReader    |    CharArrayWriter     |
|  访问管道  | 处理流             |     PipeInputStream     |     PipeOutputStream     |      PipeReader       |       PipeWriter       |
| 访问字符串 | 处理流             |                         |                          |     StringReader      |      StringWriter      |
|   缓冲流   | 处理流             | ==BufferedInputStream== | ==BufferedOutputStream== |  ==BufferedReader==   |   ==BufferedWriter==   |
|   转换流   | 处理流             |                         |                          | ==InputStreamReader== | ==OutputStreamWriter== |
|   对象流   | 处理流             |  ==ObjectInputStream==  |  ==ObjectOutputStream==  |                       |                        |
|   过滤流   | 处理流             |    FilterInputStream    |    FilterOutputStream    |     FilterReader      |      FilterWriter      |
|   打印流   | 处理流             |                         |       PrintStream        |                       |      PrintWriter       |
| 推回输入流 | 处理流             |   PushbackInputStream   |                          |    PushbackReader     |                        |
|   特殊流   | 处理流             |     DataInputStream     |     DataOutputStream     |                       |                        |

## 节点流（文件流）

> 节点流有四种：FileInputStream、FileOutputStream、FileReader、FileWriter

### FileInputStream节点字节输入流

```java
@Test
public void testFileInputStream() throws IOException {
  FileInputStream fis = null;// 初始化FileInputStream对象
  FileOutputStream fos = null;// 初始化FileOutputStream对象
  try {
    File srcFile = new File("4.jpg");// 创建File对象，指明要读取的字节文件
    fis = new FileInputStream(srcFile);// 将字节文件传入字节流中进行读取操作
    fos = new FileOutputStream(new File("Maserati.jpg"));// 创建File对象指明写出的文件并置入字节输出流中，即使不存在该文件也会自动创建
    int length;// 定义用于记录字节个数的length变量
    byte[] byteArr = new byte[1024];// 创建用于保存字节数据的字节数组
    while ((length = fis.read(byteArr)) != -1) {// 不断读取
      fos.write(byteArr, 0, length);// 不断写入
    }
    System.out.println("复制图片成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (fis != null) {// 避免空指针
      try {
        fis.close();// 关闭字节输入流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    if (fos != null) {// 避免空指针
      try {
        fos.close();// 关闭字节输出流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}
```

### FileOutputStream节点字节输出流

```java
@Test
public void testFileInputStream() throws IOException {
  FileInputStream fis = null;// 初始化FileInputStream对象
  FileOutputStream fos = null;// 初始化FileOutputStream对象
  try {
    File srcFile = new File("4.jpg");// 创建File对象，指明要读取的字节文件
    fis = new FileInputStream(srcFile);// 将字节文件传入字节流中进行读取操作
    fos = new FileOutputStream(new File("Maserati.jpg"));// 创建File对象指明写出的文件并置入字节输出流中，即使不存在该文件也会自动创建
    int length;// 定义用于记录字节个数的length变量
    byte[] byteArr = new byte[1024];// 创建用于保存字节数据的字节数组
    while ((length = fis.read(byteArr)) != -1) {// 不断读取
      fos.write(byteArr, 0, length);// 不断写入
    }
    System.out.println("复制图片成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (fis != null) {// 避免空指针
      try {
        fis.close();// 关闭字节输入流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    if (fos != null) {// 避免空指针
      try {
        fos.close();// 关闭字节输出流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}
```

### 字节流复制非文本操作

```java
@Test
public void testFileInputStream() throws IOException {
  FileInputStream fis = null;// 初始化FileInputStream对象
  FileOutputStream fos = null;// 初始化FileOutputStream对象
  try {
    File srcFile = new File("4.jpg");// 创建File对象，指明要读取的字节文件
    fis = new FileInputStream(srcFile);// 将字节文件传入字节流中进行读取操作
    fos = new FileOutputStream(new File("Maserati.jpg"));// 创建File对象指明写出的文件并置入字节输出流中，即使不存在该文件也会自动创建
    int length;// 定义用于记录字节个数的length变量
    byte[] byteArr = new byte[1024];// 创建用于保存字节数据的字节数组
    while ((length = fis.read(byteArr)) != -1) {// 不断读取
      fos.write(byteArr, 0, length);// 不断写入
    }
    System.out.println("复制图片成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (fis != null) {// 避免空指针
      try {
        fis.close();// 关闭字节输入流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    if (fos != null) {// 避免空指针
      try {
        fos.close();// 关闭字节输出流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}
```

### FileReader节点字符输入流

#### 使用read()方法读取数据

> 关于以下代码的说明：
>
> + read()方法的理解：返回读取到的一个字符。若达到文件末尾，返回-1；因为每次只读一个字符，当数据量大时，效率低
> + 异常的处理：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理可能出现的异常代码
> + 读入的文件一定要真实存在，否则会报错FileNotFoundException

```java
//IDEA示例：助理解
@Test
public void testFileReader(){
 	File file = new File("hello.txt");// 该文件在单元测试方法中是相较于当前Module的位置，若在main方法中则是当前工程
  FileReader fileReader = new FileReader(file);// 提供具体的流，将file对象作为参数传入流的构造器
  // 数据的读入
  int data = fileReader.read();// read()方法返回读入的一个字符，若达到文件末尾则返回-1，字符对应的是char型，但此处返回的是int类型，因为char型与int型可以等价交换
  while (data != -1) {// 可能不止一个字符，所以需要循环一直读取
    System.out.print((char) data);// 将每一个读取出来的字符所对应的ASCII码强转为char类型数据并输出
    data = fileReader.read();// 继续读，相当于i++，直至读到文件末尾
  }
  fileReader.close();// 注意一定要关闭流
}
//优化后
@Test
public void fileReaderTest() {
  FileReader fileReader = null;// 初始化FileReader流
  try {
    File file = new File("hello.txt");// 提供欲操作的文件（该文件在单元测试方法中是相较于当前Module的位置，若在main方法中则是当前工程）
    fileReader = new FileReader(file);// 提供具体的流，将file对象作为参数传入流的构造器
    // 数据的读入
    int data;
    while ((data = fileReader.read()) != -1) {
      System.out.print((char) data);
    }
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (fileReader != null) {// 避免出现空指针异常
      try {
        fileReader.close();// 关闭流
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```

#### 使用read(char[] cbuf)读取数据

> 对read()方法读取数据操作的升级，使用read()的重载方法read(char[] cbuf)方法读取数据
>
> 关于以下代码的说明：
>
> + read(char[] cbuf)方法的理解：返回每次读入到char型数组中的字符个数，使用length变量保存字符个数，若达到文件末尾，返回-1
> + 异常的处理：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理可能出现的异常代码
> + 读入的文件一定要真实存在，否则会报错FileNotFoundException

```java
@Test
public void method() {
  File file = new File("hello.txt");// 提供File文件对象
  FileReader fileReader = null;// 初始化FileReader对象
  try {
    fileReader = new FileReader(file);// 将File对象传入流进行读入操作
    int length;//定义一个读取数据后返回的长度变量
    char[] charArr = new char[5];//定义5个长度的char型数组用于一次性读取5个字符的数据
    while ((length = fileReader.read(charArr)) != -1) {// 每次都读入5个字符数据，按指定长度覆盖之前读入的数据
      // 如"我爱中国abc" 第一次"我爱中国a"，第二次"bc中国a"，第二次读入的数据按照读入的长度覆盖第一次读取的数据，依此类推	使用循环的方式输出数据
      //				for (int i = 0; i < length; i++) {// 读入一次循环输出一次
      //					System.out.print(charArr[i]);
      //				}
      //使用String包装数据
      String s = new String(charArr, 0, length);// 从char数组中取出数据，从头开始取，每次取length长度，就相当于以上的for循环
      System.out.print(s);// 输出结果为："我爱中国abc";实际上也是拼接在一起：我爱中国a bc
    }
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    if (fileReader != null) {// 避免空指针异常
      try {
        fileReader.close();// 关闭流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
```

### FileWriter节点字符输出流

> 从内存中写出数据到硬盘中的文件中

#### <span style="background:-webkit-linear-gradient(-70deg,#9867f0,#ed4e50);-webkit-background-clip: text;-webkit-text-fill-color: transparent;-webkit-box-decoration-break: clone;">FileWriter常用方法及描述</span>

|                      方法名                      |     方法性质     |                           方法描述                           |
| :----------------------------------------------: | :--------------: | :----------------------------------------------------------: |
|          public  FileWriter(File file)           |     构造方法     | 可对传入的File文件对象进行写出操作<br />File文件可以不存在，会自动创建 |
|   public  FileWriter(File file,boolean append)   |     构造方法     | 可对传入的File文件对象进行写出操作<br />File文件可以不存在，会自动创建<br />append为false表示写出内容将替换原有文件的内容<br />append为true表示写出的内容将在原有文件内容后进行追加 |
|         public  void  write(String str)          | 无返回值类型方法 | 将指定str字符串内容写出到文件上<br />写出的内容支持转义字符的使用 |
| public  void  write(char[] cbuf,int off,int len) | 无返回值类型方法 | 将cbuf中的数据写入到文件<br />从off索引位置开始，写入len个字符 |

#### 使用write(String str)写出数据

> 输出数据到文件的操作说明
>
> + 该文件是可以不存在的，若不存在，在输出的过程中，会自动创建此文件
> + 若文件已然存在，默认之后的写出操作将替换原有文件

```java
@Test
public void testFileWriter() throws IOException {
  File file = new File("hello1.txt");// 提供File类对象，指明要写出到的文件，写出的文件若不存在，会自动创建该文件
  FileWriter fileWriter = new FileWriter(file, true);// 提供FileWriter对象，用于数据的写出操作
  // 写出的操作
  fileWriter.write("我爱zx-10r\n");// 输出第一句话，支持转义字符\n换行
  fileWriter.write("我爱Martha");// 输出第二句话
  fileWriter.close();// 流资源的关闭
}
```

### 字符流复制文本操作

```java
@Test
public void testFileReaderWriter() {
  FileReader fr = null;// 初始化FileReader对象
  FileWriter fw = null;// 初始化FileWriter对象
  try {
    File srcFile = new File("srcFile");// 创建File对象，指明要读取的file文件，所读取的文件必须真实存在，否则异常
    File destFile = new File("destFile");// 创建File对象，指明要写入的file文件，所写入的文件可以不存在，自动创建
    fr = new FileReader(srcFile);// 将要读取的文件传入输入字符流对象
    fw = new FileWriter(destFile);// 将要写入的文件传入输出字符流对象
    // 读取并输出操作
    int length;// 用于保存读入的字符个数
    char[] srcArr = new char[5];// 用于存储读入的字符数据
    while ((length = fr.read(srcArr)) != -1) {// 不断读取
				fw.write(srcArr, 0, length);// 将每一次读入的数据写出到文件，从头开始写，写入长度为length，因为未指定FileWriter构造器append参数默认每一次的操作会替换原有文件
			}
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (fr != null) {// 避免空指针异常
      try {
        fr.close();// 关闭输入流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    if (fw != null) {// 避免空指针异常
      try {
        fw.close();// 关闭输出流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}
```

### 节点流的总结

+ 对于文本文件（.txt、.java、.c、.cpp）等，最好使用字符流处理；使用字符流处理，可以在内存层面读出到控制台展示
  + 使用字节流处理输出到控制台可能会出现乱码，以字符集（UTF-8）为例，一个中文占3个字节，若所造的byte[]数组长度刚好存储到后面不够3个字节的空间，那么一个"中"字就要被拆分读取，所以会造成乱码
  + 当然若不输出到控制台（即不在内存层面读出来），只是做一个复制操作，也是可以使用字节流的，因为底层都是使用字节存储的，将文本文件数据读取来原封不动再写出到另外一个文件中，依然不会出现乱码
+ 对于非文本文件（.jpg、.avi.、.mp3、.mp4、.doc、.ppt）等，使用字节流处理；无论如何都不能使用字符流处理非文本文件

## 处理流之缓冲流

> 缓冲流也是处理流的一种，主要作用是为了提升流的读取、写入速度，即提高读写效率（开发中常用）
>
> 处理流就是套接在已有流的基础上，即缓冲流只是在原有节点流的基础上再包了一层而已
>
> 之所以能提升效率，原因是缓冲流内部提供了缓冲区size（1024*8=8192），可以存放8192个字节，相当于8KB，缓冲流执行读入操作时，会先将数据读入缓冲区中，当缓冲区存满了会一次性将数据写出，所以效率高些；缓冲输出流BufferedOutputStream有一个flush()方法，该方法被调用时会刷新缓冲区，默认情况下，当读入的数据超出缓冲区，缓冲流会自动调用flush()方法，flush出去（即写出数据，清空缓冲区），若我们读取时显式调用flush()方法，则可以在不存满缓冲区的情况下也将数据一次性写出并刷新缓冲区（当然没有必要显式调用该方法，了解即可）

### 缓冲字节输入输出流

```java
//字节型缓冲流实现非文本文件的复制操作如下
@Test
public void testBufferedInputOuputStream() {
  FileInputStream fis = null;// 初始化字节输入流对象
  FileOutputStream fos = null;// 初始化字节输出流对象
  BufferedInputStream bis = null;// 初始化缓冲字节输入流对象
  BufferedOutputStream bos = null; // 初始化缓冲字节输出流对象
  try {
    File srcFile = new File("4.jpg");// 创建File对象，指明所要读取的字节文件
    fis = new FileInputStream(srcFile);// 创建字节输入流对象，并将要读取的srcFile文件传入字节输入流中
    fos = new FileOutputStream(new File("Maserati.jpg"));// 创建File对象&创建字节输出流对象，指明所要写入的字节文件并传入字节输入流中，若文件不存在会自动创建
    bis = new BufferedInputStream(fis);// 创建缓冲字节输入流对象，将字节输入流对象传入缓冲输入流中，提升效率
    bos = new BufferedOutputStream(fos);// 创建缓冲字节输出流对象，将字节输出流对象传入缓冲输出流中，提升效率
    // 使用缓冲字节流进行读写操作
    int length;// 用于记录所读取的字节个数
    byte[] byteArr = new byte[1024];// 用于保存所读取的字节数据
    while ((length = bis.read(byteArr)) != -1) {// 不断读取
      bos.write(byteArr, 0, length);// 不断写入
    }
    System.out.println("复制成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    // 关闭顺序为：先关闭外层处理流，后关闭内层节点流
    if (bis != null) {// 避免空指针
      try {
        bis.close();// 关闭缓冲字节输入流
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (bos != null) {//  避免空指针
      try {
        bos.close();// 关闭缓冲字节输出流
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    // 说明：关闭外层流的同时，会自动关闭外层流所包裹在内的内层流，所以可忽略不写
    //			fis.close();
    //			fos.close();
  }
}
```

### 缓冲字符输入输出流

```java
//字符型缓冲流实现文本文件的复制操作如下
@Test
public void testBufferedReaderWriter() {
  FileReader fr = null;// 初始化字符输入流对象
  FileWriter fw = null;// 初始化字符输出流对象
  BufferedReader br = null;// 初始化缓冲字符输入流对象
  BufferedWriter bw = null; // 初始化缓冲字符输出流对象
  try {
    File srcFile = new File("srcFile");// 创建File对象，指明所要读取的文本文件
    fr = new FileReader(srcFile);// 创建字符输入流对象，并将要读取的srcFile文件传入字符输入流中
    fw = new FileWriter(new File("destFile"));// 创建File对象&创建字符输出流对象，指明所要写入的字符文件并传入字符输入流中，若文件不存在会自动创建
    br = new BufferedReader(fr);// 创建缓冲字符输入流对象，将字符输入流对象传入缓冲输入流中，提升效率
    bw = new BufferedWriter(fw);// 创建缓冲字符输出流对象，将字符输出流对象传入缓冲输出流中，提升效率
    // 使用缓冲字符流进行读写操作(方式一：使用数组的方式)
    //			int length;// 用于记录所读取的字符个数
    //			char[] charArr = new char[1024];// 用于保存所读取的字符数据
    //			while ((length = br.read(charArr)) != -1) {// 不断读取
    //				bw.write(charArr, 0, length);// 不断写入
    //			}
    // 方式二：使用缓冲字符流一次读一行的方式
    String data;
    while ((data = br.readLine()) != null) {// readLine()方法一次能读一行数据，但是不包括换行符，所以当有换行的数据时要手动换行
      // 换行方式一：
      // bw.write(data + "\n");//写入所读出的一行数据
      bw.write(data);
      bw.newLine();// 换行方式二：其实也是加了个换行符
    }
    System.out.println("复制成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    // 关闭顺序为：先关闭外层处理流，后关闭内层节点流
    if (br != null) {
      try {
        br.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (bw != null) {
      try {
        bw.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    // 说明：关闭外层流的同时，会自动关闭外层流所包裹在内的内层流，所以可忽略不写
    //			fis.close();
    //			fos.close();
  }
}
```

## 处理流之转换流

> 转换流提供了在字节流和字节流之间的转换
>
> Java API提供了两个转换流，这两个流属于字符流
>
> + InputStreamReader：将InputStream转换为Reader，将一个字节的输入流转换为字符的输入流
> + OutputStreamWriter：将Writer转换为OutputStream，将一个字符的输出流转换为字节的输出流
>
> 解码：字节、字节数组——>字符数组、字符串
>
> 编码：字符串、字符数组——>字节、字节数组
>
> 字节流中的数据都是字符时，转成字符流操作更高效
>
> 很多时候我们使用转换流来处理文件乱码问题，实现编码和解码的功能
>
> 字符集

### InputStreamReader字符输入转换流

```java
// InputStreamReader的使用，实现字节的输入流到字符的输入流的转换
@Test
public void method() {
  FileInputStream fis = null;// 初始化节点字节输入流对象（节点流）
  InputStreamReader isr = null;// 初始化字符转换输入流（处理流）
  try {
    File file = new File("hello.txt");// 创建File对象，指明要读取的文件
    fis = new FileInputStream(file);// 将file对象置入字节输入流对象中
    // isr = new InputStreamReader(fis);//再将字节输入流使用转换流包装，并且使用系统默认的字符集，即eclipse中设置的字符集
    isr = new InputStreamReader(fis, "UTF-8");// 将字节输入流使用转换流包装，并且使用指定的字符集，此处指定的字符集取决于文件的保存时使用的字符集
    int length;// 定义字符的读取个数
    char[] charArr = new char[5];// 定义字符数组用于保存字符数据
    while ((length = isr.read(charArr)) != -1) {// 不断读取
      String s = new String(charArr, 0, length);// 包装每一次数据
      System.out.print(s);// 输出
    }
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (isr != null) {// 避免空指针
      try {
        isr.close();// 关闭处理流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}
```

### OutputStreamWriter字符输入转换流

```java
// OutputStreamReader的使用，实现字符的输出流到字节的输出流的转换
@Test
public void method() {
  FileOutputStream fos = null;// 初始化节点字节输出流对象（节点流）
  OutputStreamWriter osw = null;// 初始化字符转换输出流（处理流）
  try {
    File file = new File("hello.txt");// 创建File对象，指明要写出的文件，文件可以不存在，将自动创建
    fos = new FileOutputStream(file);// 将file对象置入字节输出流对象中
    // osw = new OutputStreamWriter(fos);//再将字节输出流使用转换流包装，并且使用系统默认的字符集写出，即eclipse中设置的字符集
    osw = new OutputStreamWriter(fos, "UTF-8");// 将字节输出流使用转换流包装，并且使用指定的字符集写出
    String str = "我爱玛莎";// 定义要写出的内容
    osw.write(str);// 写出到文件
    System.out.println("写出成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (osw != null) {// 避免空指针
      try {
        osw.close();// 关闭处理流
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}
```

### 转换流实现文件的读入和写出

```java
// 综合使用转换流实现文件的读入和写出
@Test
public void test() {
  FileInputStream fis = null;// 初始化字节输入流对象（节点流）
  FileOutputStream fos = null;// 初始化字节输出流对象（节点流）
  InputStreamReader isr = null;// 初始化转换输入流对象（处理流）
  OutputStreamWriter osw = null;// 初始化转换输出流对象（处理流）
  try {
    File srcFile = new File("srcFile");// 创建File对象，指明读入的文件
    File destFile = new File("destFile.txt");// 创建File对象，指明要写出到的文件
    fis = new FileInputStream(srcFile);// 将要读入的文件置入字节输入流中
    fos = new FileOutputStream(destFile);// 将要写出的文件置入字节输出流中
    isr = new InputStreamReader(fis);// 将字节输入流使用转换输入流包装
    osw = new OutputStreamWriter(fos);// 将字节输出流使用转换输出流包装
    // 读入操作
    int length;// 定义记录字符个数的变量
    char[] charArr = new char[1024];// 定义保存字符数据的数组
    while ((length = isr.read(charArr)) != -1) {
      // 写出操作
      osw.write(charArr, 0, length);
    }
    System.out.println("写出成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (isr != null) {// 避免空指针
      try {
        isr.close();// 关闭转换流
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (osw != null) {// 避免空指针
      try {
        osw.close();// 关闭转换流
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```

### 多种字符集编码的说明

<span style="background:-webkit-linear-gradient(-70deg,#9867f0,#ed4e50);-webkit-background-clip: text;-webkit-text-fill-color: transparent;-webkit-box-decoration-break: clone;">**编码表的由来**</span>

> 计算机只能识别二进制数据，早期由来是电信号，为了方便应用计算机，让他可以识别各个国家的文字，就将各个国家的文字用数字表示，并一一对应，形成一张表，这就是编码表

<span style="background:-webkit-linear-gradient(-70deg,#9867f0,#ed4e50);-webkit-background-clip: text;-webkit-text-fill-color: transparent;-webkit-box-decoration-break: clone;">**补充字符编码**</span>

> Unicode不完美，这里就有三个问题
>
> + 我们已经知道，英文字母只用一个字节表示就够了
> + 如何才能区别Unicode和ASCII，计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢
>
> + 若和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符，Unicode在很长一段时间内无法推广，直至互联网的出现
>
> 面向传输的众多UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为了传输而设计的编码，并使编码无国界，这样就可以显示全世界所有文化的字符了
>
> Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16

<p align="center" style="font-weight:bolder;font-size:20px;color:#fc5531">常见的编码表</p>

| 编码代号  |                           编码描述                           |
| :-------: | :----------------------------------------------------------: |
|   UTF-8   |       变长的编码方式<br />可用1~4个字节来表示一个字符        |
|  Unicode  | 国际标准码，融合了目前人类使用的所有字符<br />为每个字符分配唯一的字符码，所有的文字都用两个字节来表示 |
|   ASCII   |         美国标准信息交换码<br />用一个字节的7位表示          |
| ISO8859-1 |        拉丁码表（欧洲码表）<br />用一个字节的8位表示         |
|  GB2312   |           中国的中文码表，最多两个字节编码所有字符           |
|    GBK    | 中国的中文编码表升级，融合了更多的中文文字符号<br />最多两个字节编码 |

## 标准输入、输出流（了解）

> System.in和System.out分别代表了系统标准的输入和输出设备，System.in是标准的输入流，默认从键盘输入，System.out是标准的输出流，默认从控制台输出
>
> 默认的输入设备是：键盘；输出设备是：显示器
>
> System.in的类型是InputStream类型
>
> System.out的类型是PrintStream，其是OutputStream的子类、FilterOutputStream的子类
>
> 重定向：通过System类的setIn，setOut方法对默认设备进行改变，即重新指定输入和输出的流
>
> + public static void setIn(InputStream in)
> + public static void setOut(PrintStream out)

```java
//代码演示
@Test
public void test() {
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));//缓冲流包裹转换流包裹System.in即节点流
  String data;
  System.out.println("请输入数据：");
  try {
    while((data  = br.readLine()) != null) {
      if(data.equalsIgnoreCase("exit")) {
        System.out.println("程序退出！");
        break;
      }
      System.out.println(data.toUpperCase());
      System.out.println("请输入数据：");
    }
  } catch (IOException e) {
    e.printStackTrace();
  }finally {
    try {
      br.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
```

## 打印流（了解）

> 实现将基本数据类型的数据格式化为字符串输出
>
> 打印流：PrintStream和PrintWriter
>
> + 提供了一系列重载的print()和println()方法，用于多种数据类型的输出
> + PrintStream和PrintWriter的输出不会抛出IOException
> + PrintStream和PrintWriter有自动flush功能
> + PrintStream打印的所有字符都使用平台默认字符编码转换为字节，在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类
> + System.out返回的是PrintStream的实例

```java
//打印流练习
@Test
public void test2() {
  PrintStream ps = null;// 初始化打印流
  try {
    FileOutputStream fos = new FileOutputStream(new File("text.txt"));// 指定一个输出到的文件
    // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\n' 时都会刷新输出缓冲区)
    ps = new PrintStream(fos, true);// 创建打印流对象，且允许追加数据
    if (ps != null) {
      System.setOut(ps); // 把标准输出流(控制台输出)改成输出到文件
    }
    for (int i = 0; i <= 255; i++) { // 输出ASCII字符
      System.out.print((char) i);
      if (i % 50 == 0) { // 每50个数据一行
        System.out.println(); // 换行
      }
    }
  } catch (FileNotFoundException e) {
    e.printStackTrace();
  } finally {
    if (ps != null) {// 避免空指针
      ps.close();// 关闭打印流
    }
  }
}
```

## 数据流（了解）

> 数据流就是为了方便地操作Java语言的基本数据类型和String的数据，可以用于保存基本数据类型和String型数据到文件
>
> + 如年龄、姓名、性别boolean数据赋值给一个变量，但是该变量只存在于内存之中，断电就没有了，可以将这些数据持久化到一个文件中，有需要时，再读入内存中，还原回来，形成一个一个的变量
> + 所以数据流的作用就是用于读取或写出基本数据类型的变量或字符串
>
> 数据流有两个类：DataInputStream和DataOutputStream，分别套接在InputStream和OutputStream子类的流上

<p align="center" style="font-weight:bolder;font-size:20px;color:#fc5531">DataInputStream类中的方法</p>

|          方法名           | 方法描述 |
| :-----------------------: | :------: |
|     byte  readByte()      |          |
|    short  readShort()     |          |
|      int  readInt()       |          |
|     long  readLong()      |          |
|    float  readFloat()     |          |
|   double  readDouble()    |          |
|  boolean  readBoolean()   |          |
|     char  readChar()      |          |
|     String  readUTF()     |          |
| void  readFully(byte[] b) | 字节数组 |

<p align="center" style="font-weight:bolder;font-size:20px;color:#fc5531">DataOutputStream类中的方法</p>

|           方法名           | 方法描述 |
| :------------------------: | :------: |
|     byte  writeByte()      |          |
|    short  writeShort()     |          |
|      int  writeInt()       |          |
|     long  writeLong()      |          |
|    float  writeFloat()     |          |
|   double  writeDouble()    |          |
|  boolean  writeBoolean()   |          |
|     char  writeChar()      |          |
|     String  writeUTF()     |          |
| void  writeFully(byte[] b) |          |

```java
// 将内存中的字符串、基本数据类型的变量写出到文件中
@Test
public void test() {
  DataOutputStream dos = null;// 初始化数据输出流对象
  try {
    dos = new DataOutputStream(new FileOutputStream("data.txt"));
    dos.writeUTF("Martha");// 写出代表姓名的String型数据到文件中
    dos.flush();// 显式地写出到文件中
    dos.writeInt(21);// 写出代表年龄的int型数据
    dos.flush();
    dos.writeBoolean(true);// 是不是个男性
    dos.flush();
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    try {
      dos.close();// 关闭数据流
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
```

```java
// 将文件中的字符串、基本数据类型的变量读入到内存中
@Test
public void test() {
  DataInputStream dis = null;// 初始化数据输入流对象
  try {
    dis = new DataInputStream(new FileInputStream("data.txt"));
    // 读入的时候要注意，按写出的顺序依次读入，否则会报异常
    String name = dis.readUTF();// 读入代表姓名的String型数据到文件中
    System.out.println(name);// Martha
    int age = dis.readInt();// 读入代表年龄的int型数据
    System.out.println(age);// 21
    boolean isMale = dis.readBoolean();// 读入性别布尔值
    System.out.println(isMale);// true
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    try {
      dis.close();// 关闭数据流
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
```

## 对象流（掌握）

> ObjectInputStream和ObjectOutputStream
>
> 用于存储和读取基本数据类型数据或对象的处理流，它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来
>
> 序列化：用ObejctOutputStream类保存基本类型数据或对象的机制
>
> 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制
>
> ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量
>
> 对象的序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点，当其它程序获取了这种二进制流，就可以恢复成原来的Java对象
>
> 序列化的好处在于可将任何实现了Serializable接口的对象转换为字节数据，使其在保存和传输时可被还原
>
> 序列化是RMI（Remote Method Invoke-远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础，因此序列化机制是JavaEE平台的基础
>
> 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一，否则会抛异常---NotSerializableException异常
>
> + Serializable
> + Externalizable

### 对字符串进行序列化与反序列化操作

```java
// 序列化的过程：将内存中的Java对象保存到磁盘中或通过网络传输出去
@Test
public void test() {
  ObjectOutputStream oos = null;// 初始化对象输出流的对象
  try {
    oos = new ObjectOutputStream(new FileOutputStream("Object.dat"));// 文件格式指定为dat，不是直接点击查看的，可以使用反序列化的过程来查看
    oos.writeObject(new String("我爱zx-10r"));
    oos.flush();// 刷新操作
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (oos != null) {
      try {
        oos.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
// 反序列化的过程
@Test
public void test() {
  ObjectInputStream ois = null;// 初始化对象输入流对象
  try {
    ois = new ObjectInputStream(new FileInputStream("Object.dat"));// 指定要反序列化的文件
    Object obj = ois.readObject();
    String str = (String) obj;
    System.out.println(str);
  } catch (IOException e) {
    e.printStackTrace();
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    if (ois != null) {
      try {
        ois.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```

### 对自定义类进行序列化与反序列化操作

```java
//自定义类
/*
	①自定义类需要实现Serializable接口，该接口只是一个标识，凡是实现该接口的都标识为该类是一个可序列化的
	②需要该类提供一个全局常量，即指定一个序列版本号，该标识只是为了识别是某一个类型的数据，方便读入的时候分别，因为一个文件可以写入多个不同对象，所以每个对象之间只能使用serialVersionUID用于区分
*/
public class Person implements Serializable {
	private static final long serialVersionUID = 1L;

	private String name;
	private int age;

	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}

}
```

```java
//自定义类序列化的过程
@Test
public void testPerson() {
  ObjectOutputStream oos = null;
  try {
    oos = new ObjectOutputStream(new FileOutputStream("Person.dat"));
    oos.writeObject(new Person("Martha", 21));
    oos.flush();
    System.out.println("保存Person对象成功");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (oos != null) {
      try {
        oos.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}

//自定义类的反序列化的过程
@Test
public void testPerson2() {
  ObjectInputStream ois = null;
  try {
    ois = new ObjectInputStream(new FileInputStream("Person.dat"));
    Object obj = (Person) ois.readObject();
    System.out.println(obj);
  } catch (IOException e) {
    e.printStackTrace();
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    if (ois != null) {
      try {
        ois.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```

### serialVersionUID的理解

> 凡是实现了Serializable接口的类都有一个表示序列化版本标识符的静态变量
>
> + private static final long serialVersionUID;
> + serialVersionUID用来表明类的不同版本之间的兼容性。简而言之其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容
> + 如果类没有显式定义这个全局常量，它的值时Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化，所以建议显式声明
>
> 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本的一致性，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常（InvalidCastException）

### 自定义类可序列化的其它要求

> 除了当前自定义类需要实现Serializable接口之外，还必须保证其内部的所有属性也必须是可序列化的（即其内部的属性也要实现Serializable接口），默认情况下，基本数据类型是可序列化的，所以就以防其它自定义类充当属性
>
> 补充：对象流不能序列化被static和transient修饰的属性，若被和两个关键字修饰，则说明该属性不想被序列化，反序列化出来只是默认值

## 随机存取文件流（了解）

> RandomAccessFile类声明在java.io包下，但直接继承于java.lang.Object类，并且它实现了DataInput、DataOutput两个接口，即意味着这个类可以进行读写操作（可以使用该类实现多线程断点下载功能）
>
> RandomAccessFile类支持随机访问的方式，程序可以直接跳到文件的任意地方来读、写文件
>
> + 支持只访问文件的部分内容
> + 可以向已存在的文件后追加内容
>
> RandomAccessFile对象包含一个记录指针，用以标识当前读写处的位置
>
> RandomAccessFile类对象可以自由移动记录指针：
>
> + long getFilePointer()：获取文件记录指针的当前位置
> + void seek(long pos)：将文件及记录指针定位到pos位置
>
> 构造器：
>
> + public RandomAccessFile(File file,String mode)
> + public RandomAccessFile(String name,String mode)
>
> 创建RandomAccessFile类实例需要指定一个mode参数，该参数是指定RandomAccessFile的访问模式
>
> + r：以只读方式打开（不会创建文件，而是会取读取一个已存在的文件，若读取的文件不存在则报异常）
> + rw：打开以便读取和写入（文件不存在则会创建文件，若存在则不会创建）
> + rwd：打开以便读取和写入；同步文件内容的更新
> + rws：打开以便读取和写入；同步文件内容和元数据更新
>
> 如果RandomAccessFile作为输出流时，写出到的文件若不存在则自动创建，文件若存在则默认从头覆盖文件内容（开头是abc，则会被写出内容xyz覆盖）

```java
//实现图片的复制效果
@Test
public void test() {
  RandomAccessFile raf1 = null;
  RandomAccessFile raf2 = null;
  try {
    raf1 = new RandomAccessFile("Maserati.jpg", "r");
    raf2 = new RandomAccessFile("Maserati.jpg", "rw");
    byte[] byteArr = new byte[1024];
    int length;
    while ((length = raf1.read(byteArr)) != -1) {
      raf2.write(byteArr, 0, length);
    }
    System.out.println("图片复制成功");
  } catch (IOException e) {

  } finally {
    if (raf1 != null) {
      try {
        raf1.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (raf2 != null) {
      try {
        raf2.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```

```java
// 实现在abcdefg的abc后插入xyz
@Test
public void test2() throws IOException {
  File file = new File("test.txt");
  System.out.println(file.length());
  if (!file.exists()) {
    file.createNewFile();
  }
  RandomAccessFile raf = new RandomAccessFile(file, "rw");
  raf.seek(3);// 将指针调整到下标为3的位置进行插入
  StringBuilder str = new StringBuilder((int) file.length());// 指定一个长度，避免底层扩容，因为所要保存的指针3位置后的数据内容不可能超出文件总的长度
  byte[] arr = new byte[1024];// 创建字节数组保存字节数据
  int len;// 指定长度用于记录字节个数
  while ((len = raf.read(arr)) != -1) {
    str.append(new String(arr, 0, len));// 使用String进行字节数组到字符串的转换，再拼接到StringBuilder中
  }
  raf.seek(3);// 上面循环读取数据后需要重新调整指针
  raf.write(("xyz" + str).getBytes());// 将保存后的数据和要插入的数据拼接一起写入，呈现出插入效果
  raf.close();// 关闭流
}
```

## NIO.2中的Path、Paths、Files类的使用（了解）

### Java NIO概述

> Java NIO（NEW IO）是从Java1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的（IO是面向流的）、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作
>
> Java API中提供了两套NIO，一套是针对标准输入输出NIO，一套就是网络编程NIO
>
> + java.nio.channel.Channel
>   + FileChannel：处理本地文件
>   + SocketChannel：TCP网络编程的客户端的Channel
>   + ServerSocketChannel：TCP网络编程的服务器端的Channel：
>   + DatagramChannel：UDP网络编程中发送端和接收端的Channel
>
> 随着JDK7的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以置于我们称他们为NIO.2，因为NIO提供的一些功能已经成为文件处理中越来越重要的部分

### NIO.2中Path、Paths和Files核心API

> 早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高，而且，大多数方法在出错时仅返回失败，并不会提供异常信息
>
> NIO.2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在
>
> + 在以前IO操作都是这样写的：
>   + import java.io.File
>   + File file = new File("index.html");
> + 但在Java7中，我们可以这样写
>   + import java.nio.file.Path;
>   + import java.nio.file.Paths;
>   + Path path = Paths.get("index.html");
>
> + 同时，NIO.2在java.nio.file包下还提供Files、Paths工具类，Files包含了大量的静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法
> + Paths类提供的静态get()方法用于获取Path对象：
>   + static Path get(String first,String...more)：用于将多个字符串串联成路径
>   + static Path get(URI uri)：返回指定uri所对应的Path路径

### Path类常用方法

|              方法名              |                         方法描述                         |
| :------------------------------: | :------------------------------------------------------: |
|        String  toString()        |            返回调用 Path 对象的字符串表示形式            |
| boolean  startsWith(String path) |                 判断是否以 path 路径开始                 |
|  boolean endsWith(String path)   |                 判断是否以 path 路径结束                 |
|      boolean  isAbsolute()       |                    判断是否是绝对路径                    |
|        Path  getParent()         | 返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 |
|         Path  getRoot()          |                返回调用 Path 对象的根路径                |
|       Path  getFileName()        |             返回与调用 Path 对象关联的文件名             |
|       int  getNameCount()        |              返回Path 根目录后面元素的数量               |
|      Path  getName(int idx)      |             返回指定索引位置 idx 的路径名称              |
|    ==Path  toAbsolutePath()==    |            ==作为绝对路径返回调用 Path 对象==            |
|      Path  resolve(Path p)       |       合并两个路径，返回合并后的路径对应的Path对象       |
|        ==File  toFile()==        |               ==将Path转化为File类的对象==               |

```java
/**
 * 1. jdk 7.0 时，引入了 Path、Paths、Files三个类。
 * 2.此三个类声明在：java.nio.file包下。
 * 3.Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关
 * <p>
 * 4.如何实例化Path:使用Paths.
 * static Path get(String first, String … more) : 用于将多个字符串串连成路径
 * static Path get(URI uri): 返回指定uri对应的Path路径
 *
 * @author shkstart
 * @create 2019 下午 2:44
 */
public class PathTest {

    //如何使用Paths实例化Path
    @Test
    public void test1() {
        Path path1 = Paths.get("d:\\nio\\hello.txt");//new File(String filepath)

        Path path2 = Paths.get("d:\\", "nio\\hello.txt");//new File(String parent,String filename);

        System.out.println(path1);
        System.out.println(path2);

        Path path3 = Paths.get("d:\\", "nio");
        System.out.println(path3);
    }

    //Path中的常用方法
    @Test
    public void test2() {
        Path path1 = Paths.get("d:\\", "nio\\nio1\\nio2\\hello.txt");
        Path path2 = Paths.get("hello.txt");

//		String toString() ： 返回调用 Path 对象的字符串表示形式
        System.out.println(path1);

//		boolean startsWith(String path) : 判断是否以 path 路径开始
        System.out.println(path1.startsWith("d:\\nio"));
//		boolean endsWith(String path) : 判断是否以 path 路径结束
        System.out.println(path1.endsWith("hello.txt"));
//		boolean isAbsolute() : 判断是否是绝对路径
        System.out.println(path1.isAbsolute() + "~");
        System.out.println(path2.isAbsolute() + "~");
//		Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径
        System.out.println(path1.getParent());
        System.out.println(path2.getParent());
//		Path getRoot() ：返回调用 Path 对象的根路径
        System.out.println(path1.getRoot());
        System.out.println(path2.getRoot());
//		Path getFileName() : 返回与调用 Path 对象关联的文件名
        System.out.println(path1.getFileName() + "~");
        System.out.println(path2.getFileName() + "~");
//		int getNameCount() : 返回Path 根目录后面元素的数量
//		Path getName(int idx) : 返回指定索引位置 idx 的路径名称
        for (int i = 0; i < path1.getNameCount(); i++) {
            System.out.println(path1.getName(i) + "*****");
        }

//		Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象
        System.out.println(path1.toAbsolutePath());
        System.out.println(path2.toAbsolutePath());
//		Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象
        Path path3 = Paths.get("d:\\", "nio");
        Path path4 = Paths.get("nioo\\hi.txt");
        path3 = path3.resolve(path4);
        System.out.println(path3);

//		File toFile(): 将Path转化为File类的对象
        File file = path1.toFile();//Path--->File的转换

        Path newPath = file.toPath();//File--->Path的转换

    }


}
```



### Files类常用方法

|                            方法名                            |                方法描述                 |
| :----------------------------------------------------------: | :-------------------------------------: |
|       Path copy(Path src, Path dest, CopyOption … how)       |               文件的复制                |
|    Path createDirectory(Path path, FileAttribute … attr)     |              创建一个目录               |
|       Path createFile(Path path, FileAttribute … arr)        |              创建一个文件               |
|                    void delete(Path path)                    | 删除一个文件/目录，如果不存在，执行报错 |
|                void deleteIfExists(Path path)                |  Path对应的文件/目录如果存在，执行删除  |
|        Path move(Path src, Path dest, CopyOption…how)        |         将 src 移动到 dest 位置         |
|                     long size(Path path)                     |        返回 path 指定文件的大小         |
|         boolean exists(Path path, LinkOption … opts)         |            判断文件是否存在             |
|      boolean isDirectory(Path path, LinkOption … opts)       |             判断是否是目录              |
|     boolean isRegularFile(Path path, LinkOption … opts)      |             判断是否是文件              |
|                 boolean isHidden(Path path)                  |           判断是否是隐藏文件            |
|                boolean isReadable(Path path)                 |            判断文件是否可写             |
|                boolean isWritable(Path path）                |            判断文件是否可写             |
|       boolean notExists(Path path, LinkOption … opts)        |           判断文件是否不存在            |
| SeekableByteChannel newByteChannel(Path path, OpenOption…how) | 获取与指定文件的连 接，how 指定打开方式 |
|        DirectoryStream newDirectoryStream(Path path)         |          打开 path 指定的目录           |
|    InputStream newInputStream(Path path, OpenOption…how)     |          获取 InputStream 对象          |
|   OutputStream newOutputStream(Path path, OpenOption…how)    |         获取 OutputStream 对象          |

```java
/**
 * Files工具类的使用：操作文件或目录的工具类
 * @author shkstart
 * @create 2019 下午 2:44
 */
public class FilesTest {

	@Test
	public void test1() throws IOException{
		Path path1 = Paths.get("d:\\nio", "hello.txt");
		Path path2 = Paths.get("atguigu.txt");
		
//		Path copy(Path src, Path dest, CopyOption … how) : 文件的复制
		//要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。
//		Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);
		
//		Path createDirectory(Path path, FileAttribute<?> … attr) : 创建一个目录
		//要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。
		Path path3 = Paths.get("d:\\nio\\nio1");
//		Files.createDirectory(path3);
		
//		Path createFile(Path path, FileAttribute<?> … arr) : 创建一个文件
		//要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。
		Path path4 = Paths.get("d:\\nio\\hi.txt");
//		Files.createFile(path4);
		
//		void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错
//		Files.delete(path4);
		
//		void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束
		Files.deleteIfExists(path3);
		
//		Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置
		//要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。
//		Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);
		
//		long size(Path path) : 返回 path 指定文件的大小
		long size = Files.size(path2);
		System.out.println(size);

	}

	@Test
	public void test2() throws IOException{
		Path path1 = Paths.get("d:\\nio", "hello.txt");
		Path path2 = Paths.get("atguigu.txt");
//		boolean exists(Path path, LinkOption … opts) : 判断文件是否存在
		System.out.println(Files.exists(path2, LinkOption.NOFOLLOW_LINKS));

//		boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录
		//不要求此path对应的物理文件存在。
		System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS));

//		boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件

//		boolean isHidden(Path path) : 判断是否是隐藏文件
		//要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。
//		System.out.println(Files.isHidden(path1));

//		boolean isReadable(Path path) : 判断文件是否可读
		System.out.println(Files.isReadable(path1));
//		boolean isWritable(Path path) : 判断文件是否可写
		System.out.println(Files.isWritable(path1));
//		boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在
		System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS));
	}

	/**
	 * StandardOpenOption.READ:表示对应的Channel是可读的。
	 * StandardOpenOption.WRITE：表示对应的Channel是可写的。
	 * StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略
	 * StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常
	 *
	 * @author shkstart 邮箱：shkstart@126.com
	 * @throws IOException
	 */
	@Test
	public void test3() throws IOException{
		Path path1 = Paths.get("d:\\nio", "hello.txt");

//		InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象
		InputStream inputStream = Files.newInputStream(path1, StandardOpenOption.READ);

//		OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象
		OutputStream outputStream = Files.newOutputStream(path1, StandardOpenOption.WRITE,StandardOpenOption.CREATE);


//		SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。
		SeekableByteChannel channel = Files.newByteChannel(path1, StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);

//		DirectoryStream<Path>  newDirectoryStream(Path path) : 打开 path 指定的目录
		Path path2 = Paths.get("e:\\teach");
		DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path2);
		Iterator<Path> iterator = directoryStream.iterator();
		while(iterator.hasNext()){
			System.out.println(iterator.next());
		}


	}
}
```



## 使用第三方jar包实现数据读写操作（commons-io）

# 第十四章 网络编程

## 网络编程概述

> Java是Internet上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序
>
> Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在Java的本机安装系统里，由JVM进行控制。并且Java实现了一个跨平台的网络库。程序员面对的是一个统一的网络编程环境

<p align="center" style="font-weight:bolder;font-size:20px;color:#fc5531">网络基础</p>

> <span style="font-weight:bolder;color:#fc5531">计算机网络</span>
>
> 把分布在不同地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源
>
> <span style="font-weight:bolder;color:#fc5531">网络编程的目的</span>
>
> 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯
>
> <span style="font-weight:bolder;color:#fc5531">网络编程中的两个主要问题</span>
>
> + 如何准确地定位网络上一台或多台主机；定位主机上的特定的应用
>
> + 找到主机后如何可靠高效地进行数据传输 

## ==网络通信要素概述==

<p align="center" style="font-weight:bolder;font-size:20px;color:#fc5531">如何实现网络中的主机互相通信</p>

> <span style="font-weight:bolder;color:#fc5531">通信双方地址</span>
>
> + IP：每一个IP地址定位了每一台主机
> + 端口号：用于区分一个主机上不同的应用程序
>
> <span style="font-weight:bolder;color:#fc5531">一定的规则</span>（网络通信协议，有两套参考模型）
>
> + OSI 参考模型：模型过于理想化，未能在因特网上进行广泛推广
> + TCP/IP参考模型（或TCP/IP协议）：事实上的国际标准
>

## ==通信要素1：IP和端口号==

### ==IP的理解和InetAddress类的实例化==

#### ==IP地址（InetAddress）==

> + 唯一地标识Internet上的计算机（即通信实体）
> + IP地址分类方式1：IPV4和IPV6
>   + IPV4：4个字节组成（32位），4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1
>   + IPV6：16个字节组成（128位），写成8个无符号整数，每个整数使用4个十六进制位表示，数之间用冒号隔开，如3ffe:3201:1401:1280:c8ff:fe4d:db39:1984
> + IP地址分类方式2：公网地址（万维网使用）和私有地址（局域网使用）；
>   + 192.168.开头的是私有地址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用
> + IP地址特点：不易记忆
> + 域名：www.baidu.comde等等，比IP地址形象且便于记忆
> + 本地回环地址（hostAddress）：127.0.0.1，对应着localhost——主机名（hostName）：localhost
> 

#### ==InetAddress类的实例化==

> 实例化InetAddress类的两个方法
>
> + getByName(String host)
>
> + getLocalHost()
>
> InetAddress类的两个常用方法
>
> + getHostName()
> + getHostAddress()

```java
public static void main(String[] args) {
  try {
    InetAddress net = InetAddress.getByName("192.168.10.14");
    System.out.println(net);// /192.168.10.14
    InetAddress net2 = InetAddress.getByName("www.atguigu.com");
    System.out.println(net2);// www.atguigu.com/58.216.118.229
    InetAddress net3 = InetAddress.getLocalHost();// 获取本机地址信息
    System.out.println(net3);// Martha-Win10专业工作站/192.168.37.1
    System.out.println(net3.getHostName());// Martha-Win10专业工作站
    System.out.println(net3.getHostAddress());// 192.168.37.1
  } catch (UnknownHostException e) {
    e.printStackTrace();
  }
}
```

### ==端口号的理解==

> 端口号是表示正在计算机上运行的进程（即程序）
>
> + 要求不同的进程有不同的端口号
> + 被规定为一个16位的整数0-65535
> + 端口分类
>   + 公认端口：0~1023；被预先定义的服务通信占用（如HTTP占用端口80，FTP占用端口21，Telnet占用端口23）
>   + 注册端口：1024~49151；分配给用户进程或应用程序（如Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）
> + 动态/私有端口：49152~65535
>
> 端口号与IP地址的组合得出一个网络套接字：Socket

## 通信要素2：网络协议

> <span style="font-weight:bolder;color:#fc5531">网络通信协议</span>
>
> 计算机网络中实现通信必须要有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准
>
> <span style="font-weight:bolder;color:#fc5531">问题：网络协议太复杂</span>
>
> 计算机网络通信涉及的内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制、流量控制、路由控制，如何实现如此复杂的网络协议呢？
>
> <span style="font-weight:bolder;color:#fc5531">通信协议分层的思想</span>
>
> 在制定协议时，把复杂成分分解成一些简单的成分，再将他们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展

### ==TCP/IP协议簇==

> 传输层协议中有两个非常重要的协议：
>
> + 传输控制协议TCP（Transmission Control Protocol）
> + 用户数据报协议UDP（User Datagram Protocol）
>
> TCP/IP以其两个主要协议：传输控制协议（TCP）和网络互联协议（IP）而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议
>
> IP（Internet Protocol）协议是网络层的主要协议，支持网间互联的数据通信
>
> TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即
>
> + 物理链路层
> + IP层
> + 传输层
> + 应用层

### TCP和UDP网络通信协议的对比

#### TCP协议

> 使用TCP协议之前，需要建立TCP连接，形成传输数据通道
>
> 传输前，采用三次握手方式，点对点通信，是可靠的
>
> TCP协议进行通信的两个应用进程：客户端、服务端
>
> 在连接中可进行大数据量的传输
>
> 传输完毕后，需要自己释放已建立的连接，效率较UDP低

#### UDP协议

> 将数据、源、目的封装成数据包，不需要建立连接
>
> 每个数据包的大小限制在64KB内
>
> 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的
>
> 可以广播发送
>
> 发送数据结束时无需释放资源，开销小，速度快

## TCP网络编程

```java
// 服务端
@Test
public void server() {
  InputStream is = null;// 初始化字节输入流
  ByteArrayOutputStream baos = null;// 初始化字节数组流
  ServerSocket serverSocket = null;// 初始化服务端socket
  Socket socket = null;// 初始化Socket
  try {
    serverSocket = new ServerSocket(8899);// 创建服务端对象
    socket = serverSocket.accept();// 服务端接收客户端发来的Socket数据
    is = socket.getInputStream();// 创建字节输入流
    baos = new ByteArrayOutputStream();// 创建字节数组输出流，避免中文使用字节读入乱码
    byte[] buffer = new byte[5];
    int len;
    while ((len = is.read(buffer)) != -1) {
      baos.write(buffer, 0, len);
    }
    System.out.println(baos.toString());// 查看数据
    System.out.println("收到了来自" + socket.getInetAddress().getHostName() + "的数据");
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (is != null) {
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (baos != null) {
      try {
        baos.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (socket != null) {
      try {
        socket.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (serverSocket != null) {
      try {
        serverSocket.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

}

// 客户端
@Test
public void client() {
  Socket socket = null;// 初始化socket
  OutputStream os = null;// 初始化输出流
  try {
    InetAddress net = InetAddress.getLocalHost();
    socket = new Socket(net, 8899);
    os = socket.getOutputStream();
    os.write("您好，我是客户端".getBytes());
  } catch (UnknownHostException e) {
    e.printStackTrace();
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (os != null) {
      try {
        os.close();// 关闭流资源
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (socket != null) {
      try {
        socket.close();// 关闭socket资源
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```

## UDP网络编程

> 类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序
>
> UDP数据包通过数据包套接字DatagramSocket发送和接收，系统不保证UDP数据包一定能够安全送达目的地，也不确认什么时候可以送达
>
> DatagramPacket对象封装了UDP数据包，在数据包中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
>
> UDP协议中的每个数据包都给出了完整的地址信息，因此无需建立发送方和接收方的连接。如同发快递一样

```java
// 发送端
@Test
public void sender() {
  DatagramSocket socket = null;// 初始化socket
  DatagramPacket packet = null;// 初始化数据包packet
  try {
    socket = new DatagramSocket();// 创建socket
    String str = "我是将要发送的数据";// 定义要发送的数据
    byte[] data = str.getBytes();// 将数据转为字节并存入字节数组中
    InetAddress net = InetAddress.getLocalHost();// 获取本机地址信息
    packet = new DatagramPacket(data, 0, data.length, net, 8989);// 将数据及要发送的数据内容长度发送至net主机所对应的8989端口程序上
    socket.send(packet);// 发送数据包
  } catch (SocketException e) {
    e.printStackTrace();
  } catch (UnknownHostException e) {
    e.printStackTrace();
  } catch (IOException e) {
    e.printStackTrace();
  }
  socket.close();
}

// 接收端
@Test
public void receiver() {
  DatagramSocket socket = null;// 初始化socket
  DatagramPacket packet = null;// 初始化数据包packet
  try {
    socket = new DatagramSocket(8989);// 指定接收端端口并创建socket
    byte[] buffer = new byte[100];// 定义字节数组用于存储发过来的数据
    packet = new DatagramPacket(buffer, 0, buffer.length);// 创建数据包并将数据存入
    socket.receive(packet);// 接收数据
    System.out.println(new String(packet.getData(), 0, packet.getLength()));
  } catch (SocketException e) {
    e.printStackTrace();
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (socket != null) {
      socket.close();
    }
  }
}
```

## URL编程

> URL（Uniform Resource Locator）：统一资源定位符，对应着互联网上某一个资源的地址
>
> 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源
>
> 通过URL我们可以访问Internet上的各种网络资源，比如最常见的www,ftp站点，浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源
>
> URL的基本结构由5部分组成
>
> <传输协议>://<主机名>:<端口号>/<文件名>#片段名？参数列表
>
> 例如：

```java
@Test
public void test() throws MalformedURLException {
  URL url = new URL("https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=%E5%9B%BE%E7%89%87&hs=0&pn=6&spn=0&di=78430&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&ie=utf-8&oe=utf-8&cl=2&lm=-1&cs=1242053365%2C2901037121&os=1864971347%2C3023457541&simid=4274972645%2C834422103&adpicid=0&lpn=0&ln=30&fr=ala&fm=&sme=&cg=&bdtype=0&oriquery=%E5%9B%BE%E7%89%87&objurl=https%3A%2F%2Fgimg2.baidu.com%2Fimage_search%2Fsrc%3Dhttp%3A%2F%2Fimage.wangchao.net.cn%2Ffengjing%2F1327205317794.jpg%26refer%3Dhttp%3A%2F%2Fimage.wangchao.net.cn%26app%3D2002%26size%3Df9999%2C10000%26q%3Da80%26n%3D0%26g%3D0n%26fmt%3Djpeg%3Fsec%3D1631178798%26t%3D39654a7a14dbc4ec5f7c02d6f1cba3ee&fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bowg2viw5_z%26e3Bgjp_z%26e3BvgAzdH3Fujg23tg2AzdH3F1jpwts_9clna_m_z%26e3Bip4s&gsm=7&islist=&querylist=");
  System.out.println(url.getProtocol());//获取该URL的协议名
  System.out.println(url.getHost());//获取该URL的主机名
  System.out.println(url.getPort());//获取该URL的端口号
  System.out.println(url.getPath());//获取该URL的文件路径
  System.out.println(url.getFile());//获取该URL的文件名
  System.out.println(url.getQuery());//获取该URL的查询名
}
```

```java
//使用URL定位互联网上的一张图片并下载到本地
@Test
public void test() {
  HttpURLConnection conn = null;
  InputStream is = null;
  FileOutputStream fos = null;
  try {
    URL url = new URL( "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.wangchao.net.cn%2Ffengjing%2F1327205317794.jpg&refer=http%3A%2F%2Fimage.wangchao.net.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1631179539&t=de438952f00a85fc0382fb1b9fe2ee5f");
    conn = (HttpURLConnection) url.openConnection();
    conn.connect();
    is = conn.getInputStream();
    fos = new FileOutputStream("image.jpg");
    byte[] arr = new byte[1024];
    int len;
    while ((len = is.read(arr)) != -1) {
      fos.write(arr, 0, len);
    }
  } catch (MalformedURLException e) {
    e.printStackTrace();
  } catch (FileNotFoundException e) {
    e.printStackTrace();
  } catch (IOException e) {
    e.printStackTrace();
  } finally {
    if (is != null) {
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (fos != null) {
      try {
        fos.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    if (conn != null) {
      conn.disconnect();// 断开连接
    }
  }
}
```

***

# 第十五章 反射

## Java反射机制概述

> 在使用反射之前，通过new创建类实例对象，由于封装性的影响，不可以通过对象调用类内部私有的结构
>
> 在使用反射之后，除了可以调用非私有结构，也可以调用一个类的私有结构的（如私有属性、私有方法 、私有构造器）

### Java Reflection

> + Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 
>
> + 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象地称为反射

### 补充:动态语言vs静态语言

> 动态语言：是一类运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其它结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构（主要动态语言：Object-C、C#、JavaScript、PHP、等）
>
> 静态语言：与动态语言相对应的，运行时结构不可变得语言就是静态语言。（Java、C、C++）
>
> Java不是动态语言，但Java可以称之为”准动态语言“。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程更加灵活

### Java反射机制研究及应用

> Java反射机制提供的功能如下：
>
> + 在运行时判断任意一个对象所属的类
> + 在运行时构造任意一个类的对象
> + 在运行时判断任意一个类所具有的成员变量和方法
> + 在运行时获取泛型信息
> + 在运行时调用任意一个对象的成员变量和方法
> + 在运行时处理注解
> + 生成动态代理

#### 通过直接new对象的方式或反射的方式都可以调用公共的结构，开发中使用哪个？

> 建议：使用直接new创建对象的方式，需要体现动态性时则考虑使用反射的方式
>
> 动态性理解：如服务器在运行中，浏览器端发送请求如/login表示要登陆，那么服务器端就动态创建Login类的对象并执行相关结构，若浏览器端发送请求如/register表示要注册，则服务器端动态创建Register类的对象并执行相关结构，因为服务器无法提前预知究竟要创建哪种指定结构，所以这就体现了反射的动态性，此时就建议使用反射来创建相关对象（Servlet中可以体现）

#### 如何看待反射和封装性两个技术

> 二者是不矛盾的，封装性将类的私有结构私有化意味着建议不要在外部去调用私有结构，没多大意义，反射是能调用私有结构，人家封装好了，不建议调用，你要非要调用也可以调用，但是也许公共方法更好，逻辑啥的都写好了，你非要调用私有结构也行，只是可能不如公共结构更好，所以封装性是建议去调用公共的结构，私有的结构就不要调用了；反射是能不能调用的问题，所以不矛盾

### 反射相关的主要API与代码演示

> java.lang.Class：代表一个类
>
> java.lang.reflect.Method：代表类的方法
>
> java.lang.reflect.Field：代表类的成员变量
>
> java.lang.reflect.Constructor：代表类的构造器
>
> ...

```java
//以如下Person类示例
public class Person {
	private String name;// 私有name属性
	int age;// 公有age属性

	// 公有构造器
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	// 私有构造器
	private Person(String name) {
		this.name = name;
	}

	// 公有方法
	public void show() {
		System.out.println("我是一个人");
	}

	// 私有方法
	private String showNation(String nation) {
		System.out.println("我是一个" + nation + "人");
		return nation;
	}
  // 重写toString()方法
  @Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
}
```

```java
// 在使用反射之前，对于new出来的Person对象，由于封装性的影响，不能直接调用私有结构
@Test
public void method() {
  Person person = new Person("Martha", 21);
  person.age = 11;
  person.show();
  System.out.println(person);//Person [name=Martha, age=11]
}

// 在使用反射之后，可以访问到Person类内部的所有结构，包括私有结构
@Test
public void method() throws Exception {
  Class<Person> clazz = Person.class;// 将运行时类对象赋给Class类
  // 通过clazz反射调用Person类公共构造器以创建Person类的对象，括号中指明构造器的参数类型
  Constructor constructorPublic = clazz.getConstructor(String.class, int.class);
  Object obj = constructorPublic.newInstance("Martha", 21);// 通过调用newInstance创建实例对象
  Person person = (Person) obj;// 对obj向下转型为Person类型
  System.out.println(person);// 输出结果为：Person [name=Martha, age=21]

  // 通过反射调用私有结构（属性、方法、构造器）
  // 通过反射调用Person类私有属性name，括号中指明属性名称
  Field name = clazz.getDeclaredField("name");// 获取私有属性name
  name.setAccessible(true);// 设置name的状态可见
  name.set(person, "Beth");// 将Person类name的值的Martha改为Beth
  System.out.println(person);// 输出结果为：Person [name=Beth, age=21]

  // 通过反射调用Person类的私有方法，括号中指明方法名、方法参数类型
  Method showNation = clazz.getDeclaredMethod("showNation", String.class);
  showNation.setAccessible(true);// 设置showNation方法的状态可见
  Object result = showNation.invoke(person, "中国");// 调用Person类的该方法并传入实际参数，可接收返回值
  System.out.println(result);// 中国

  // 通过clazz对象获取Person类的带参构造器，括号内指明该构造器参数类型
  Constructor constructorPrivate = clazz.getDeclaredConstructor(String.class);
  constructorPrivate.setAccessible(true);// 设置该私有构造器为可见状态
  person = (Person) constructorPrivate.newInstance("Martha&Beth");// 通过该私有构造器设置Person类的name属性
  System.out.println(person);// Person [name=Martha&Beth, age=0]，新创建了一个Person对象，所以age为0
}
```

## 理解Class类并获取Class实例

### Class类的加载过程

> 程序经过javac.exe编译命令之后，会生成一个或多个字节码文件（以.class结尾），接着我们使用java.exe命令对某个字节码文件进行解释运行（相当于将某个字节码文件加载到内存中），解释运行的过程就称为类的加载，加载到内存中的类就称为运行时类，此运行时类就作为Class类的一个实例；换句话说，Class类的实例就对应着一个运行时类

### 获取Class实例的四种方式

```java
// 获取Class类实例的方式（前三种方式需要掌握，在不同的情况下可能会采取不同的方式获取Class类的实例）
@Test
public void test() throws Exception {
  // 方式一：通过调用运行时类的属性.class赋给Class类，完成Class类的实例化
  Class<Person> clazz1 = Person.class;
  System.out.println(clazz1);// class reflect.Person 输出的就是Person类本身

  // 方式二：通过运行时类的对象完成Class类的实例化
  Person person = new Person();// 创建Person对象
  Class clazz2 = person.getClass();// 通过person对象获取内存中的Person类对象得到Class类实例
  System.out.println(clazz2);// class reflect.Person 输出的就是Person类本身

  // 方式三：通过调用Class类的静态方法forName(String classPath)完成Class类的实例化（开发中最常用！！！）
  Class clazz3 = Class.forName("reflect.Person");// 将一个类的全类名作为参数传入
  System.out.println(clazz3);// class reflect.Person 输出的就是Person类本身

  // 方式四：使用类的加载器ClassLoader获取Class类的实例
  ClassLoader classLoader = Person.class.getClassLoader();//通过类对象获取类加载器返回一个类加载器
  Class clazz4 = classLoader.loadClass("reflect.Person");//类加载器加载一个类的全类名得到Class对象
  System.out.println(clazz4);// class reflect.Person 输出的就是Person类本身

  System.out.println(clazz1 == clazz2 && clazz2 == clazz3 && clazz3 == clazz4);// 输出结果为：true
  // 虽然获取的方式不一样，但是获取的都是内存中同一个运行时类，加载到内存中的运行时类会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类
}
```

### Class实例对应结构的说明

> 除了类以外，有没有其他的结构可以作为Class类的实例呢？如下结构的都可以作为Class对象的实例：
>
> + class类对象（外部类、成员内部类/静态内部类、局部内部类、匿名内部类）
> + interface接口
> + []数组
> + enum枚举
> + annotation注解@interface
> + primitive type：基本数据类型
> + void

```java
//Class实例可以有哪些结构的说明（代码示例）
@Test
public void test1() {
  Class c1 = Object.class;// 类
  Class c2 = Comparable.class;// 接口
  Class c3 = String[].class;// 对象数组
  Class c4 = int[][].class;// 基本数据类型二维数组
  Class c5 = ElementType.class;// 枚举
  Class c6 = Override.class;// 注解
  Class c7 = int.class;// 基本数据类型
  Class c8 = void.class;// void类型
  Class c9 = Class.class;// Class类本身

  int[] a = new int[10];
  int[] b = new int[100];
  Class class1 = a.getClass();
  Class class2 = b.getClass();
  System.out.println(class1);// class [I：int类型的一维数组
  System.out.println(class2);// class [I：int类型的一维数组
  System.out.println(class1 == class2);// true：只要两个或以上的数组的元素类型与数组的维度相同，那么就是同一个Class
}
```

***

## 类的加载过程与ClassLoader的理解

### 了解：类的加载过程

> 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化
>
> + 类的加载（Load）：将类的class文件读入内存，并为之创建一个java.lang.Class对象，此过程由类的加载器完成
> + 类的链接（Link）：将类的二进制数据合并到JRE中
> + 类的初始化（Initialize）：JVM负责对类进行初始化
>
> 详细过程如下：
>
> + 加载：将class字节码文件内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与
> + 链接：将Java类的二进制代码合并带JVM的运行状态之中的过程
>   + 验证：确保加载的类信息复合JVM规范，例如：以cafe开头，没有安全方面的问题
>   + 准备：正式为类变量（声明为static的变量）分配内存并设置类变量的默认初始值的阶段，这些内存都将在方法区中进行分配
>   + 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程
> + 初始化
>   + 执行类构造器<clinit>()方法的过程。类类构造器<clinit>()方法是由编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的（类构造器是构造类信息的，不是构造该类对象的构造器）
>   + 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
>   + 虚拟机会保证一个类的类构造器<clinit>()方法在多线程环境中被正确加锁和同步

### ClassLoader的理解

> 类加载器的作用：类的加载器是用来把类(class)装载进内存的
>
> + 类加载器的作用：将class字节码文件内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Class对象，作为方法区中类数据的访问入口
> + 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持（缓存）一段时间。不过JVM垃圾回收机制也可以回收这些Class对象（运行时类）
>
> JVM规范定义了如下类型的类的加载器：
>
> + Bootstap ClassLoader——引导类加载器：用C++编写，是JVM自带的类加载器，负责Java平台核心类库的加载，无法直接获取
> + Extension ClassLoader——扩展类加载器：负责jre/lib/ext目录下的jar包或指定目录下jar包的加载
> + System ClassLoader——系统类加载器：负责java -classpath或所指目录下的类与jar包的加载工作，是最常用的加载器
> + 自定义类加载器

```java
//关于类加载器的代码演示
@Test
public void test() {
  // 对于自定义类，是使用系统类加载器进行加载
  ClassLoader systemClassLoader = ClassLoaderTest.class.getClassLoader();// 使用本类获取系统类加载器
  System.out.println(systemClassLoader);// sun.misc.Launcher$AppClassLoader@6d06d69c：App的就是系统类加载器
  // 调用系统类加载器的getParent()方法可以获取到扩展类加载器
  ClassLoader extensionClassLoader = systemClassLoader.getParent();
  System.out.println(extensionClassLoader);// sun.misc.Launcher$ExtClassLoader@2957fcb0：上一层就是扩展类加载器
  // 通过扩展类加载器的getParent()方法是无法获取到引导类加载器的，引导类加载器主要负责加载Java核心类库，无法加载自定义类
  ClassLoader bootstapClassLoader = extensionClassLoader.getParent();
  System.out.println(bootstapClassLoader);// null：输出null不代表没有，而是不能直接获取该引导类加载器

  ClassLoader bootstapClassLoader2 = String.class.getClassLoader();// 通过核心类库获取引导类加载器
  System.out.println(bootstapClassLoader2);// 结果还是null，确实没办法获取到
}
```

### 使用ClassLoader加载配置文件

```java
@Test
public void test1() throws Exception {
  Properties pro = new Properties();// 创建Properties对象

  // 读取配置文件方式一：使用FileInputStream
  // 创建字节流对象读取配置文件
  // FileInputStream fis = new FileInputStream("src/jdbc1.properties");//字节流默认读取的文件在当前工程目录下
  // pro.load(fis);后续步骤相同

  // 读取配置文件方式二：使用ClassLoader
  ClassLoader loader = this.getClass().getClassLoader();// 获取类加载器
  InputStream is = loader.getResourceAsStream("jdbc1.properties");// 类加载器默认加载文件的位置在当前工程的src目录下
  pro.load(is);// 将字节流对象加载到properties对象中
  String username = pro.getProperty("user");// 获取name属性
  String password = pro.getProperty("password");// 获取password属性
  System.out.println("user=" + username + ",password=" + password);// 输出
  is.close();// 关闭流
}
```

## 创建运行时类的对象

```java
//通过反射创建对应的运行时类的对象
@Test
public void method() throws InstantiationException, IllegalAccessException {
  Class<Person> clazz = Person.class;// 实例化Class
  /*
		 * 	调用newInstance()方法创建对应的运行时类Person类的对象，内部调用了此运行时类的空参构造器
		 *	要求newInstance()方法正常地运行并创建运行时类的对象，要求如下：
		 *		①运行时类必须提供空参的构造器
		 *		②空参构造器的访问权限得够；通常为public最好
		 *	在JavaBean中要求提供一个public的空参构造器
		 *		①便于通过反射创建运行时类的对象
		 *		②便于子类继承此运行时类时默认调用super()时，保证父类有此空参构造器
		 */
  Person instance = clazz.newInstance();//通过反射调用Person类对象空参构造器创建Person对象（开发中最常用）
}
```

## 获取运行时类的完整结构

### 获取运行时类的属性结构

```java
@Test
public void test() {
  Class clazz = Person.class;
  // 获取Person类所有属性结构
  Field[] fields = clazz.getFields();// 获取当前运行时类及其所有父类中所有声明为public访问权限的属性
  for (Field f : fields) {
    System.out.println(f);
  }
  System.out.println();
  Field[] declaredFields = clazz.getDeclaredFields();// 获取运行时类本身声明的所有属性（与权限修饰符无关且不包含父类中声明的属性）
  for (Field f : declaredFields) {
    System.out.println(f);
  }
}

@Test
public void test1() {
  Class clazz = Person.class;
  Field[] declaredFields = clazz.getDeclaredFields();// 获取运行时类本身声明的所有属性（与权限修饰符无关且不包含父类中声明的属性）
  // 获取每一个属性的权限修饰符、数据类型、变量名
  for (Field f : declaredFields) {
    // 获取权限修饰符
    int modifiers = f.getModifiers();//每一个权限修饰符都有一个int值与之对应
    System.out.print(Modifier.toString(modifiers) + "\t");//使用toString转化int值为具体修饰符
    // 获取数据类型
    Class type = f.getType();
    System.out.print(type.getSimpleName() + "\t");
    // 获取变量名
    System.out.print(f.getName());
    // 获取该属性对应的值
    System.out.println(f.get(null));
  }
}
```

### 获取运行时类的方法结构

```java
@Test
public void test() {
  Class clazz = Person.class;
  Method[] methods = clazz.getMethods();// 获取当前运行时类及其所有父类中所有声明为public访问权限的方法
  for (Method m : methods) {
    System.out.println(m);
  }
  System.out.println();
  Method[] declaredMethods = clazz.getDeclaredMethods();// 获取运行时类本身声明的所有方法（与权限修饰符无关且不包含父类中声明的方法）
  for (Method m : declaredMethods) {
    System.out.println(m);
  }
}

@Test
public void test1() {
  Class clazz = Person.class;
  Method[] declaredMethods = clazz.getDeclaredMethods();// 获取运行时类本身声明的所有方法（与权限修饰符无关且不包含父类中声明的方法）
  // 获取每一个方法的注解、权限修饰符、返回值类型、方法名、(参数类型1 形参名称1,...)、抛出的异常、
  for (Method m : declaredMethods) {
    // 获取方法的注解（要求注解的生命周期为RUNTIME才能获取到，因为运行时类只能检测到运行时期的注解）
    Annotation[] annotations = m.getAnnotations();
    for (Annotation a : annotations) {
      System.out.println(a);
    }
    // 获取方法的权限修饰符
    int modifiers = m.getModifiers();
    System.out.print(Modifier.toString(modifiers) + "\t");

    // 获取方法的返回值类型
    Class returnType = m.getReturnType();
    System.out.print(returnType.getSimpleName() + "\t");

    // 获取方法的方法名
    String name = m.getName();
    System.out.print(name + "\t");
    System.out.print("(");
    // 获取方法的形参
    Class[] parameterTypes = m.getParameterTypes();
    for (Class c : parameterTypes) {
      System.out.print(c.getSimpleName() + "\t");
    }
    Parameter[] parameters = m.getParameters();
    for (Parameter p : parameters) {
      System.out.print(p.getName());
    }
    System.out.print(")  ");

    // 获取方法抛出的异常
    Class[] exceptionTypes = m.getExceptionTypes();
    if (exceptionTypes.length != 0) {
      System.out.print("throws ");
      for (int i = 0; i < exceptionTypes.length; i++) {
        if (i == exceptionTypes.length - 1) {
          System.out.print(exceptionTypes[i].getSimpleName());
          break;
        }
        System.out.print(exceptionTypes[i].getSimpleName() + ",");
      }
    }
    System.out.println();
  }
}
```

### 获取运行时类的构造器

```java
@Test
public void test() {
  Class clazz = Person.class;
  Constructor[] constructors = clazz.getConstructors();// 获取当前运行时类中所有声明为public访问权限的构造器
  for (Constructor c : constructors) {
    System.out.println(c);
  }
  System.out.println();
  Constructor[] declaredConstructors = clazz.getDeclaredConstructors();// 获取运行时类本身声明的所有构造器（与权限修饰符无关）
  for (Constructor c: declaredConstructors) {
    System.out.println(c);
  }
}
//其它构造器结构的获取与方法类似
```

### 获取运行时类的父类及父类的泛型

```java
@Test
public void test3() {
  Class clazz = Person.class;
  Class superClass = clazz.getSuperclass();// 获取运行时类Person的直接父类
  System.out.println(superClass);// class reflect.Creature

  Type genericSuperclass = clazz.getGenericSuperclass();// 获取运行时类Person的直接父类的泛型
  System.out.println(genericSuperclass.getTypeName());// reflect.Creature<java.lang.String>
  
  ParameterizedType paramType = (ParameterizedType)genericSuperclass;//对泛型进行强转为参数类型
  Type[] type = paramType.getActualTypeArguments();//通过参数类型获取实际上的泛型类型
  System.out.println(type[0].getTypeName());//获取泛型全类名：java.lang.String
}
```

### 获取运行时类实现的接口、所在的包、注解等

```java
@Test
public void test4() {
  Class clazz = Person.class;
  Class[] interfaces = clazz.getInterfaces();// 获取运行时类本身所实现的接口
  for (Class c : interfaces) {
    System.out.println(c);
    /*
			 * interface java.lang.Comparable 
			 * interface reflect.MyInterface
			 */
  }
  // 获取运行时类的直接父类所实现的接口
  Class[] interfacesSuper = clazz.getSuperclass().getInterfaces();
  for (Class c : interfacesSuper) {
    System.out.println(c);// interface java.io.Serializable
  }

  // 获取运行时类所在的包
  Package pack = clazz.getPackage();
  System.out.println(pack);// package reflect

  // 获取运行时类的注解
  Annotation[] annotations = clazz.getAnnotations();
  for (Annotation a : annotations) {
    System.out.println(a);// @reflect.MyAnnotation(value=hi)
  }
}
```

## 调用运行时类指定的结构

### 调用运行时类指定的属性

```java
// 开发中常用的获取运行时类指定的属性
@Test
public void test65() throws Exception {
  Class<Person> clazz = Person.class;
  Person person = clazz.newInstance();// 创建运行时类的对象
  Field name = clazz.getDeclaredField("name");// 获取Person类中声明为private的name属性
  name.setAccessible(true);// 设置私有状态的name属性为可见状态，保证当前属性是可访问的
  name.set(person, "Martha");// 设置当前name属性的值；参数一：指明所设置该属性的对象；参数二：指明要设置该属性的属性值
  String personName = (String) name.get(person);// 获取当前name属性的值；参数：获取该对象中当前属性的值
  System.out.println(personName);// Martha
}
// 开发中不常用的获取运行时类指定的属性
@Test
public void test5() throws Exception {
  Class<Person> clazz = Person.class;
  Person person = clazz.newInstance();// 创建运行时类的对象
  Field id = clazz.getField("id");// 获取Person类中声明为public的id属性，该方法要求运行时类中的属性声明为public的，所以通常不采用此方法
  id.set(person, 1001);// 设置当前id属性的值；参数一：指明所设置该属性的对象；参数二：指明要设置该属性的属性值
  int personId = (int) id.get(person);// 获取当前id属性的值；参数：获取该对象中当前属性的值
  System.out.println(personId);// 1001
}
```

### 调用运行时类指定的方法

```java
// 获取运行时类指定的方法
@Test
public void test5() throws Exception {
  Class<Person> clazz = Person.class;
  Person person = clazz.newInstance();// 创建运行时类的对象
  Method declaredMethod = clazz.getDeclaredMethod("show", String.class);// 获取指定的某个方法；参数一：指明所要获取的方法名称；参数二：指明该方法形参列表的的形参类型；因为可能有多个重载方法
  declaredMethod.setAccessible(true);// 设置该方法是可访问的
  String nation = (String) declaredMethod.invoke(person, "中国");// 调用该运行时类对象的该方法；参数一：指明该方法的调用者对象；参数二：指明方法需要传入的实际参数
  System.out.println(nation);// 中国：invoke()方法的返回值即为运行时类中所调用方法show()的返回值类型，可进行向下强转

  // 通过反射调用运行时类中指定的静态方法（静态属性的调用相同）
  Method showDescMethod = clazz.getDeclaredMethod("showDesc");
  showDescMethod.setAccessible(true);
  Object returnVal = showDescMethod.invoke(Person.class);// 静态方法由当前类对象进行调用，便于理解则可以直接传入Person.class，当然也可以如下传入null值，因为clazz本身就是运行时类，填null值本身也不影响
  // Object returnVal = showDescMethod.invoke(null); invoke是通过showDescMethod调用的，showDescMethod是通过clazz得到的，本身clazz就知道静态结构是啥，所以对于静态方法的调用该参数可填可不填，但是必须要求填第一个参数，故也可以填null值，没影响
  System.out.println(returnVal);// null：如果调用的运行时类中的方法没有返回值，则invoke()方法返回null
}
```

### 调用运行时类指定的构造器

```java
// 获取运行时类指定的构造器
@Test
public void test() throws Exception {
  Class<Person> clazz = Person.class;
  // 获取指定的构造器；参数：指明该构造器参数列表的参数类型
  Constructor<Person> declaredConstructor = clazz.getDeclaredConstructor(String.class);
  declaredConstructor.setAccessible(true);// 设置该构造器可访问
  Person person = declaredConstructor.newInstance("Martha");// 通过该构造器创建Person对象
  System.out.println(person);// Person [name=Martha, age=0]
}
```

## 反射的应用：动态代理

> 代理设计模式的原理：使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上（之前代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以只通过一个代理类完成全部的代理功能）
>
> 动态代理：是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象（哪个被代理类被加载到内存中，则创建该被代理类所对应的代理类）
>
> 动态代理的使用场合
>
> + 调试
> + 远程方法调用
>
> 动态代理相比静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一地处理众多的方法（即一个代理类就可以搞定所有的被代理类）

```java
/*
 *	动态代理
 *	要想实现动态代理需要解决的问题？
 *		①如何根据加载到内存中的被代理类动态创建一个代理类及其对象
 *		②当通过代理类对象调用方法时，如何动态地调用到被代理类中同名的方法
 */
public class DynamicProxyTest {
	public static void main(String[] args) {
    //所创建的代理类实现的接口与被代理类相同所以返回的对象为该接口，默认为Object，向下强转即可得到
		Human proxyInstance = (Human) ProxyFactory.getProxyInstance(new SuperMan());// 创建代理类的对象
		//当通过代理类对象调用方法时会自动地调用被代理类中同名的方法
		System.out.println(proxyInstance.getBelief());
		proxyInstance.eat("麻辣烫");
		
		ClothFactory c = (ClothFactory)ProxyFactory.getProxyInstance(new NikeClothFactory());
		c.produceCloth();
		
	}
}
//人类
interface Human {
	String getBelief();// 获取信仰

	void eat(String food);// 吃啥东西
}

//被代理类
class SuperMan implements Human {

	@Override
	public String getBelief() {
		return "超人信仰上帝";
	}

	@Override
	public void eat(String food) {
		System.out.println("超人吃" + food);
	}

}

//生产代理类的工厂
class ProxyFactory {
	// 调用此静态方法返回一个代理类的对象；解决问题①
	public static Object getProxyInstance(Object obj) {// obj：其实就是被代理类的对象；Object返回值类型就是代理类对象类型
		MyInvocationHandler handler = new MyInvocationHandler();
		handler.bind(obj);// 绑定被代理类对象，以通过反射调用具体被被代理类方法
		return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);// 创建代理类对象；参数一：我们这个对象是哪个加载器加载的（被代理类是哪个加载器加载的，代理类的加载器的提供就与之一样）；参数二：提供被代理类所实现的接口，因为代理类也需要实现被代理类所实现的接口；参数三：代理类会去handler中调用invoke方法，即代理类调用被代理类中的方法，解决问题②
	}
}
//需要提供一个类实现InvocationHandler中的invoke方法，并使之与代理类绑定，代理类才会真正调用到被代理类中同名的方法
class MyInvocationHandler implements InvocationHandler {
	private Object obj;// 需要使用被代理类的对象进行赋值

	public void bind(Object obj) {// 初始化obj
		this.obj = obj;
	}

	// 当我们通过代理类的对象，调用方法a时，就会自动地调用如下方法：invoke()
	// 将被代理类要执行的方法a的功能声明在invoke()方法中
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		Object returnVal = method.invoke(obj, args);// method即为代理类对象调用的方法，，此方法也就作为了被代理类对象要调用的方法
		return returnVal;// 被代理类对象所调用方法的返回值就作为当前类中invoke()方法的返回值
	}

}
```

### 动态代理与AOP（Aspect Orient Programming）

> 前面介绍的Porxy和InvocationHandler，很难看出这种动态代理的优势，下面介绍一种更实用的动态代理机制
>
> 面向切面编程：在基础时大概了解下，以以下代码为例

```java
class HumanUtil{
  public void method1(){
    System.out.println("===========通用方法一===========");
  }
  public void method2(){
    System.out.println("===========通用方法二===========");
  }
}
class MyInvocationHandler implements InvocationHandler {
	private Object obj;// 需要使用被代理类的对象进行赋值

	public void bind(Object obj) {// 初始化obj
		this.obj = obj;
	}

	// 当我们通过代理类的对象，调用方法a时，就会自动地调用如下方法：invoke()
	// 将被代理类要执行的方法a的功能声明在invoke()方法中
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    HumanUtil human = new HumanUtil();
    human.method1();//通用方法一
		Object returnVal = method.invoke(obj, args);// 此处的方法是会变化的，而不是"硬代码"，写死的，这就是面向切面编程
    human.method2();//通用方法二
		return returnVal;
	}
/*执行后输出结果，通用方法不变，但是中间所调用的方法瞬息万变（有个大概了解即可，框架再提）
===========通用方法一===========
超人吃麻辣烫
===========通用方法二===========
===========通用方法一===========
耐克工厂生产运动服
===========通用方法二===========
*/
}
```

# 第十六章 Java8其它新特性

> Java8新特性简介：Java8又称为（JDK1.8）是Java语言开发的一个主要版本
>
> Java8是Oracle公司于2014年3月份发布，可以看作是自Java5以来最具革命性的版本，Java8为Java语言、编译器、类库、开发工具与JVM带来了大量的新特性
>
> + 速度更快
> + 代码更少（增加了新语法Lambda表达式）
> + 强大的Stream API
> + 便于并行（并行流与串行流）
> + 最大化减少空指针异常：Optional
> + Nashorn引擎，允许在JVM上运行JS应用

## 并行流与串行流

> 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相较于串行的流，并行的流可以很大程度上提高程序的执行效率
>
> Java8中将并行进行了优化，我们可以很容易地对数据进行 并行操作。Stream API可以声明性地通过parallel()与sequential()在并行流和顺序流之间进行切换

## Lambda表达式

### 为什么要使用Lambda表达式

> Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升

### Lambda表达式代码示例

```java
//去同存异的思想
@Test
public void test() {
  Runnable r1 = new Runnable() {

    @Override
    public void run() {
      System.out.println("我是匿名实现类的非匿名对象的一般写法");
    }

  };
  r1.run();// 我是匿名实现类的非匿名对象的一般写法‘
  
  Runnable r2 = () -> System.out.println("我是匿名实现类的非匿名对象的Lambda写法");
  r2.run();// 我是匿名实现类的非匿名对象的Lambda写法
}

@Test
public void test2() {
  // 一般写法
  Comparator<Integer> com1 = new Comparator<Integer>() {

    @Override
    public int compare(Integer o1, Integer o2) {
      return Integer.compare(o1, o2);
    }

  };
  System.out.println(com1.compare(1, 2));// -1
  // Lambda写法
  Comparator<Integer> com2 = (o1, o2) -> Integer.compare(o1, o2);
  System.out.println(com2.compare(1, 2));// -1
  // 方法引用
  Comparator<Integer> com3 = Integer::compare;
  System.out.println(com3.compare(1, 2));// -1
}
```

### Lambda表达式语法使用的6种情况

> 举例：(o1, o2) -> Integer.compare(o1, o2);
>
> 格式：->：称为lambda操作符或者箭头操作符
>
> + 操作符的左边称为lambda的形参列表（其实就是接口中的抽象方法的形参列表）
> + 操作符的右边称为lambda体（其实就是重写的抽象方法的方法体）

```java
@Test
public void test3() {
  // 语法格式一：对于无参数无返回值的情况
  Runnable r1 = new Runnable() {
    @Override
    public void run() {
      System.out.println("对于无参数无返回值的情况的一般写法");
    }
  };
  r1.run();// 对于无参数无返回值的情况的一般写法
  Runnable r2 = () -> System.out.println("对于无参数无返回值情况的Lambda写法");
  r2.run();// 对于无参数无返回值情况的Lambda写法

  // 语法格式二：对于有一个参数无返回值的情况
  Consumer<String> con = new Consumer<String>() {
    @Override
    public void accept(String t) {
      System.out.println(t);
    }
  };
  con.accept("有一个参数无返回值的情况的一般写法");// 有一个参数无返回值的情况的一般写法
  // 使用Lambda表达式
  Consumer<String> con2 = (String t) -> {
    System.out.println(t);
  };
  con2.accept("有一个参数无返回值的情况的Lambda写法");// 有一个参数无返回值的情况的Lambda写法
  // 语法格式三：数据类型可以省略，因为编译器可以推断出来，称为"类型推断"
  // 泛型决定了方法参数类型，且方法只有一个需要重写，所以相对于语法格式二省略了参数数据类型
  Consumer<String> con3 = (t) -> {
    System.out.println(t);
  };
  // 类型推断举例说明
  ArrayList<String> list = new ArrayList<String>();
  ArrayList<String> list2 = new ArrayList<>();// 类型推断
  int[] arr = new int[] { 1, 2, 3 };
  int[] arr2 = { 1, 2, 3 };// 类型推断

  // 语法格式四：Lambda操作符左边若只需要一个参数时，括号可以省略，相较于语法格式三省略了括号
  Consumer<String> con4 = t -> {
    System.out.println(t);
  };
  // 语法格式五：Lambda需要两个或以上的参数，多条执行语句，并且有返回值的情况
  Comparator<Integer> com = new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
      System.out.println(o1);
      System.out.println(o2);
      return o1.compareTo(o2);
    }
  };
  System.out.println(com.compare(1, 2));// -1
  // 两个参数，不能省略括号
  Comparator<Integer> com2 = (o1, o2) -> {
    // 多条执行语句
    System.out.println(o1);
    System.out.println(o2);
    return o1.compareTo(o2);// 有返回值
  };
  System.out.println(com2.compare(1, 2));// -1

  // 语法格式6：当Lambda体只有一条语句时，return与大括号若有，则都可以省略不写
  Comparator<Integer> com4 = new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o1.compareTo(o2);// 只有一条执行语句
    }
  };
  System.out.println(com4.compare(1, 2));// -1
  // return关键字和大括号都省略
  Comparator<Integer> com5 = (o1, o2) -> o1.compareTo(o2);
  System.out.println(com5.compare(1, 2));// -1
}
```

### Lambda表达式语法的总结

> + 【左边】Lambda形参列表的参数类型可以省略（类型推断）；若形参列表只有一个参数，则括号'()'可以省略不写
> + 【右边】Lambda体应该使用{}进行包裹；若Lambda体若只有一条执行语句（可能是return语句）就可以省略{}与return关键字
> + Lambda表达式的本质就是作为函数式接口的实例，依赖于函数式接口而存在，失去了接口就没有意义，当然此接口需要是函数式接口，即接口中有且只有一个抽象方法才适用Lambda表达式

## 函数式(Functional)接口

### 函数式接口的描述

> + 如果一个接口中只声明了一个抽象方法，则此接口也称为函数式接口
> + 可以通过Lambda表达式来创建该接口的对象（若Lambda表达式抛出一个受检异常（即：非运行时异常），那么该异常需要在目标接口的抽象方法上进行声明）
> + 我们可以在一个接口上使用@FunctionalInterface注解，检查它是否是一个函数式接口。同时javadoc也会包含一条声明，说明该接口是一个函数式接口
> + 在java.util.function包下定义了Java8的丰富的函数式接口

### 如何理解函数式接口

> + Java从诞生日起就一直倡导”一切皆对象“，在Java里面面向对象编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即Java不但可以支持面向对象（OOP）也可以支持面向函数编程（OOF）
>
> + 在函数式编程语言当中，函数被当作一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但在Java8中有所不同。在Java8中，Lambda表达式是对象，而不是函数，它必须依附于一类特别的对象类型——函数式接口
> + 简单地说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以使用Lambda表达式来表示
> + 所以以前用匿名实现类表示的现在都可以使用Lambda表达式来写

### Java内置的函数式接口介绍

#### Java内置的四大核心函数式接口

|          函数式接口           | 参数类型 | 返回值类型 |                         接口方法描述                         |
| :---------------------------: | :------: | :--------: | :----------------------------------------------------------: |
|  Consumer<T><br />消费型接口  |    T     |    void    |   对类型为T的对象应用操作<br />包含方法： void accept(T t)   |
|  Supplier<T><br />供给型接口  |    无    |     T      |           返回类型为T的对象<br />包含方法：T get()           |
| Function<T,R><br />函数型接口 |    T     |     R      | 对类型为T的对象应用操作，并返回结果。结果是R类型的对象<br />包含方法：R apply(T t) |
| Predicate<T><br />断定型接口  |    T     |  boolean   | 确定类型为T的对象是否满足某约束，并返回 boolean 值<br />包含方法：boolean test(T t) |

#### 其它函数式接口

|                        函数式接口名称                        |         参数类型          |        返回值类型         |                         接口方法描述                         |
| :----------------------------------------------------------: | :-----------------------: | :-----------------------: | :----------------------------------------------------------: |
|                      BiFunction<T,U,R>                       |            T,U            |             R             | 对类型为 T, U 参数应用操作，返回 R 类型的结果<br />包含方法为： R apply(T t, U u); |
|            UnaryOperator<T><br />(Function子接口)            |             T             |             T             | 对类型为T的对象进行一元运算，并返回T类型的结果<br />包含方法为：T apply(T t); |
|          BinaryOperator<T><br />(BiFunction 子接口)          |            T,T            |             T             | 对类型为T的对象进行二元运算，并返回T类型的结果<br />包含方法为： T apply(T t1, T t2); |
|                       BiConsumer<T,U>                        |            T,U            |           void            | 对类型为T, U 参数应用操作<br />包含方法为： void accept(T t, U u) |
|                       BiPredicate<T,U>                       |            T,U            |          boolean          |              包含方法为： boolean test(T t,U u)              |
| ToIntFunction<T><br />ToLongFunction<T><br />ToDoubleFunction<T> |             T             | int<br />long<br />double |              分别计算int、long、double值的函数               |
|  IntFunction<T><br />LongFunction<T><br />DoubleFunction<T>  | int<br />long<br />double |             R             |            参数分别为int、long、double 类型的函数            |

### Java内置的函数式接口代码使用举例

```java
/**
 * java内置的4大核心函数式接口
 *
 * 消费型接口 Consumer<T>     void accept(T t)
 * 供给型接口 Supplier<T>     T get()
 * 函数型接口 Function<T,R>   R apply(T t)
 * 断定型接口 Predicate<T>    boolean test(T t)
 *
 *
 * @author shkstart
 * @create 2019 下午 2:29
 */
public class LambdaTest2 {
  @Test
  public void test1(){
    //一般写法
    happyTime(500, new Consumer<Double>() {
      @Override
      public void accept(Double aDouble) {
        System.out.println("学习太累了，去天上人间买了瓶矿泉水，价格为：" + aDouble);
      }
    });
    System.out.println("********************");
    //Lambda写法
    happyTime(400,money -> System.out.println("学习太累了，去天上人间喝了口水，价格为：" + money));
  }

  public void happyTime(double money, Consumer<Double> con){
    con.accept(money);
  }


  @Test
  public void test2(){
    List<String> list = Arrays.asList("北京","南京","天津","东京","西京","普京");
    //一般写法
    List<String> filterStrs = filterString(list, new Predicate<String>() {
      @Override
      public boolean test(String s) {
        return s.contains("京");
      }
    });
    System.out.println(filterStrs);
		//Lambda写法
    List<String> filterStrs1 = filterString(list,s -> s.contains("京"));
    System.out.println(filterStrs1);
  }

  //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定
  public List<String> filterString(List<String> list, Predicate<String> pre){
    ArrayList<String> filterList = new ArrayList<>();
    for(String s : list){
      if(pre.test(s)){
        filterList.add(s);
      }
    }
    return filterList;
  }
}
```

## 方法引用和构造器引用及数组引用

### 方法引用

> + 当要传递给Lambda体的操作已经有实现的方法了，就可以使用方法引用
> + 方法引用可以看作是Lambda表达式深层次的表达。换句话说，方法引用本质上就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖
> + 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致（该要求适用于以下第一种与第二种情况，第三种情况有些区别）
> + 格式：使用操作符"::"将类或对象与方法名隔开来
> + 如下三种主要使用情况
>   + 对象：：实例方法名
>   + 类：：静态方法名
>   + 类：：实例方法名（在面向对象中，类不可以直接调用非静态方法，但在方法引用中特殊）

```java
@Test
public void testMethod() {
  //一般写法
  Consumer<String> con1 = new Consumer<String>() {
    @Override
    public void accept(String t) {
      System.out.println(t);
    }
  };
  con1.accept("一般写法");

  //Lambda表达式写法
  Consumer<String> con2 = str -> System.out.println(str);
  con2.accept("Lambda表达式写法");

  /*
		 * Lambda表达式升级版之方法引用写法的第一种使用情况【对象::非静态方法名称】
		 *	鉴于Consumer接口中唯一的方法声明为：void accept(T t);
		 *	PrintStream中所使用到的实现方法声明为：void println(T t);
		 *	故二者的参数列表与返回值类型一致，适用方法引用的方式
		 */
  PrintStream print = System.out;// 首先创建PrintStream实例对象
  Consumer<String> con3 = print::println;//套上格式【对象::非静态方法名称】
  con3.accept("这是方法引用写法的第一种使用情况【对象::非静态方法名称】");


  /*
		 	方法引用的第二种使用情况【类::静态方法名称】：
		 		Comparator中的int comare(T t1,T t2)
		 		Integer中的int comare(T t1,T t2)
		 */
  Comparator<Integer> com = (t1,t2) -> Integer.compare(t1, t2);//Lambada表达式写法
  com.compare(1, 2);// -1
  Comparator<Integer> com2 = Integer::compare;//方法引用写法
  com.compare(1, 2);// -1

  /*
	 	方法引用的第三种使用情况【类::非静态方法名称】有难度：函数式接口方法的两个参数中，第一个参数是作为方法引用的调用者出现的也满足规则
	 		Comparator中的int comare(T t1,T t2)
	 		String中的int t1.compareTo(t2)
		 */
  Comparator<String> comparator = (t1,t2) -> t1.compareTo(t2);// Lambda表达式写法
  comparator.compare("a", "b");// -1
  Comparator<String> comparator2 = String::compareTo;// 方法引用写法
  comparator2.compare("a", "b");//-1
}
```

### 构造器引用

> 与方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致，抽象方法的返回值类型即为构造器所属类的类型

```java
@Test
public void testConstructor() {
  /*
	 * 构造器引用：Supplier中的T get() Person的空参构造器：Person()
	 */
  // 一般写法
  Supplier<Person> sup = new Supplier<Person>() {
    @Override
    public Person get() {
      return new Person();
    }
  };

  // Lambda写法
  Supplier<Person> sup2 = () -> new Person();

  // 构造器引用写法
  Supplier<Person> sup3 = Person::new;
  System.out.println(sup3.get());// Person [name=null, age=0]

  // Function中的R apply(T t)
  Function<Integer, Person> func = new Function<Integer, Person>() {
    @Override
    public Person apply(Integer t) {
      return new Person(t);// new Person(id)
    }
  };
  // Lambda写法
  Function<Integer, Person> func2 = id -> new Person(id);
  // 构造器引用写法
  Function<Integer, Person> func3 = Person::new;// 参数不用写了，返回值类型相同，参数列表相同即方法引用的写法，参数列表可以省略不写，调用的就是new Person(id)
  System.out.println(func3.apply(1001));// Person [name=null, age=0, id=1001]
}
```

### 数组引用

> 可以将数组看作一个特殊的类，则数组引用的用法与构造器引用的用法一致

```java
@Test
public void testConstructor() {
  // Function中的R apply(T t)
  Function<Integer, String[]> func = new Function<Integer, String[]>() {
    @Override
    public String[] apply(Integer t) {
      return new String[t];// 初始化长度
    }
  };
  // Lambda写法
  Function<Integer, String[]> func2 = length -> new String[length];
  String[] arr = func2.apply(5);// 相当于String[] arr = new String[5];
  // 数组引用写法
  Function<Integer, String[]> func3 = String[]::new;// 看作构造器就行了
}
```

***

## 强大的Stream API

### 什么是Stream

> Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列（集合讲的是数据，Stream讲的是计算）
>
> 注意：
>
> + Stream不会自己存储元素
> + Stream不会改变源对象，相反，他们会返回一个持有结果的新的Stream（不可变性）
> + Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行

### Stream API说明

> + Java8最重要的两大改变就是出现了Lambda表达式与StreamAPI
>
> + Stream API（java.util.Stream）把真正的函数式编程风格引入到Java中，这是目前为止对Java类库最好的补充，因为StreamAPI可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码
> + Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用StreamAPI对集合进行操作，就类似于使用SQL执行的数据库查询，也可以使用StreamAPI来并行执行操作。简言之，StreamAPI提供了一种高效且易于使用的处理数据的方式

### 为什么要使用StreamAPI

> + 实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源更多了，有MongDB、Redis等，而这些NoSQL的数据就需要Java层面去处理，当处理到NoSQL的数据，就应当应用上StreamAPI
> + Stream和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的。前者主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算

### Stream操作的三个步骤

> + 创建Stream：根据一个数据源（如集合、数组等），获取一个Stream流，即Stream的实例化
> + 中间操作：一个中间操作链，对数据源的数据进行处理（过滤、映射等）
> + 终止操作（终端操作）：一旦终止操作，才执行中间操作链，并产生结果，之后该流就被关闭了，即需要重新创建Stream流

### Stream的实例化的四种方式

> 实例化方式一：通过集合实例化，Java8的Collection接口被扩展，提供了两个获取Stream实例的方法：
>
> + default Stream<E> stream()：返回一个串行流（即顺序流）
> + default Stream<E> parallelStream()：返回一个并行流
>
> 实例化方式二：通过数组实例化，Java8中的Arrays的静态方法stream()可以获取数组流：
>
> + static <T> Stream<T> stream(T[] array)：通过指定的泛型返回一个自定义类型流
> + 重载形式，能够处理对应基本类型的数组：
>   + public static IntStream stream(int[] array)
>   + public static LongStream stream(long[] array)
>   + public static DoubleStream stream(double[] array)
>   + ...
>
> 实例化方式三：可以通过调用Stream类静态方法of()，通过显式值创建一个流。它可以接受任意数量的参数（即可变形参），这些个可变参数构成一个容器
>
> + public static<T> Stream<T> of(T...values)：返回一个流
>
> 实例化方式四：创建无限流，可以使用静态方法Stream.iterate()和Stream.generate()创建无限流（适合造数据，了解前三个即可）
>
> + 【迭代】public static<T> Stream<T> iterate(final T seed,final UnaryOperator<T> f)
> + 【生成】public static<T> Stream<T> generate(Supplier<T> s)

```java
@Test
public void test() {
  // 实例化方式一：通过集合
  List<Integer> list = new ArrayList<Integer>();
  Stream<Integer> listStream = list.stream();// 获取一个集合的串行流
  Stream<Integer> listParallelStream = list.parallelStream();// 获取一个集合的并行流

  // 实例化方式二：通过数组
  int[] arr = new int[] { 1, 2, 3 };
  IntStream arrIntStream = Arrays.stream(arr);// 获取Int类型数组流

  Person[] personArr = new Person[2];
  Stream<Person> stream = Arrays.stream(personArr);// 获取自定义类型数组流

  // 实例化方式三：通过Stream.of(T..values)
  Stream<Integer> of = Stream.of(1, 2, 3, 4, 5);

  // 实例化方式四：创建无限流（可以帮我们造数据）
  // 迭代
  Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println);// limit方法意为中间链限制（就想要前十个，没有限制就会无限执行下去，因为是无限流），forEach遍历方法意为终止操作，因为要输出结果
  // 生成
  Stream.generate(Math::random).limit(10).forEach(System.out::println);
}
```

### Stream的中间操作

> 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为“惰性求值”

#### 筛选与切片

|       方法名        |                           方法描述                           |
| :-----------------: | :----------------------------------------------------------: |
| filter(Predicate p) |             接收Lambda表达式，从流中过滤某些元素             |
|     distinct()      | 筛选，通过流所生成元素的hashCode()和equals()去除重复元素<br />要求自定义类重写hashCode()与equals()方法 |
| limit(long maxSize) |                截断流，使其元素不超过给定数量                |
|    skip(long n)     | 跳过元素，返回一个扔掉了前n个元素的流。<br />若流中元素不足n个，则返回一个空流。与limit(n)互补 |

```java
//filter(Predicate p)方法示例：按参数p中重写的方法test设置的条件过滤掉某些元素
List<Person> personList = new ArrayList<Person>();//初始化承装Person类对象的List
//添加数据
personList.add(new Person("Martha", 21));
personList.add(new Person("Martha", 22));
personList.add(new Person("Martha", 11));
personList.add(new Person("Martha", 32));
personList.add(new Person("Martha", 12));
Stream<Person> listStream = personList.stream();// 通过Person集合得到串行流
		/*筛选出所有集合对象中年龄大于18岁的Person【一般写法】
		Predicate<Person> predicate = new Predicate<Person>() {

			@Override
			public boolean test(Person t) {
				return t.getAge() > 18;
			}

		};
		Stream<Person> filterStream = listStream.filter(predicate);//将Predicate的引用作为参数传入以作为filter方法过滤的判断条件
		Consumer<Person> consumer = new Consumer<Person>() {

			@Override
			public void accept(Person t) {
				System.out.println(t);//输出被过滤后的Person对象
			}

		};
		filterStream.forEach(consumer);//将Consumer的引用作为参数传入以作为forEach方法遍历的终止操作
		*/
//筛选出所有集合对象中年龄大于18岁的Person【Lambda写法】
listStream.filter(person -> person.getAge() > 18).forEach(System.out::println);
--------------------------------------------------------------------------------------------------------
//limit(long maxSize)方法示例：截断流，使其元素不超过指定maxSize的数量
List<Person> personList = new ArrayList<Person>();//初始化承装Person类对象的List
//添加数据
personList.add(new Person("Martha", 21));
personList.add(new Person("Martha", 22));
personList.add(new Person("Martha", 11));
personList.add(new Person("Martha", 32));
personList.add(new Person("Martha", 12));
Stream<Person> listStream = personList.stream();// 通过Person集合得到串行流
//筛选出所有集合对象中年龄大于18岁的两个Person【Lambda写法】，注意是串行流所以按照元素添加顺序筛选输出
listStream.filter(person -> person.getAge() > 18).limit(2).forEach(System.out::println);
--------------------------------------------------------------------------------------------------------
//skip(long n)方法示例：返回一个忽略了集合或数组前n个元素的流，即会跳过指定数量的元素，即使满足条件也跳过
List<Person> personList = new ArrayList<Person>();//初始化承装Person类对象的List
//添加数据
personList.add(new Person("Martha", 21));
personList.add(new Person("Martha", 32));
personList.add(new Person("Martha", 11));
personList.add(new Person("Martha", 22));
personList.add(new Person("Martha", 12));
Stream<Person> listStream = personList.stream();// 通过Person集合得到串行流
//由于是串行流，所以跳过集合前两个元素后开始筛选出其后所有集合对象中年龄大于18岁的Person【Lambda写法】
listStream.filter(person -> person.getAge() > 18).skip(2).forEach(System.out::println);
--------------------------------------------------------------------------------------------------------
//distinct()方法示例：去重复数据
List<Person> personList = new ArrayList<Person>();//初始化承装Person类对象的List
//添加数据
personList.add(new Person("Martha", 21));
personList.add(new Person("Martha", 32));
personList.add(new Person("Martha", 11));
personList.add(new Person("Martha", 22));
personList.add(new Person("Martha", 12));
//添加重复数据
personList.add(new Person("Martha", 12));
personList.add(new Person("Martha", 12));
personList.add(new Person("Martha", 12));
personList.add(new Person("Martha", 12));
Stream<Person> listStream = personList.stream();// 通过Person集合得到串行流
//去掉集合中重复的Person数据对象【Lambda写法】
listStream.distinct().forEach(System.out::println);
```

#### 映射

|             方法名              |                           方法描述                           |
| :-----------------------------: | :----------------------------------------------------------: |
|         map(Function f)         | 接收一个函数作为参数，该函数功能会被应用到每个元素上，并将其映射成一个新的元素 |
| mapToDouble(ToDoubleFunction f) | 接收一个函数作为参数，该函数功能会被应用到每个元素上，产生一个新的DoubleStream |
|    mapToInt(ToIntFunction f)    | 接收一个函数作为参数，该函数功能会被应用到每个元素上，产生一个新的IntStream |
|   mapToLong(ToLongFunction f)   | 接收一个函数作为参数，该函数功能会被应用到每个元素上，产生一个新的LongStream |
|       flatMap(Function f)       | 接收一个函数作为参数，将流中的每一个值都换成另一个流，然后将所有的流连接成一个流 |

```java
//map(Function f)方法示例：将函数f的功能应用到每一个元素上，使其变为符合功能所要求的元素
List<Character> charList = Arrays.asList('a','b','c');//初始化字符List
Stream<Character> stream = charList.stream();//获取字符集合流
		/*
		Function<Character,Character> mapper = new Function<Character,Character>() {
			@Override
			public Character apply(Character t) {
				return t.toUpperCase(t);//转为大写字符
			}
		};
		stream.map(mapper).forEach(System.out::println);
		*/
//将每一个字符元素按照函数指定功能转为大写字符
stream.map(Character::toUpperCase).forEach(System.out::println);
--------------------------------------------------------------------------------------------------------
//flatMap(Function f)方法示例：
@Test
public void test2() {
  // map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。
  List<String> list = Arrays.asList("aa", "bb", "cc", "dd");
  // 每个元素都被转为另一个流，所以流中包含流，使用map方法来映射若遍历时需要两层遍历
  Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest::fromStringToStream);
  streamStream.forEach(s -> {
    s.forEach(System.out::println);
  });
  System.out.println();
  // flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流，所以就只有一条流
  Stream<Character> characterStream = list.stream().flatMap(StreamAPITest::fromStringToStream);
  characterStream.forEach(System.out::println);

}

// 将字符串中的多个字符构成的集合转换为对应的Stream的实例
public static Stream<Character> fromStringToStream(String str) {// aa
  ArrayList<Character> list = new ArrayList<>();
  for (Character c : str.toCharArray()) {
    list.add(c);
  }
  return list.stream();
}
```

#### 排序

|         方法名         |                           方法描述                           |
| :--------------------: | :----------------------------------------------------------: |
|        sorted()        | 返回一个新流，按照自然顺序从小到大排序<br />要求自定义类实现Comparable接口 |
| sorted(Comparator com) |             返回一个新流，按照比较器顺序定制排序             |

```java
@Test
public void test1() {
  // 自然排序
  List<Integer> list = Arrays.asList(2, 3, 1, 5);
  list.stream().sorted().forEach(System.out::print);

  // 定制排序
  List<Person> personList = new ArrayList<Person>();// 初始化承装Person类对象的List
  // 添加数据
  personList.add(new Person("比尔盖茨", 21));
  personList.add(new Person("马化腾", 22));
  personList.add(new Person("扎克伯格", 11));
  personList.add(new Person("施瓦辛格", 11));
  // 按照年龄排序
  personList.stream().sorted((p1, p2) -> Integer.compare(p1.getAge(), p2.getAge())).forEach(System.out::println);
}
```

### Stream的终止操作

> + 终止操作会从流的流水线生成结果，其结果可以是任何不是流的值，例如List、Integer甚至void
>
> + 当一个流进行终止操作后，不可再次使用

#### 匹配与查找

|         方法名         |                           方法描述                           |
| :--------------------: | :----------------------------------------------------------: |
| allMatch(Predicate p)  |                     检查是否匹配所有元素                     |
| anyMatch(Predicate p)  |                   检查是否至少匹配一个元素                   |
| noneMatch(Predicate p) |                   检查是否没有匹配所有元素                   |
|      findFirst()       |                        返回第一个元素                        |
|       findAny()        |                    返回当前流中的任意元素                    |
|        count()         |                       返回流中元素总数                       |
|   max(Comparator c)    |                        返回流中最大值                        |
|   min(Comparator c)    |                        返回流中最小值                        |
|  forEach(Consumer c)   | 内部迭代（使用Collection接口需要用户去做迭代，称为外部迭代<br />StreamAPI使用内部迭代，即它帮你把迭代做了） |

```java
@Test
public void test1() {
  List<Person> personList = new ArrayList<Person>();// 初始化承装Person类对象的List
  // 添加数据
  personList.add(new Person("比尔盖茨", 21));
  personList.add(new Person("马化腾", 22));
  personList.add(new Person("扎克伯格", 11));
  personList.add(new Person("施瓦辛格", 11));
  // 使用allMatch(Predicate p)方法判断是否所有Person的年龄都大于18岁
  boolean isAdult = personList.stream().allMatch(person -> person.getAge() > 18);
  System.out.println(isAdult);// false：Person集合中还存在11岁的未成年人

  // 使用anyMatch(Predicate p)方法判断是否存在有年满18岁的Person
  boolean isExist = personList.stream().anyMatch(person -> person.getAge() > 18);
  System.out.println(isExist);// true：Person集合中存在21岁的成年人

  // 使用noneMatch方法判断是否没有一个名字叫Martha的Person
  boolean isNone = personList.stream().noneMatch(person -> person.getName().equals("Martha"));
  System.out.println(isNone);// true：Person集合中的确没有一个名字叫做Martha的人‘

  // 使用findFirst()方法返回Person集合中第一个Person对象
  Optional<Person> person = personList.stream().findFirst();
  System.out.println(person.get());// Person [name=比尔盖茨, age=21, id=0]

  // 使用findAny()方法返回Person集合中任何一个Person对象，由于随机性所以使用并行流，因为串行流进来就获取到了第一个
  Optional<Person> randomPerson = personList.parallelStream().findAny();
  System.out.println(randomPerson.get());

  // 使用count()方法返回当前流中元素总数
  long sum = personList.stream().count();
  System.out.println(sum);// 4：当前流中未经任何中间操作，故总数与集合长度一样

  // 使用max(Comparator c)方法返回当前流中最大值，以下为获取年龄最大的那个人
  Optional<Person> maxPerson = personList.stream()
    .max((person1, person2) -> Integer.compare(person1.getAge(), person2.getAge()));
  System.out.println(maxPerson.get());// Person [name=马化腾, age=22, id=0]

  // 使用min(Comparator c)方法返回当前流中最大值，以下为获取年龄最小的那个人
  Optional<Person> minPerson = personList.stream()
    .min((person1, person2) -> Integer.compare(person1.getAge(), person2.getAge()));
  System.out.println(minPerson.get());// Person [name=扎克伯格, age=11, id=0]：即使有两个11岁的人，但别忘了，这是串行流

  // 使用forEach(Consumer c)方法遍历当前流中的元素
  personList.stream().forEach(System.out::println);
  /*
		 Person [name=比尔盖茨, age=21, id=0]
		 Person [name=马化腾, age=22, id=0]
		 Person [name=扎克伯格, age=11, id=0]
		 Person [name=施瓦辛格, age=11, id=0]
	*/
}
```

#### 归约

> map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名

|             方法名              |                           方法描述                           |
| :-----------------------------: | :----------------------------------------------------------: |
| reduce(T iden,BinaryOperator b) | 可以将流中元素反复结合起来，得到一个值。返回T<br />参数一：初始值，结果会加上初始值 |
|    reduce(BinaryOperator b)     |   可以将流中元素反复结合起来，得到一个值。返回Optional<T>    |

```java
// 使用reduce(T iden,BinaryOperator b)方法计算1-10自然数的和
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		/*
		BinaryOperator<Integer> accumulator = new BinaryOperator<Integer>() {

			@Override
			public Integer apply(Integer t, Integer u) {
				return Integer.sum(t, u);
			}
		};
		list.stream().reduce(0, accumulator);
		*/
Integer sum = list.stream().reduce(0, Integer::sum);
System.out.println(sum);// 55

// 使用reduce(BinaryOperator b)方法计算所有Person年龄总和
List<Person> personList = new ArrayList<Person>();// 初始化承装Person类对象的List
// 添加数据
personList.add(new Person("比尔盖茨", 21));
personList.add(new Person("马化腾", 22));
personList.add(new Person("扎克伯格", 11));
Optional<Integer> ageSum = personList.stream().map(person1 -> person1.getAge()).reduce(Integer::sum);
System.out.println(ageSum.get());// 54
```

#### 收集

> Collector接口中方法的实现决定了如何对流执行收集的操作（如收集到List、Set、Map）

|         方法名          |                           方法描述                           |
| :---------------------: | :----------------------------------------------------------: |
| collection(Collector c) | 将流转换为其它形式<br />接受一个Collector接口的实现，用于给Stream中元素做汇总的方法 |

```java
@Test
public void test1() {
  // 使用collect(Collector c)方法收集年龄大于18岁的Person，并返回一个List对象
  List<Person> personList = new ArrayList<Person>();// 初始化承装Person类对象的List
  // 添加数据
  personList.add(new Person("比尔盖茨", 21));
  personList.add(new Person("马化腾", 22));
  personList.add(new Person("扎克伯格", 11));
  personList.add(new Person("Martha", 22));
  personList.add(new Person("Beth", 32));
  // Collector<Person,,List<Person>> collector = new
  // Collector<Person,,List<Person>>() {};
  List<Person> collect = personList.stream().filter(person -> person.getAge() > 18).collect(Collectors.toList());
  collect.forEach(System.out::println);
  // 无序集合Set
  Set<Person> set = personList.stream().filter(person -> person.getAge() > 18).collect(Collectors.toSet());
  set.forEach(System.out::println);
}
```

> 另外，Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：

## Optional类

> + 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司主名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java8类库的一部分
> + Optional<T>类（java.util.Optional）是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null值，表示这个值不存在。原来使用null表示一个值不存在，现在Optional类可以更好地表达这个概念。并且可以避免空指针异常
> + Optional类的JavaDoc描述如下：这是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象
> + Optional类提供了很多有用的方法，这样我们就不用显式进行空值检测
> + 总结：
>   + Optional类就是为了避免空指针异常而创建的
>   + 常用方法为：
>     + ofNullable(T t)
>     + orElse(T t)

> 创建Optional类对象的方法

|          方法名          |              方法描述               |
| :----------------------: | :---------------------------------: |
|     Optional.of(T t)     | 创建一个Optional实例，要求t必须非空 |
|     Optional.empty()     |      创建一个空的Optional实例       |
| Optional.ofNullable(T t) |  创建一个Optional实例，t可以为null  |

```java
@Test
public void test1() {
  Girl girl = new Girl();
  // girl = null;
  // of(T t):保证t是非空的
  Optional<Girl> optionalGirl = Optional.of(girl);// 实例化方式一
  // girl = null;
  // ofNullable(T t)：t可以为null//实例化方式二
}
```

> 判断Optional容器中是否包含对象

|                    方法名                     |                           方法描述                           |
| :-------------------------------------------: | :----------------------------------------------------------: |
|             boolean  isPresent()              |                       判断是否包含对象                       |
| void  ifPresent(Consumer<? super T> consumer) | 如果有值，就执行Consumer接口的实现代码<br />并且该值会作为参数传给该代码 |

> 获取Optional容器的对象

|                         方法名                          |                           方法描述                           |
| :-----------------------------------------------------: | :----------------------------------------------------------: |
|                        T  get()                         |         如果调用对象包含值，返回该值<br />否则抛异常         |
|                   T  orElse(T other)                    |       如果有值则将其返回<br />否则返回指定的other对象        |
|        T  orElseGet(Supplier<? extends T> other)        | 如果有值则将其返回<br />否则抛出由Supplier接口实现提供的对象 |
| T  orElseThrow(Supplier<? extends X> exceptionSupplier) | 如果有值则将其返回<br />否则抛出由Supplier接口实现提供的异常 |

```java
// 优化以后的getGirlName():需要if判断来层层嵌套避免空指针异常
public String getGirlName1(Boy boy) {
  if (boy != null) {
    Girl girl = boy.getGirl();
    if (girl != null) {
      return girl.getName();
    }
  }
  return null;
}
// 使用Optional类的getGirlName():
public String getGirlName2(Boy boy) {
  Optional<Boy> boyOptional = Optional.ofNullable(boy);
  // 此时的boy1一定非空
  Boy boy1 = boyOptional.orElse(new Boy(new Girl("迪丽热巴")));
  Girl girl = boy1.getGirl();
  Optional<Girl> girlOptional = Optional.ofNullable(girl);
  // girl1一定非空
  Girl girl1 = girlOptional.orElse(new Girl("古力娜扎"));
  return girl1.getName();
}
@Test
public void test5() {
  Boy boy = null;
  boy = new Boy();
  boy = new Boy(new Girl("肖老师"));
  String girlName = getGirlName2(boy);
  System.out.println(girlName);//肖老师
}
```

# 第十七章 Java9&10&11新特性

## Java 9 的新特性

### JDK版本更新的说明

> +  经过4次跳票，历经曲折的Java 9 终于终于在2017年9月21日发布
> + 从Java 9 这个版本开始，Java 的计划发布周期是 6 个月，下一个 Java 的主版本将于 2018 年 3 月发布，命名为 Java 18.3，紧接着再过六个月将发布 Java  18.9
> + 这意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的 （6 个月为周期）发布模式，并逐步的将 Oracle JDK 原商业特性进行开源
> + 针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term  support）
> + Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、可交互 的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安 全增强、扩展提升、性能管理改善等。可以说Java 9是一个庞大的系统工程， 完全做了一个整体改变

### 新版本JDK的下载与IDEA开发环境的设置

### Java 9 中有哪些不得不说的新特性？

> + ==模块化系统==
> + ==jShell命令==
> + 多版本兼容jar包
> + 接口的私有方法
> + 钻石操作符的使用升级
> + 语法改进：try语句
> + String存储结构变更
> + 便利的集合特性：of()
> + 增强的Stream API 
> + 全新的HTTP客户端API
> + Deprecated的相关API
> + javadoc的HTML 5支持
> + Javascript引擎升级：Nashorn
> + java的动态编译器
> +  官方提供的新特性列表：
>   + [Java Platform, Standard Edition What’s New in Oracle JDK 9, Release 9](https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6)
> +  或参考 Open JDK
>   + [JDK 9 (java.net)](http://openjdk.java.net/projects/jdk9/)
> +  在线Oracle JDK 9 Documentation
>   + [Oracle JDK 9 Documentation](https://docs.oracle.com/javase/9/)

### JDK 和 JRE 目录结构的改变

#### Java8目录结构

|    目录名    |                           目录描述                           |
| :----------: | :----------------------------------------------------------: |
|   bin 目录   |      包含命令行开发和调试工具，如javac，jar和javadoc。       |
| include目录  |            包含在编译本地代码时使用的C/C++头文件             |
|   lib 目录   | 包含JDK工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包 含javac编译器的Java类 |
|   lib 目录   | 包含基本命令，如java命令。 在Windows平台上，它包含系统的运行时动态链 接库（DLL）。 |
| jre/lib 目录 | 包含用户可编辑的配置文件，如.properties和.policy文件。包含几个JAR。 rt.jar文件包含运行时的Java类和资源文件。 |

#### Java9及以上

> 没有名为jre的子目录

|    目录名    |                           目录描述                           |
| :----------: | :----------------------------------------------------------: |
|   bin 目录   | 包含所有命令。 在Windows平台上，它继续包含系统的运行时动态链接库。 |
|  conf 目录   | 包含用户可编辑的配置文件，例如以前位于jre\lib目录中的.properties和.policy文件 |
| include 目录 | 包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于JDK中 |
|  jmods 目录  | 包含JMOD格式的平台模块。 创建自定义运行时映像时需要它。 它只存在于JDK中 |
|  legal 目录  |                         包含法律声明                         |
|   lib 目录   | 包含非Windows平台上的动态链接本地库。 其子目录和文件不应由开发人员直接编辑或使用 |

### 模块化系统

> + 谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目。众所周知，Java 已经 发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越 来越暴露出一些问题：
>   + Java 运行环境的膨胀和臃肿。每次JVM启动的时候，至少会有30～60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第 一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程序运行需要的class）
>   + Java 运行环境的膨胀和臃肿。每次JVM启动的时候，至少会有30～60MB的内存 加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第 一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程 序运行需要的class
>   + 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间 的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共 类所访问到，这样就会导致无意中使用了并不想被公开访问的 API
>   + 本质上讲也就是说，模块(module)的概念，其实就是package外再裹一层，也就是说，用模块来管理各个package，通过声明某个package 暴露，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。
> + 实现目标
>   + 模块化的主要目的在于减少内存的开销
>   + 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开 发和维护
>   + 改进 Java SE 平台，使其可以适应不同大小的计算设备
>   + 改进其安全性，可维护性，提高性能
> + 实现步骤如下
>   + 以Eclipse举例，每一个都是一个工程，每一个工程都有一个src目录
>   + 以IDEA举例，一个大的工程中有许多小Module，每一个小Module都有一个src目录
>   + 如在day01工程（Module）的src目录的包下的类想引用day02工程（Module）src目录包下的类或API，则要同时在两个工程（Module）的src目录下创建module-info.java文件（右键src→new出来的结构），代码如下：

```java
//module-info.java的引用者（即以上的day01工程(module)）声明如下
module day01{
  requires day02;//表明需要day02工程的结构，因为在被引用者文件中module day02暴露了day01所需要的包
}
//module-info.java的被引用者（即以上的day02工程(module)）声明如下
module day02{
  exports com.martha.bean;//暴露包，等同于暴露了这个包下所有的结构，谁需要就直接requires day02即可获取并导入暴露的包
}
```

#### 模块化系统的总结

> 模块将由通常的类和新的模块声明文件（module-info.java）组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系， 以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在 模块中，不能在外部使用。
>
> + exports：控制着哪些包可以被其它模块访问到。所有不被导出的包默认 都被封装在模块里面。
> + requires：指明对其它模块的依赖。

### Java的REPL工具：jShell命令

> +  产生背景：像Python 和 Scala 之类的语言早就有交互式编程环境 REPL (read - evaluate - print - loop)了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码， 就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现。
> + 设计理念：即写即得、快速运行
> +  实现目标：即可以在命令行书写Java代码并运行
>   + Java 9 中终于拥有了 REPL工具：jShell。让Java可以像脚本语言一样运行，从 控制台启动jShell，利用jShell在没有创建类的情况下直接声明变量，计算表达式， 执行语句。即开发时可以在命令行里直接运行Java的代码，而无需创建Java文 件，无需跟人解释”public static void main(String[] args)”这句废话。
>   + jShell也可以从文件中加载语句或者将语句保存到文件中。
>   + jShell也可以是tab键进行自动补全和自动添加分号。

```powershell
调出jshell工具
C:>jshell
获取帮助
jshell>/help intro
基本使用和Java类似并且没有受检异常（编译时异常）
列出当前 session 里所有有效的代码片段
jshell>/list
查看当前 session 下所有创建过的变量
jshell>/vars
查看当前 session 下所有创建过的方法
jshell>/methods
使用外部代码编辑器来编写 Java 代码
jshell>/edit
使用/open命令打开指定Java文件
jshell>/open C:code\helloworld.java
退出jShell
jshell>/exit
```

### 接口的私有方法

> Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。
>
> 在Java 9中，接口更加的灵活和强大，连方法的访问权限修饰符都可 以声明为private的了，此时方法将不会成为你对外暴露的API的一部分。

```java
interface MyInterface {
  //接口的抽象方法
	void normalInterfaceMethod();
  //接口中的默认方法1【源自Java8】
  default void methodDefault1() {
  	init();
  }
  //接口中的默认方法2【源自Java8】
  public default void methodDefault2() {
  	init();
  }
  //接口中的私有方法【源自Java8】
  public static void staticMethod(){
    System.out.println("我是接口中声明的私有方法");
  }
  //接口中定义的私有方法【源自Java9】
  private void init() {
  	System.out.println("默认方法中的通用操作");
  }
}
class MyInterfaceImpl implements MyInterface{
  @Override
  public void normalInterfaceMethod(){
    System.out.println("我实现了接口中的抽象方法");
  }
}
public class MyInterfaceTest {
  public static void main(String[] args) {
    MyInterfaceImpl impl = new MyInterfaceImpl();//创建实现类的对象
    impl.methodDefault1();//实现类可以调用接口中的默认方法
    //impl.staticMethod();//不能通过实现类对象调用接口中的静态方法，接口中的静态方法应由接口本身调用
    // impl.init();//不能调用接口中声明的私有方法
  }
}
```

### 钻石操作符的升级

> 我们将能够与匿名实现类共同使用钻石操作符（diamond operator）在Java 8 中如下的操作是会报错的：即在Java8中泛型的<>不能与匿名是实现类共同使用，但在Java9开始就改进了这个问题
>
> 编译报错信息：Cannot use “<>” with anonymous inner classes.
>
> Comparator com = new Comparator==<>==(){ 
>
> ​	@Override 
>
> ​	public int compare(Object o1, Object o2) {
>
>  		return 0; 
>
> ​	}
>
>  };

### try结构的语法升级

```java
// java 8之前的资源关闭的操作，需要手动放入finally中进行资源的关闭
InputStreamReader reader = null;
try {
  reader = new InputStreamReader(System.in);
  char[] cbuf = new char[20];
  int len;
  if ((len = reader.read(cbuf)) != -1) {
    String str = new String(cbuf, 0, len);
    System.out.println(str);
  }
} catch (IOException e) {
  e.printStackTrace();
} finally {
  if (reader != null) {
    try {
      reader.close();//手动关闭资源
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
--------------------------------------------------------------------------------------------------------
// java 8中资源关闭操作: Java 8 中，可以实现资源的自动关闭，但要求自动关闭的资源的声明和实例化都必须放在try的()中,多个资源的声明和初始化用分号;隔开如(InputStream is = new FileInputStream();OutputStream os = new OutputStream()...)
try (InputStreamReader reader = new InputStreamReader(System.in)) {
  char[] cbuf = new char[20];
  int len;
  if ((len = reader.read(cbuf)) != -1) {
    String str = new String(cbuf, 0, len);
    System.out.println(str);
  }
} catch (IOException e) {
  e.printStackTrace();
}
--------------------------------------------------------------------------------------------------------
// java9中资源关闭操作：需要自动关闭的资源的声明和实例化可以放在try的一对小括号外部。但此时的引用对象reader置入小括号中就变为常量了，声明为final的，在try语句内不可修改
//注意：若存在多个流，则多个流的引用使用;分号隔开，如try(reader;writer..)
InputStreamReader reader = new InputStreamReader(System.in);
try (reader) {
  char[] cbuf = new char[20];
  int len;
  if ((len = reader.read(cbuf)) != -1) {
    String str = new String(cbuf, 0, len);
    System.out.println(str);
  }
  //reader = null;不可对其进行修改
} catch (IOException e) {
  e.printStackTrace();
}
```

### String底层存储结构的变更

> 字符串类的当前实现将字符存储在字符中阵列，每个字符使用两个字节（十六位）。从许多不同的应用程序表明，字符串是堆使用而且，大多数字符串对象只包含拉丁文-1字符。此类字符只需要一个字段的存储，因此一半的此类字符对象的内部字符阵列中的空间将未使用
>
> 我们建议将字符串类的内部表示从UTF-16 字符阵列到字组阵列加上编码标志字段。新字符串类将存储编码为 ISO-8859-1/拉丁文-1 的字符（一个字符一个byte），或作为UTF-16（每个字符两个字节），基于内容字符串。编码标志将指示使用哪个编码。
>
> 结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。（当然StringBuffer和StirngBuilder底层也改为使用byte[]数组存储数据了）

### 集合工厂方法：快速创建只读集合

> 要创建一个只读、不可改变的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。

```java
//Java8中创建只读集合的写法,先创建并赋值完集合，再通过unmodifiableList锁定集合为只读，不省事儿
List<String> namesList = new ArrayList <>();
namesList.add("Joe");
namesList.add("Bob");
namesList.add("Bill");
//返回的namesList是一个不可再改变的集合，故只读集合
namesList = Collections.unmodifiableList(namesList);
namesList.add("Martha");//虽然编译不报错，但在运行时会报异常
System.out.println(namesList);
//缺点：我们一下写了五行。即：它不能表达为单个表达式。，当然Java8还有一种常用的方式返回的也是一个只读集合
List<Integer> list = Arrays.asList(1,2,3);
list.add(4);//运行时也会报异常，因为它是只读的
--------------------------------------------------------------------------------------------------------
//Java9中可以更方便地创建一个只读集合【使用集合工厂方法of()就可以返回一个只读集合】，一行代码就可以创建只读集合，省事儿
List<Integer> list = List.of(1,2,3);
list.add(4);//运行时也会报异常，因为它是只读的
Set<Integer> set = Set.of(1,2,3);
set.add(4);//运行时也会报异常，因为它是只读的
Map<String,Integer> map = Map.of("Martha",21,"Mery",24);
map.put("Jerry",23);//运行时也会报异常，因为它是只读的
//Map除了of的方式创建只读集合，也可以通过Map.ofEntries()创建只读集合
Map<String,Integer> map2 = Map.ofEntries(Map.entry("Martha",21),Map.entry("Mery",24));
map2.put("Jerry",23);//运行时也会报异常，因为它是只读的
```

### InputStream的加强

> InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream（直接实现数据的复制操作），这是在处理原始数据流时非常常见的一种用法，如下示例：

```java
@Test
public void test() {
  ClassLoader cl = this.getClass().getClassLoader();
  try (InputStream is = cl.getResourceAsStream("hello.txt");
       OutputStream os = new FileOutputStream("src\\hello1.txt")) {
    is.transferTo(os); // 把输入流中的所有数据直接自动地复制到输出流中，即直接帮我们实现了读取输出的操作，换句话说，我们只需要指定输入流及被读取文件与输出流及被写出文件即可
  } catch (IOException e) {
    e.printStackTrace();
  }
}
```

### 增强的Stream API

> + Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。 
> + 在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法： takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法，可以 让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。 
> + 除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。

#### takeWhile()方法的使用

> 用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，takeWhile返回从开头开始的尽量多的元素。

```java
List<Integer> list = Arrays.asList(56, 23, 45, 12, 48, 60, 32, 45, 62);
// takeWhile()返回从开头开始满足条件的尽量多的元素，以下为获取到48之后，检索到60不满足条件，那么就尽可能找到48了，60不满足就停止循环了，60之后有满足的条件的元素也不要了
list.stream().takeWhile(p -> p < 58).forEach(System.out::print);// 56 23 45 12 48
```

#### dropWhile()方法的使用

> dropWhile 的行为与 takeWhile 相反，当有一个元素不满足条件，则返回该元素本身与该元素之后剩余的元素

```java
List<Integer> list = Arrays.asList(56, 23, 45, 12, 48, 60, 32, 45, 62);
// dropWhile()当有一个元素不满足条件，则返回该元素本身与该元素之后剩余的元素,以下为前三个元素都满足大于12的条件，到12就不满足了，12==12，所以包括12在内，其后所有的元素都将被直接返回，即其后的元素不再进行条件判断
list.stream().dropWhile(p -> p > 12).forEach(System.out::print);// 12 48 60 32 45 62
```

#### ofNullable()方法的使用

> Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。

```java
@Test
public void test2() {
  // of()参数中的多个元素，可以包含null值
  Stream<Integer> stream1 = Stream.of(1, 2, 3, null);
  stream1.forEach(System.out::println);// 1 2 3 null
  // 但of()参数不能存储单个null值。否则，报异常，当然可以这样Stream.of(null,null);这样就不算是单个null值就不会报异常
  //        Stream<Object> stream2 = Stream.of(null);
  //        stream2.forEach(System.out::println);//报异常
  Integer i = 10;
  i = null;
  // ofNullable()：形参变量是可以为null值的单个元素
  Stream<Integer> stream3 = Stream.ofNullable(i);
  long count = stream3.count();
  System.out.println(count);// 0，如果存储的是null值，则count就为0
}
```

#### iterate()重载方法的使用

> 这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代，所以之前的无限流就得以得到更好的限制了

```java
// 原先控制无限流的终止方式：
Stream.iterate(1, i -> i + 1).limit(100).forEach(System.out::println);
// 现在的终止方式：可以设置迭代条件
Stream.iterate(1, i -> i < 100, i -> i + 1).forEach(System.out::println);
```

### Optional的新方法stream()

> Optional也是一个容器，也应该像集合数组那样，能够获取一个属于自己的流，用于对自己所存储的数据进行中间操作等等，以下为代码示例：

```java
List<String> list = new ArrayList<>();
list.add("Tom");
list.add("Jerry");
list.add("Tim");
Optional<List<String>> optional = Optional.ofNullable(list);
Stream<List<String>> stream = optional.stream();//通过optional对象获取一个stream
stream.flatMap(x -> x.stream()).forEach(System.out::println);//获取集合的stream并遍历
```

### Javascript引擎升级：Nashorn

> + Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。 Nashorn 项目跟随 Netscape 的 Rhino 项目，目的是为了在 Java 中实现一个高 性能但轻量级的 Javascript 运行时。Nashorn 项目使得 Java 应用能够嵌入 Javascript。它在 JDK 8 中为 Java 提供一个 Javascript 引擎。
> + JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。
> + 一句话，JS代码可以在Java虚拟机上面运行了

## Java 10 的新特性

> + 2018年3月21日，Oracle官方宣布Java10正式发布。
> + 需要注意的是 Java 9 和 Java 10 都不是 LTS (Long-Term-Support) 版本。和 过去的 Java 大版本升级不同，这两个只有半年左右的开发和维护期。而未 来的 Java 11，也就是 18.9 LTS，才是 Java 8 之后第一个 LTS 版本。
> + JDK10一共定义了109个新特性，其中包含12个JEP（对于程序员来讲，真 正的新特性其实就一个），还有一些新API和JVM规范以及JAVA语言规范上 的改动。
> + JDK10的12个JEP（JDK Enhancement Proposal特性加强提议）参阅官方 文档：http://openjdk.java.net/projects/jdk/10/

### 局部变量的类型推断

> + 产生背景： 开发者经常抱怨Java中引用代码的程度。局部变量的显示类型声明，常常被认为 是不必须的，给一个好听的名字经常可以很清楚的表达出下面应该怎样继续。
>
> + 好处： 减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！
>
> + 场景一：类实例化时作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第一次用于声明变量类型，第二次用于构造器：
>
>   ```java
>   LinkedHashSet set = new LinkedHashSet<>();
>   Person p = new Person();
>   ```
>
> + 场景二：返回值类型含复杂泛型结构 变量的声明类型书写复杂且较长，尤其是加上泛型的使用：
>
>   ```java
>   Iterator<Map.Entry<Integer, Student>> iterator = set.iterator()
>   ```
>
> + 场景三： 我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中， 比如： 
>
>   ```java
>   URL url = new URL("http://www.atguigu.com");
>   URLConnection connection = url.openConnection(); 
>   Reader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
>   ```
>
> 尽管 IDE可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且， 有时候开发人员会尽力避免声明中间变量，因为太多的类型声明只会分散注意 力，不会带来额外的好处。

```java
@Test
public void test(){
  var number = 10;//类型推断：就不需要写int number = 10;了，直接使用var关键字声明即可
  var list = new ArrayList<Integer>();//同样类型推断
  list.add(12);
  //遍历集合的操作
  for(var i : list){
    System.out.println(i);// 123
    System.out.println(i.getClass());// class java.lang.Integer
  }
  
  //普通的遍历操作
  for(var i = 0;i<10;i++){
    System.out.println(i);
  }
}
--------------------------------------------------------------------------------------------------------
//不可以使用var的情况
@Test
public void test() {
  var i;//编译错误：无法推断i为何类型（局部变量不赋值，就不能实现类型推断）
  var i = null;//编译错误：无法通过null推断出具体类型（局部变量赋值为null，就不能实现类型推断）
  
   //2.Lambda表示式中，左边的函数式接口不能声明为var
  Supplier<Double> sup = () -> Math.random();
  //var sup = () -> Math.random();
  
  //3.方法引用中，左边的函数式接口不能声明为var
	Consumer<String> con = System.out::println;
	//var con = System.out::println;

  //4.数组的静态初始化中，注意如下的情况也不可以
  int[] arr = {1, 2, 3, 4};
  //var arr = {1,2,3,4};
  
  //5.方法的返回值类型不能使用var
  public var method1(){
    return 0;
  }
  
  //6.方法的参数类型也不能使用var
  public void method(var args){}
  //7.构造器的参数类型不能使用var
  public Person(var name){
    
  }
  
  //8.类属性不能使用var
  var name;//因为属性有默认值，默认值是通过数据类型得出，所以不能使用var来声明
  
  //9.try结构
  try{}catch(Var e){e.printStackTrace();}
}
```

#### 局部变量类型推断的工作原理

> 在处理var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中。

#### 局部变量类型推断的使用注意点

> + var不是一个关键字，你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字， 而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它 就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以， 但极少人会用它作为类名。
> + 这不是JavaScript 首先我要说明的是，var并不会改变Java是一门静态类型语言的事实。编译器负责推 断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。 下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：
>
> ```java
> var url = new URL("http://www.atguigu.com");
> var connection = url.openConnection();
> var reader = new BufferedReader(
> new InputStreamReader(connection.getInputStream()));
> //反编译后
> URL url = new URL("http://www.atguigu.com");
> URLConnection connection = url.openConnection();
> BufferedReader reader = new BufferedReader(
> new InputStreamReader(connection.getInputStream()));
> ```
>
> 从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所 以请放心，这不是 JavaScript。

### 集合工厂方法：新增创建只读集合的方法

> 自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和 copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。

```java
@Test
public void test5() {
  // 示例1：
  var list1 = List.of("Java", "Python", "C");
  var copy1 = List.copyOf(list1);//本身list1就是只读集合，所以返回的copy1就是其本身
  System.out.println(list1 == copy1); // true

  // 示例2：
  var list2 = new ArrayList<String>();
  list2.add("aaa");
  var copy2 = List.copyOf(list2);// list2不是一个只读集合，那么通过copyOf方法之后，就会返回为一个新的只读集合(不影响数据)，所以二者不同
  System.out.println(list2);
  System.out.println(copy2);
  System.out.println(list2 == copy2); // false

  // 示例1和2代码基本一致，为什么一个为true,一个为false?
  // 结论：copyOf(Xxx coll):如果参数coll本身就是一个只读集合，则copyOf()返回值即为当前的coll
  // 如果参数coll不是一个只读集合，则copyOf()返回一个新的集合，这个集合是只读的。
}
```

> 从 源 码 分 析 ， 可 以 看 出 copyOf 方 法 会 先 判 断 来 源 集 合 是 不 是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创 建一个新的集合。 示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类， 所以 copyOf 方法又创建了一个新的实例，所以为false。 注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。 上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。

## Java 11 的新特性

> JDK 11 是一个长期支持版本（LTS, Long-Term-Support）
>
> + 对于企业来说，选择 11 将意味着长期的、可靠的、可预测的技术路线图。 其中免费的OpenJDK11 确定将得到 OpenJDK 社区的长期支持， LTS 版本将 是可以放心选择的版本。
> + 从 JVM GC 的角度，JDK11 引入了两种新的 GC，其中包括也许是划时代意义 的 ZGC，虽然其目前还是实验特性，但是从能力上来看，这是 JDK 的一个巨 大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部 分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会 上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的 问题

### String新增方法

```java
// isBlank():判断字符串是否为空白
System.out.println("\t".isBlank());// true：如果字符串中没有数据（或只有转义字符）都返回true表示空白字符串
// strip():去除首尾空白
System.out.println("-----" + "  \t abc \t  \n  ".strip() + "-------");// -----abc-------：包括转移字符在内首尾空白部分都会被去除
System.out.println("-----" + "  \t abc \t  \n  ".trim() + "-------");// 功能同上
// stripTrailing():去除尾部空格
System.out.println("-----" + "  \t abc \t  \n  ".stripTrailing() + "-------");// ----- abc-------
// stripLeading():去除首部空格
System.out.println("-----" + "  \t abc \t".stripLeading());// -----abc
// repeat(int count):复制字符串
String str1 = "abc";
String str2 = str1.repeat(5);
System.out.println(str2);// abcabcabcabcabc

// lines().count():行数统计
String str3 = "abc\ndef\ng";
System.out.println(str3.lines().count());// 3
```

### Optional 加强

> Optional 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换 成一个 Stream, 或者当一个空 Optional 时给它一个替代的。

| 方法名                                                       |                           方法描述                           |  版本  |
| ------------------------------------------------------------ | :----------------------------------------------------------: | :----: |
| boolean isEmpty()                                            |                      判断value是否为空                       | JDK 11 |
| ifPresentOrElse(Consumer action, Runnable emptyAction)       |   value非空，执行参数1功能；如果value 为空，执行参数2功能    |  JDK9  |
| Optional or(Supplier<?  extends Optional<? extends T>> supplier) | value非空，返回对应的Optional； value为空，返回形参封装的Optional |  JDK9  |
| Stream stream()                                              | value非空，返回仅包含此value的 Stream；否则，返回一个空的Stream |  JDK9  |
| T orElseThrow()                                              |   value非空，返回value；否则抛异常 NoSuchElementException    | JDK10  |

```java
@Test
public void test1() {
  var op = Optional.empty();// 创建一个空的Optional容器类
  System.out.println(op.isPresent());// false：判断内部的value是否存在，显然不存在
  System.out.println(op.isEmpty());// true：判断内部的value是否为空，显然为空，二者返回值必然相反

  op = Optional.of("abc");// 创建一个存储字符串“abc”值得Optional容器类
  // orElseThrow():当value非空，返回value；否则抛异常NoSuchElementException
  var obj = op.orElseThrow();// 此时非空，那么obj将被赋值为字符串“abc”
  System.out.println(obj);// abc

  Optional<String> op1 = Optional.of("hello");
  //op = Optional.empty();
  // or:value非空，返回对应的Optional；value为空，返回形参封装的Optional
  Optional<Object> op2 = op.or(() -> op1);// or方法是针对Optional类的补充，orElse是针对Optional类中的值的补充
  System.out.println(op2);// Optional[abc]
}
```

### 局部变量类型推断升级

> 在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样的语法。

```java
//错误的形式: 必须要有类型, 可以加上var
//Consumer<String> con1 = (@Deprecated t) -> System.out.println(t.toUpperCase());
//正确的形式:
//使用var的好处是在使用lambda表达式时给参数加上注解。
Consumer<String> con2 = (@Deprecated var t) -> System.out.println(t.toUpperCase());
```

### 全新的HTTP客户端API

> + HTTP，用于传输网页的协议，早在1997年就被采用在目前的1.1版本中。直 到2015年，HTTP2才成为标准。
>
> + HTTP/1.1和HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。 HTTP/1.1依赖于请求/响应周期。 HTTP/2允许服务器“push”数据：它可以发 送比客户端请求更多的数据。这使得它可以优先处理并发送对于首先加载 网页至关重要的数据。
> + 这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 java.net 包中找到这个 API。
> + 它 将 替 代 仅 适 用 于 blocking 模式的 HttpURLConnection （HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的 方法），并提供对WebSocket 和 HTTP/2的支持。

```java
//java11新特性四：HttpClient替换原有的HttpURLConnection。
@Test
public void test4(){
  //同步的方式
  try {
    HttpClient client = HttpClient.newHttpClient();
    HttpRequest request = HttpRequest.newBuilder(URI.create("http://127.0.0.1:8080/test/")).build();
    HttpResponse.BodyHandler<String> responseBodyHandler = HttpResponse.BodyHandlers.ofString();
    HttpResponse<String> response = client.send(request, responseBodyHandler);
    String body = response.body();
    System.out.println(body);
  } catch (IOException e) {
    e.printStackTrace();
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
  //异步的方式
  HttpClient client = HttpClient.newHttpClient();
  HttpRequest request = HttpRequest.newBuilder(URI.create("http://127.0.0.1:8080/test/")).build();
  HttpResponse.BodyHandler<String> responseBodyHandler = HttpResponse.BodyHandlers.ofString();
  CompletableFuture<HttpResponse<String>> sendAsync = client.sendAsync(request, responseBodyHandler);
  sendAsync.thenApply(t -> t.body()).thenAccept(System.out::println);
  //HttpResponse<String> response = sendAsync.get();
  //String body = response.body();
  //System.out.println(body);
}
```

### 更简化的编译运行程序

> + 编译：javac Javastack.java
> + 运行：javac Javastack
>
> 在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。 而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示： java Javastack.java
>
> 一个命令编译运行源代码的注意点：
>
> + 执行源文件中的第一个类, 第一个类必须包含主方法，且只会找第一个类，其他类不找
> + 并且不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的（缺点）
> + 说白了，只适用于一个.java文件，若该.java文件中关联着其它.java文件，那还是分两步编译运行吧

### 其它新特性

> + 废弃Nashorn引擎：废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的 可以考虑使用GraalVM。
> + ZGC：
>   + GC是java主要优势之一。 然而, 当GC停顿太长, 就会开始影响应用的响应时 间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力 的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高 效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。
>   + ZGC, A Scalable Low-Latency Garbage Collector(Experimental) ZGC, 这应该是JDK11最为瞩目的特性, 没有之一。 但是后面带了Experimental, 说明这还不建议用到生产环境。
>   + ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会 STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长 而变长。
>   + 优势：
>     + ZGC暂停时间不会超过10ms
>     + 既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)
>     + 和G1相比, 应用吞吐能力不会下降超过15%
>     + 为未来的GC功能和利用colord指针以及Load barriers优化奠定基础
>     + 初始只支持64位系统
>   + ZGC的设计目标是：支持TB级内存容量，暂停时间低（<10ms），对整个 程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人 兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存）， 或压缩堆。
> + Unicode 10
> + Deprecate the Pack200 Tools and API
> + 新的Epsilon垃圾收集器
> + 完全支持Linux容器（包括Docker）
> + 支持G1上的并行完全垃圾收集
> + 最新的HTTPS安全协议TLS 1.3
> + Java Flight Recorder：在宕机前会记录操作数据【相当于黑匣子】

# 拓展

## 获取随机数

```java
//生成10-99之间的随机数
(int)(Math.random() * 99 - 10 + 1) + 10
//求a-b之间的随机数的公式为(int)((Math.random() * b - a + 1) + a)
```

## 理解万事万物皆对象

+ 在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
+ 涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类的对象

## JavaBean

> JavaBean是一种Java语言写成的可重用组件

### JavaBean的标准特征

+ 类是公共的
+ 有一个无参数的公共构造器
+ 有属性，且有对应的getter、setter方法

## MVC设计模式

> MVC是常用的设计模式之一：将整个程序分为三个层次：视图模型层、控制器层、数据模型层，这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式，释程序结构变得灵活清晰，同时也描述了程序各个对象之间的通信方式，降低了程序的耦合性

## Eclipse常用快捷键

|               快捷键                |                         功能定义                         |
| :---------------------------------: | :------------------------------------------------------: |
|               alt + /               |                      补全代码的声明                      |
|              ctrl + 1               |                         快速修复                         |
|          ctrl + shift + o           |                         批量导包                         |
|              ctrl + /               |                         单行注释                         |
|          ctrl + shift + /           |                         多行注释                         |
|          ctrl + shift + \           |                       取消多行注释                       |
|           ctrl + alt + ↓            |                   向下复制多行当前语句                   |
|           ctrl + alt + ↑            |                   向上复制多行当前语句                   |
|              ctrl + D               |                      删除指定行代码                      |
|               alt + ↑               |                         上移代码                         |
|               alt + ↓               |                         下移代码                         |
|            shift + enter            |                   切换至下一行代码空位                   |
|        ctrl + shift + enter         |                   切换至上一行代码空位                   |
| ctrl + 选中结构\|\|ctrl + shift + T |                         查看源码                         |
|               alt + ←               |                  返回上一个编辑过的页面                  |
|               alt + →               |                  进入下一个编辑过的页面                  |
|        选中指定类 + ctrl + T        |                      查看继承树结构                      |
|              ctrl + z               |                       撤销当前操作                       |
|              ctrl + y               |                      反撤销当前操作                      |
|          ctrl + shift + F           |                      格式化规整代码                      |
|           选中结构 + tab            |              选中数行整体向后移动一个制表符              |
|             shift + tab             |              选中数行整体往前移动一个制表符              |
|              ctrl + o               | 在当前类中显示类的结构<br />并支持搜索指定的方法、属性等 |
|           alt + shift + R           |           批量修改指定的方法名、变量名、类名等           |
|          ctrl + shift + x           |                 选中的结构进行大写的转换                 |
|          ctrl + shift + y           |                 选中的结构进行小写的转换                 |
|           alt + shift + S           |          调出生成setter、getter构造器等功能界面          |
|             alt + enter             |           显示当前选择资源（工程或文件）的属性           |
|              ctrl + k               |        快速查找，参照选中的打word快速定位到下一个        |
|              ctrl + w               |                       关闭当前窗口                       |
|          ctrl + shift + w           |                       关闭所有窗口                       |
|           ctrl + alt + g            |                查看指定的结构使用过的地方                |
|              ctrl + f               |                        查找与替换                        |
|              ctrl + m               |                     最大化当前的View                     |
|                home                 |                  直接定位到当前行的首位                  |
|                 end                 |                  直接定位到当前行的末尾                  |

***

## Junit 单元测试类

### Eclipse设置和操作步骤

+ 选中当前工程，右键build path→add libraries→junit 4→下一步
+ 创建Java公共类，此类提供公共的无参的构造器
+ 声明单元测试方法，方法的权限是public，无返回值，无形参
+ 方法需要声明@Test注解，并导入org.junit.Test
+ 如果执行结果没有任何异常就是绿条，不然就是红条

# 文字颜色

> 标题色：#fc5531
>
> 小标题：#FF9966



